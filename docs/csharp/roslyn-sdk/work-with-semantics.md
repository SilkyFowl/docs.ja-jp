---
title: .NET Compiler Platform SDK セマンティック モデルの使用
description: この概要は、コードのセマンティック モデルを理解して操作するために使用する型を理解するためのものです。
ms.date: 10/15/2017
ms.custom: mvc
ms.openlocfilehash: f0d254045a168f82888c5cc77a34f194a68aed0e
ms.sourcegitcommit: 8299abfbd5c49b596d61f1e4d09bc6b8ba055b36
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/27/2021
ms.locfileid: "98899127"
---
# <a name="work-with-semantics"></a><span data-ttu-id="a92e3-103">セマンティクスの使用</span><span class="sxs-lookup"><span data-stu-id="a92e3-103">Work with semantics</span></span>

<span data-ttu-id="a92e3-104">[構文ツリー](work-with-syntax.md)は、ソース コードの字句および構文構造を表します。</span><span class="sxs-lookup"><span data-stu-id="a92e3-104">[Syntax trees](work-with-syntax.md) represent the lexical and syntactic structure of source code.</span></span> <span data-ttu-id="a92e3-105">ソースのすべての宣言とロジックを説明するにはこの情報だけで十分ですが、参照内容を識別するには十分ではありません。</span><span class="sxs-lookup"><span data-stu-id="a92e3-105">Although this information alone is enough to describe all the declarations and logic in the source, it is not enough information to identify what is being referenced.</span></span> <span data-ttu-id="a92e3-106">名前は以下を表す場合があります。</span><span class="sxs-lookup"><span data-stu-id="a92e3-106">A name may represent:</span></span>

- <span data-ttu-id="a92e3-107">型</span><span class="sxs-lookup"><span data-stu-id="a92e3-107">a type</span></span>
- <span data-ttu-id="a92e3-108">フィールド</span><span class="sxs-lookup"><span data-stu-id="a92e3-108">a field</span></span>
- <span data-ttu-id="a92e3-109">メソッド</span><span class="sxs-lookup"><span data-stu-id="a92e3-109">a method</span></span>
- <span data-ttu-id="a92e3-110">ローカル変数</span><span class="sxs-lookup"><span data-stu-id="a92e3-110">a local variable</span></span>

<span data-ttu-id="a92e3-111">これらはそれぞれ一意に異なりますが、実際に識別子が指しているものを判別するには、多くの場合、言語規則をよく理解する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a92e3-111">Although each of these is uniquely different, determining which one an identifier actually refers to often requires a deep understanding of the language rules.</span></span>

<span data-ttu-id="a92e3-112">ソース コードで表されるプログラム要素がいくつかあります。プログラムは、以前にコンパイルされ、アセンブリ ファイルにパッケージ化されたライブラリを参照することもできます。</span><span class="sxs-lookup"><span data-stu-id="a92e3-112">There are program elements represented in source code, and programs can also refer to previously compiled libraries, packaged in assembly files.</span></span> <span data-ttu-id="a92e3-113">アセンブリで使用できるソース コードはありません (したがって、構文ノードやツリーもありません) が、プログラムは引き続き、その内部の要素を参照することができます。</span><span class="sxs-lookup"><span data-stu-id="a92e3-113">Although no source code, and therefore no syntax nodes or trees, are available for assemblies, programs can still refer to elements inside them.</span></span>

<span data-ttu-id="a92e3-114">これらのタスクには、**セマンティック モデル** が必要です。</span><span class="sxs-lookup"><span data-stu-id="a92e3-114">For those tasks, you need the **Semantic model**.</span></span>

<span data-ttu-id="a92e3-115">ソース コードの構文モデルだけでなく、セマンティック モデルでも言語規則がカプセル化されます。これにより、参照される正しいプログラム要素と識別子を簡単に一致させることができます。</span><span class="sxs-lookup"><span data-stu-id="a92e3-115">In addition to a syntactic model of the source code, a semantic model encapsulates the language rules, giving you an easy way to correctly match identifiers with the correct program element being referenced.</span></span>

## <a name="compilation"></a><span data-ttu-id="a92e3-116">コンパイル</span><span class="sxs-lookup"><span data-stu-id="a92e3-116">Compilation</span></span>

<span data-ttu-id="a92e3-117">コンパイルは、C# または Visual Basic プログラムのコンパイルに必要なすべてを表します。これには、アセンブリ参照、コンパイラ オプション、ソース ファイルがすべて含まれます。</span><span class="sxs-lookup"><span data-stu-id="a92e3-117">A compilation is a representation of everything needed to compile a C# or Visual Basic program, which includes all the assembly references, compiler options, and source files.</span></span>

<span data-ttu-id="a92e3-118">この情報はすべて 1 か所にあるため、ソース コードに含まれる要素を詳細に説明することができます。</span><span class="sxs-lookup"><span data-stu-id="a92e3-118">Because all this information is in one place, the elements contained in the source code can be described in more detail.</span></span> <span data-ttu-id="a92e3-119">コンパイルでは、宣言される型、メンバー、または変数をそれぞれシンボルとして表します。</span><span class="sxs-lookup"><span data-stu-id="a92e3-119">The compilation represents each declared type, member, or variable as a symbol.</span></span> <span data-ttu-id="a92e3-120">コンパイルにはさまざまなメソッドが含まれています。これらは、ソース コードで宣言されているか、アセンブリからメタデータとしてインポートされたシンボルを見つけて関連付けるのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="a92e3-120">The compilation contains a variety of methods that help you find and relate the symbols that have either been declared in the source code or imported as metadata from an assembly.</span></span>

<span data-ttu-id="a92e3-121">構文ツリーと同じように、コンパイルは不変です。</span><span class="sxs-lookup"><span data-stu-id="a92e3-121">Similar to syntax trees, compilations are immutable.</span></span> <span data-ttu-id="a92e3-122">作成したコンパイルを自分自身で変更することも、共有する可能性のある他のユーザーが変更することもできません。</span><span class="sxs-lookup"><span data-stu-id="a92e3-122">After you create a compilation, it cannot be changed by you or anyone else you might be sharing it with.</span></span> <span data-ttu-id="a92e3-123">ただし、既存のコンパイルから新しいコンパイルを作成することはできます。その際に、変更を指定します。</span><span class="sxs-lookup"><span data-stu-id="a92e3-123">However, you can create a new compilation from an existing compilation, specifying a change as you do so.</span></span> <span data-ttu-id="a92e3-124">たとえば、追加のソース ファイルまたはアセンブリ参照が含まれる場合があることを除き、既存のコンパイルとあらゆる点で同じコンパイルを作成できます。</span><span class="sxs-lookup"><span data-stu-id="a92e3-124">For example, you might create a compilation that is the same in every way as an existing compilation, except it may include an additional source file or assembly reference.</span></span>

## <a name="symbols"></a><span data-ttu-id="a92e3-125">Symbols</span><span class="sxs-lookup"><span data-stu-id="a92e3-125">Symbols</span></span>

<span data-ttu-id="a92e3-126">シンボルは、ソース コードで宣言されたか、メタデータとしてアセンブリからインポートされた異なる要素を表します。</span><span class="sxs-lookup"><span data-stu-id="a92e3-126">A symbol represents a distinct element declared by the source code or imported from an assembly as metadata.</span></span> <span data-ttu-id="a92e3-127">すべての名前空間、型、メソッド、プロパティ、フィールド、イベント、パラメーター、またはローカル変数はシンボルで表されます。</span><span class="sxs-lookup"><span data-stu-id="a92e3-127">Every namespace, type, method, property, field, event, parameter, or local variable is represented by a symbol.</span></span>

<span data-ttu-id="a92e3-128"><xref:Microsoft.CodeAnalysis.Compilation> 型のさまざまなメソッドとプロパティは、シンボルを見つけるのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="a92e3-128">A variety of methods and properties on the <xref:Microsoft.CodeAnalysis.Compilation> type help you find symbols.</span></span> <span data-ttu-id="a92e3-129">たとえば、共通のメタデータ名で宣言された型のシンボルを見つけることができます。</span><span class="sxs-lookup"><span data-stu-id="a92e3-129">For example, you can find a symbol for a declared type by its common metadata name.</span></span> <span data-ttu-id="a92e3-130">グローバル名前空間をルートとするシンボルのツリーとしてシンボル テーブル全体にアクセスすることもできます。</span><span class="sxs-lookup"><span data-stu-id="a92e3-130">You can also access the entire symbol table as a tree of symbols rooted by the global namespace.</span></span>

<span data-ttu-id="a92e3-131">シンボルには、他の参照シンボルなど、ソースまたはメタデータからコンパイラが判別した追加情報も含まれます。</span><span class="sxs-lookup"><span data-stu-id="a92e3-131">Symbols also contain additional information that the compiler determines from the source or metadata, such as other referenced symbols.</span></span> <span data-ttu-id="a92e3-132">各種類のシンボルは <xref:Microsoft.CodeAnalysis.ISymbol> から派生した個別のインターフェイスによって表され、それぞれ独自のメソッドとプロパティで、コンパイラが収集した情報が詳細に示されます。</span><span class="sxs-lookup"><span data-stu-id="a92e3-132">Each kind of symbol is represented by a separate interface derived from <xref:Microsoft.CodeAnalysis.ISymbol>, each with its own methods and properties detailing the information the compiler has gathered.</span></span> <span data-ttu-id="a92e3-133">これらのプロパティの多くは、他のシンボルを直接参照します。</span><span class="sxs-lookup"><span data-stu-id="a92e3-133">Many of these properties directly reference other symbols.</span></span> <span data-ttu-id="a92e3-134">たとえば、<xref:Microsoft.CodeAnalysis.IMethodSymbol.ReturnType?displayProperty=nameWithType> プロパティは、メソッドから返される実際の型のシンボルを示します。</span><span class="sxs-lookup"><span data-stu-id="a92e3-134">For example, the <xref:Microsoft.CodeAnalysis.IMethodSymbol.ReturnType?displayProperty=nameWithType> property tells you the actual type symbol that the method returns.</span></span>

<span data-ttu-id="a92e3-135">シンボルは、ソース コードとメタデータ間の名前空間、型、メンバーの共通表現を示します。</span><span class="sxs-lookup"><span data-stu-id="a92e3-135">Symbols present a common representation of namespaces, types, and members, between source code and metadata.</span></span> <span data-ttu-id="a92e3-136">たとえば、ソース コードで宣言されたメソッドと、メタデータからインポートされたメソッドは両方とも、同じプロパティを持つ <xref:Microsoft.CodeAnalysis.IMethodSymbol> で表されます。</span><span class="sxs-lookup"><span data-stu-id="a92e3-136">For example, a method that was declared in source code and a method that was imported from metadata are both represented by an <xref:Microsoft.CodeAnalysis.IMethodSymbol> with the same properties.</span></span>

<span data-ttu-id="a92e3-137">シンボルは <xref:System.Reflection> API で表される CLR 型システムと概念が似ていますが、型だけでなく、モデル化を行うという点で優れています。</span><span class="sxs-lookup"><span data-stu-id="a92e3-137">Symbols are similar in concept to the CLR type system as represented by the <xref:System.Reflection> API, yet they are richer in that they model more than just types.</span></span> <span data-ttu-id="a92e3-138">名前空間、ローカル変数、ラベルはすべてシンボルです。</span><span class="sxs-lookup"><span data-stu-id="a92e3-138">Namespaces, local variables, and labels are all symbols.</span></span> <span data-ttu-id="a92e3-139">また、シンボルは、CLR 概念ではなく、言語概念を表します。</span><span class="sxs-lookup"><span data-stu-id="a92e3-139">In addition, symbols are a representation of language concepts, not CLR concepts.</span></span> <span data-ttu-id="a92e3-140">重複するものが多くありますが、意味のある違いも多くあります。</span><span class="sxs-lookup"><span data-stu-id="a92e3-140">There is a lot of overlap, but there are many meaningful distinctions as well.</span></span> <span data-ttu-id="a92e3-141">たとえば、C# または Visual Basic の反復子メソッドは単一のシンボルです。</span><span class="sxs-lookup"><span data-stu-id="a92e3-141">For instance, an iterator method in C# or Visual Basic is a single symbol.</span></span> <span data-ttu-id="a92e3-142">ただし、反復子メソッドが CLR メタデータに変換された場合、それは 1 つの型および複数のメソッドとなります。</span><span class="sxs-lookup"><span data-stu-id="a92e3-142">However, when the iterator method is translated to CLR metadata, it is a type and multiple methods.</span></span>

## <a name="semantic-model"></a><span data-ttu-id="a92e3-143">セマンティック モデル</span><span class="sxs-lookup"><span data-stu-id="a92e3-143">Semantic model</span></span>

<span data-ttu-id="a92e3-144">セマンティック モデルは、1 つのソース ファイルに対するすべてのセマンティック情報を表します。</span><span class="sxs-lookup"><span data-stu-id="a92e3-144">A semantic model represents all the semantic information for a single source file.</span></span> <span data-ttu-id="a92e3-145">これを使用して以下を検出できます。</span><span class="sxs-lookup"><span data-stu-id="a92e3-145">You can use it to discover the following:</span></span>

- <span data-ttu-id="a92e3-146">ソース内の特定の場所で参照されているシンボル。</span><span class="sxs-lookup"><span data-stu-id="a92e3-146">The symbols referenced at a specific location in source.</span></span>
- <span data-ttu-id="a92e3-147">任意の式の結果の型。</span><span class="sxs-lookup"><span data-stu-id="a92e3-147">The resultant type of any expression.</span></span>
- <span data-ttu-id="a92e3-148">エラーや警告など、すべての診断情報。</span><span class="sxs-lookup"><span data-stu-id="a92e3-148">All diagnostics, which are errors and warnings.</span></span>
- <span data-ttu-id="a92e3-149">ソース領域内外への変数のフロー状態。</span><span class="sxs-lookup"><span data-stu-id="a92e3-149">How variables flow in and out of regions of source.</span></span>
- <span data-ttu-id="a92e3-150">より予測的な質問に対する回答。</span><span class="sxs-lookup"><span data-stu-id="a92e3-150">The answers to more speculative questions.</span></span>
