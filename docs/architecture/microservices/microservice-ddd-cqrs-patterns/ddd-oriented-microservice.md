---
title: DDD 指向マイクロサービスの設計
description: コンテナー化された .NET アプリケーションの .NET マイクロサービス アーキテクチャ | DDD 指向の注文マイクロサービスの設計とそのアプリケーション レイヤーを理解する
ms.date: 01/13/2021
ms.openlocfilehash: 1d17f0842bb371ce65e96f33d25b2d6e94493396
ms.sourcegitcommit: a4cecb7389f02c27e412b743f9189bd2a6dea4d6
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/14/2021
ms.locfileid: "98188336"
---
# <a name="design-a-ddd-oriented-microservice"></a><span data-ttu-id="b0045-103">DDD 指向マイクロサービスの設計</span><span class="sxs-lookup"><span data-stu-id="b0045-103">Design a DDD-oriented microservice</span></span>

<span data-ttu-id="b0045-104">ドメイン駆動設計 (DDD) は、ユーザーのユース ケースに則したビジネスの現状に基づくモデリングを提唱します。</span><span class="sxs-lookup"><span data-stu-id="b0045-104">Domain-driven design (DDD) advocates modeling based on the reality of business as relevant to your use cases.</span></span> <span data-ttu-id="b0045-105">アプリケーションの構築のコンテキストで、DDD は問題をドメインと呼んで論じます。</span><span class="sxs-lookup"><span data-stu-id="b0045-105">In the context of building applications, DDD talks about problems as domains.</span></span> <span data-ttu-id="b0045-106">独立した問題領域のことを境界付けられたコンテキストと言い (境界コンテキストはそれぞれ特定のマイクロサービスに関連します)、共通の言語を使ってこれらの問題を論じることを重視します。</span><span class="sxs-lookup"><span data-stu-id="b0045-106">It describes independent problem areas as Bounded Contexts (each Bounded Context correlates to a microservice), and emphasizes a common language to talk about these problems.</span></span> <span data-ttu-id="b0045-107">また、内部実装をサポートするための多くの技術的概念とパターンも提案します。たとえば、([ドメイン モデル貧血症](https://martinfowler.com/bliki/AnemicDomainModel.html)ではなく) 豊富なモデルを持つドメイン エンティティ、値オブジェクト、集約、および集約ルート (またはルート エンティティ) のルールなどです。</span><span class="sxs-lookup"><span data-stu-id="b0045-107">It also suggests many technical concepts and patterns, like domain entities with rich models (no [anemic-domain model](https://martinfowler.com/bliki/AnemicDomainModel.html)), value objects, aggregates, and aggregate root (or root entity) rules to support the internal implementation.</span></span> <span data-ttu-id="b0045-108">このセクションでは、それらの内部パターンの設計と実装を紹介します。</span><span class="sxs-lookup"><span data-stu-id="b0045-108">This section introduces the design and implementation of those internal patterns.</span></span>

<span data-ttu-id="b0045-109">これらの DDD の技術的なルールとパターンは、DDD のアプローチを実装する上で学習が困難な障害と見なされることがあります。</span><span class="sxs-lookup"><span data-stu-id="b0045-109">Sometimes these DDD technical rules and patterns are perceived as obstacles that have a steep learning curve for implementing DDD approaches.</span></span> <span data-ttu-id="b0045-110">しかし、重要な部分はパターンそのものではなく、ビジネス上の問題に沿ってコードを組織することと、同じビジネス用語 (ユビキタス言語) を使用することです。</span><span class="sxs-lookup"><span data-stu-id="b0045-110">But the important part is not the patterns themselves, but organizing the code so it is aligned to the business problems, and using the same business terms (ubiquitous language).</span></span> <span data-ttu-id="b0045-111">また、DDD のアプローチを適用する必要があるのは、重要なビジネス ルールを持つ複雑なマイクロサービスを実装する場合だけです。</span><span class="sxs-lookup"><span data-stu-id="b0045-111">In addition, DDD approaches should be applied only if you are implementing complex microservices with significant business rules.</span></span> <span data-ttu-id="b0045-112">CRUD サービスなどのより単純な機能は、より単純なアプローチで管理できます。</span><span class="sxs-lookup"><span data-stu-id="b0045-112">Simpler responsibilities, like a CRUD service, can be managed with simpler approaches.</span></span>

<span data-ttu-id="b0045-113">マイクロサービスを設計および定義する際は、どこに境界線を引くかが主な課題です。</span><span class="sxs-lookup"><span data-stu-id="b0045-113">Where to draw the boundaries is the key task when designing and defining a microservice.</span></span> <span data-ttu-id="b0045-114">DDD のパターンは、ドメインが持つ複雑さを理解するために役立ちます。</span><span class="sxs-lookup"><span data-stu-id="b0045-114">DDD patterns help you understand the complexity in the domain.</span></span> <span data-ttu-id="b0045-115">ドメイン モデルでは、境界付けられたコンテキストごとに、ドメインをモデル化するためのエンティティ、値オブジェクト、集約を特定および定義します。</span><span class="sxs-lookup"><span data-stu-id="b0045-115">For the domain model for each Bounded Context, you identify and define the entities, value objects, and aggregates that model your domain.</span></span> <span data-ttu-id="b0045-116">ドメイン モデルを構築および改善すると、それは境界の中に組み込まれ、境界はコンテキストを定義します。</span><span class="sxs-lookup"><span data-stu-id="b0045-116">You build and refine a domain model that is contained within a boundary that defines your context.</span></span> <span data-ttu-id="b0045-117">これは明示的であり、マイクロサービスの形を取ります。</span><span class="sxs-lookup"><span data-stu-id="b0045-117">And that is explicit in the form of a microservice.</span></span> <span data-ttu-id="b0045-118">これらの境界内のコンポーネントは、最終的にマイクロサービスになります。ただし、場合によっては、BC またはビジネス マイクロサービスがいくつかの物理サービスから構成されることもあります。</span><span class="sxs-lookup"><span data-stu-id="b0045-118">The components within those boundaries end up being your microservices, although in some cases a BC or business microservices can be composed of several physical services.</span></span> <span data-ttu-id="b0045-119">DDD では境界が重要であり、マイクロサービスにとってもまたそうです。</span><span class="sxs-lookup"><span data-stu-id="b0045-119">DDD is about boundaries and so are microservices.</span></span>

## <a name="keep-the-microservice-context-boundaries-relatively-small"></a><span data-ttu-id="b0045-120">マイクロサービスのコンテキスト境界を比較的小さく保つ</span><span class="sxs-lookup"><span data-stu-id="b0045-120">Keep the microservice context boundaries relatively small</span></span>

<span data-ttu-id="b0045-121">境界付けられたコンテキストの境界をどこに引くかを決める際は、2 つの相反する目標のバランスをとります。</span><span class="sxs-lookup"><span data-stu-id="b0045-121">Determining where to place boundaries between Bounded Contexts balances two competing goals.</span></span> <span data-ttu-id="b0045-122">第一の点として、可能な限り小さいマイクロサービスを作ることがまず望まれます。しかし、これを主な原動力とすべきではありません。ひとまとめにすべきものが一緒になるように境界を引きます。</span><span class="sxs-lookup"><span data-stu-id="b0045-122">First, you want to initially create the smallest possible microservices, although that should not be the main driver; you should create a boundary around things that need cohesion.</span></span> <span data-ttu-id="b0045-123">第二の点として、マイクロサービス間の通信が多くなりすぎないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0045-123">Second, you want to avoid chatty communications between microservices.</span></span> <span data-ttu-id="b0045-124">これらの目標は、相反する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b0045-124">These goals can contradict one another.</span></span> <span data-ttu-id="b0045-125">両者のバランスをとる必要があり、そのためには、システムをできるだけ多くの小さなマイクロサービスに分解していき、境界付けられたコンテキストを新しく分離しようとするたびに通信境界が急増する地点にまで至る必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0045-125">You should balance them by decomposing the system into as many small microservices as you can until you see communication boundaries growing quickly with each additional attempt to separate a new Bounded Context.</span></span> <span data-ttu-id="b0045-126">1 つの境界付けられたコンテキストの中で鍵となるのは、まとまりです。</span><span class="sxs-lookup"><span data-stu-id="b0045-126">Cohesion is key within a single bounded context.</span></span>

<span data-ttu-id="b0045-127">これは、クラスを実装する場合の、[不適切な関係というコードのにおい](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy)に似ています。</span><span class="sxs-lookup"><span data-stu-id="b0045-127">It is similar to the [Inappropriate Intimacy code smell](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) when implementing classes.</span></span> <span data-ttu-id="b0045-128">2 つのマイクロサービスで互いに多くの協働が必要な場合は、両者を同じマイクロサービスにまとめた方が望ましいと考えられます。</span><span class="sxs-lookup"><span data-stu-id="b0045-128">If two microservices need to collaborate a lot with each other, they should probably be the same microservice.</span></span>

<span data-ttu-id="b0045-129">この側面に対する別の観点となるのは、自律性です。</span><span class="sxs-lookup"><span data-stu-id="b0045-129">Another way to look at this aspect is autonomy.</span></span> <span data-ttu-id="b0045-130">あるマイクロサービスが別のサービスに依存しなければ要求に直接対応できない場合、真に自律的であるとは言えません。</span><span class="sxs-lookup"><span data-stu-id="b0045-130">If a microservice must rely on another service to directly service a request, it is not truly autonomous.</span></span>

## <a name="layers-in-ddd-microservices"></a><span data-ttu-id="b0045-131">DDD マイクロサービス内のレイヤー</span><span class="sxs-lookup"><span data-stu-id="b0045-131">Layers in DDD microservices</span></span>

<span data-ttu-id="b0045-132">ビジネス上および技術上の複雑性が高いエンタープライズ アプリケーションは、ほとんどの場合、複数のレイヤーで定義されます。</span><span class="sxs-lookup"><span data-stu-id="b0045-132">Most enterprise applications with significant business and technical complexity are defined by multiple layers.</span></span> <span data-ttu-id="b0045-133">レイヤーとは、論理的な成果物であり、サービスの展開には関連しません。</span><span class="sxs-lookup"><span data-stu-id="b0045-133">The layers are a logical artifact, and are not related to the deployment of the service.</span></span> <span data-ttu-id="b0045-134">これが存在しているのは、開発者がコードの複雑さを管理できるようにするためです。</span><span class="sxs-lookup"><span data-stu-id="b0045-134">They exist to help developers manage the complexity in the code.</span></span> <span data-ttu-id="b0045-135">異なるレイヤーは (ドメイン モデル レイヤーとプレゼンテーション レイヤーなど) 種類も異なる場合があります。その場合はそれらの種類間の変換が必要です。</span><span class="sxs-lookup"><span data-stu-id="b0045-135">Different layers (like the domain model layer versus the presentation layer, etc.) might have different types, which mandate translations between those types.</span></span>

<span data-ttu-id="b0045-136">たとえば、データベースから読み込まれるエンティティがあるとします。</span><span class="sxs-lookup"><span data-stu-id="b0045-136">For example, an entity could be loaded from the database.</span></span> <span data-ttu-id="b0045-137">次いで、この情報の一部、または他のエンティティからの追加データを含む情報の集約が、REST Web API を介してクライアント UI に送信される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b0045-137">Then part of that information, or an aggregation of information including additional data from other entities, can be sent to the client UI through a REST Web API.</span></span> <span data-ttu-id="b0045-138">ここでポイントとなるのは、ドメイン エンティティはドメイン モデル レイヤーに含まれており、プレゼンテーション レイヤーなど、自分が属さない他の領域に伝搬されてはならないということです。</span><span class="sxs-lookup"><span data-stu-id="b0045-138">The point here is that the domain entity is contained within the domain model layer and should not be propagated to other areas that it does not belong to, like to the presentation layer.</span></span>

<span data-ttu-id="b0045-139">さらに、集約ルート (ルート エンティティ) によって制御される、常に有効なエンティティ (「[ドメイン モデル レイヤーでの検証の設計](domain-model-layer-validations.md)」セクションを参照) が必要です。</span><span class="sxs-lookup"><span data-stu-id="b0045-139">Additionally, you need to have always-valid entities (see the [Designing validations in the domain model layer](domain-model-layer-validations.md) section) controlled by aggregate roots (root entities).</span></span> <span data-ttu-id="b0045-140">したがって、エンティティをクライアント ビューにバインドしてはなりません。これは、UI レベルでは一部のデータがまだ検証されていないためです。</span><span class="sxs-lookup"><span data-stu-id="b0045-140">Therefore, entities should not be bound to client views, because at the UI level some data might still not be validated.</span></span> <span data-ttu-id="b0045-141">そのため、ViewModel が存在します。</span><span class="sxs-lookup"><span data-stu-id="b0045-141">This reason is what the ViewModel is for.</span></span> <span data-ttu-id="b0045-142">ViewModel は、専らプレゼンテーション レイヤーのニーズに応えるデータ モデルです。</span><span class="sxs-lookup"><span data-stu-id="b0045-142">The ViewModel is a data model exclusively for presentation layer needs.</span></span> <span data-ttu-id="b0045-143">ドメイン エンティティは ViewModel に直接属してはいません。</span><span class="sxs-lookup"><span data-stu-id="b0045-143">The domain entities do not belong directly to the ViewModel.</span></span> <span data-ttu-id="b0045-144">代わりに、ViewModel からドメイン エンティティ、あるいはその逆に変換する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0045-144">Instead, you need to translate between ViewModels and domain entities and vice versa.</span></span>

<span data-ttu-id="b0045-145">複雑性に対処するには、ドメイン モデルを集約ルートで管理することが重要です。これにより、そのエンティティのグループ (集約) に関係する不変条件とルールすべてが、確実に単一のエントリ ポイントまたはゲート (集約ルート) を通して実行されます。</span><span class="sxs-lookup"><span data-stu-id="b0045-145">When tackling complexity, it is important to have a domain model controlled by aggregate roots that make sure that all the invariants and rules related to that group of entities (aggregate) are performed through a single entry-point or gate, the aggregate root.</span></span>

<span data-ttu-id="b0045-146">図 7-5 は、階層化設計が eShopOnContainers アプリケーションにどのように実装されているかを示しています。</span><span class="sxs-lookup"><span data-stu-id="b0045-146">Figure 7-5 shows how a layered design is implemented in the eShopOnContainers application.</span></span>

![ドメイン駆動設計マイクロサービス内のレイヤーを示す図。](./media/ddd-oriented-microservice/domain-driven-design-microservice.png)

<span data-ttu-id="b0045-148">**図 7-5**。</span><span class="sxs-lookup"><span data-stu-id="b0045-148">**Figure 7-5**.</span></span> <span data-ttu-id="b0045-149">eShopOnContainers 内の注文マイクロサービスの DDD レイヤー</span><span class="sxs-lookup"><span data-stu-id="b0045-149">DDD layers in the ordering microservice in eShopOnContainers</span></span>

<span data-ttu-id="b0045-150">Ordering などの DDD マイクロサービスの 3 つのレイヤー。</span><span class="sxs-lookup"><span data-stu-id="b0045-150">The three layers in a DDD microservice like Ordering.</span></span> <span data-ttu-id="b0045-151">レイヤーはそれぞれ VS プロジェクトです。アプリケーション レイヤーは Ordering.API、ドメイン レイヤーは Ordering.Domain、インフラストラクチャ レイヤーは Ordering.Infrastructure です。</span><span class="sxs-lookup"><span data-stu-id="b0045-151">Each layer is a VS project: Application layer is Ordering.API, Domain layer is Ordering.Domain and the Infrastructure layer is Ordering.Infrastructure.</span></span> <span data-ttu-id="b0045-152">システムは、各レイヤーが他の特定のレイヤーとだけ通信するように設計する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0045-152">You want to design the system so that each layer communicates only with certain other layers.</span></span> <span data-ttu-id="b0045-153">各レイヤーが異なるクラス ライブラリとして実装されている場合、この方法の適用がより簡単になる可能性があります。これは、ライブラリ間に設定されている依存関係を明確に識別できるためです。</span><span class="sxs-lookup"><span data-stu-id="b0045-153">That approach may be easier to enforce if layers are implemented as different class libraries, because you can clearly identify what dependencies are set between libraries.</span></span> <span data-ttu-id="b0045-154">たとえば、ドメイン モデル レイヤーは他のレイヤーに依存関係を持ってはなりません (ドメイン モデル クラスは単純な従来の CLR オブジェクト、つまり [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) クラスでなければなりません)。</span><span class="sxs-lookup"><span data-stu-id="b0045-154">For instance, the domain model layer should not take a dependency on any other layer (the domain model classes should be Plain Old CLR Objects, or [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), classes).</span></span> <span data-ttu-id="b0045-155">図 7-6 に示すように、**Ordering.Domain** レイヤー ライブラリは .NET ライブラリまたは NuGet パッケージだけに依存関係があり、データ ライブラリや永続化ライブラリなどの他のカスタム ライブラリには依存関係がありません。</span><span class="sxs-lookup"><span data-stu-id="b0045-155">As shown in Figure 7-6, the **Ordering.Domain** layer library has dependencies only on the .NET libraries or NuGet packages, but not on any other custom library, such as data library or persistence library.</span></span>

![Ordering.Domain の依存関係のスクリーンショット。](./media/ddd-oriented-microservice/ordering-domain-dependencies.png)

<span data-ttu-id="b0045-157">**図 7-6**。</span><span class="sxs-lookup"><span data-stu-id="b0045-157">**Figure 7-6**.</span></span> <span data-ttu-id="b0045-158">レイヤーをライブラリとして実装すると、レイヤー間の依存関係の制御が改善できる</span><span class="sxs-lookup"><span data-stu-id="b0045-158">Layers implemented as libraries allow better control of dependencies between layers</span></span>

### <a name="the-domain-model-layer"></a><span data-ttu-id="b0045-159">ドメイン モデル レイヤー</span><span class="sxs-lookup"><span data-stu-id="b0045-159">The domain model layer</span></span>

<span data-ttu-id="b0045-160">Eric Evans の名著「[Domain Driven Design](https://domainlanguage.com/ddd/)」(ドメイン駆動設計) には、ドメイン モデル レイヤーとアプリケーション レイヤーについて、次のように記述されています。</span><span class="sxs-lookup"><span data-stu-id="b0045-160">Eric Evans's excellent book [Domain Driven Design](https://domainlanguage.com/ddd/) says the following about the domain model layer and the application layer.</span></span>

<span data-ttu-id="b0045-161">**ドメイン モデル レイヤー**:ビジネスの概念、ビジネス状況に関する情報、ビジネス ルールの表現を担当します。</span><span class="sxs-lookup"><span data-stu-id="b0045-161">**Domain Model Layer**: Responsible for representing concepts of the business, information about the business situation, and business rules.</span></span> <span data-ttu-id="b0045-162">ビジネス状況を反映する状態はここで制御および使用されますが、その状態を保管することの技術的な詳細はインフラストラクチャに委任されます。</span><span class="sxs-lookup"><span data-stu-id="b0045-162">State that reflects the business situation is controlled and used here, even though the technical details of storing it are delegated to the infrastructure.</span></span> <span data-ttu-id="b0045-163">このレイヤーは、ビジネス ソフトウェアの中核です。</span><span class="sxs-lookup"><span data-stu-id="b0045-163">This layer is the heart of business software.</span></span>

<span data-ttu-id="b0045-164">ドメイン モデル レイヤーは、ビジネスを表現する場です。</span><span class="sxs-lookup"><span data-stu-id="b0045-164">The domain model layer is where the business is expressed.</span></span> <span data-ttu-id="b0045-165">マイクロサービスのドメイン モデル レイヤーを .NET で実装する場合、そのレイヤーはデータと動作をキャプチャするドメイン エンティティを持つクラス ライブラリとしてコード化されます (ロジックを持つメソッド)。</span><span class="sxs-lookup"><span data-stu-id="b0045-165">When you implement a microservice domain model layer in .NET, that layer is coded as a class library with the domain entities that capture data plus behavior (methods with logic).</span></span>

<span data-ttu-id="b0045-166">[永続化非依存](https://deviq.com/persistence-ignorance/)の原則と[インフラストラクチャ非依存](https://ayende.com/blog/3137/infrastructure-ignorance)の原則に従って、このレイヤーではデータ永続化の詳細を完全に無視する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0045-166">Following the [Persistence Ignorance](https://deviq.com/persistence-ignorance/) and the [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, this layer must completely ignore data persistence details.</span></span> <span data-ttu-id="b0045-167">これらの永続化タスクは、インフラストラクチャ レイヤーによって実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0045-167">These persistence tasks should be performed by the infrastructure layer.</span></span> <span data-ttu-id="b0045-168">このため、このレイヤーはインフラストラクチャへの直接的な依存関係を持ってはなりません。つまり、重要なルールは、ドメイン モデルのエンティティ クラスは [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) にする必要があるということです。</span><span class="sxs-lookup"><span data-stu-id="b0045-168">Therefore, this layer should not take direct dependencies on the infrastructure, which means that an important rule is that your domain model entity classes should be [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s.</span></span>

<span data-ttu-id="b0045-169">ドメイン エンティティには、Entity Framework や NHibernate などのデータ アクセス インフラストラクチャ フレームワークへの直接的な依存関係 (たとえば、基底クラスからの派生) があってはなりません。</span><span class="sxs-lookup"><span data-stu-id="b0045-169">Domain entities should not have any direct dependency (like deriving from a base class) on any data access infrastructure framework like Entity Framework or NHibernate.</span></span> <span data-ttu-id="b0045-170">ドメイン エンティティが、どのインフラストラクチャ フレームワークで定義されたどの型から派生したものでもなく、それを実装したものでもないことが理想的です。</span><span class="sxs-lookup"><span data-stu-id="b0045-170">Ideally, your domain entities should not derive from or implement any type defined in any infrastructure framework.</span></span>

<span data-ttu-id="b0045-171">Entity Framework Core などの最新の ORM フレームワークのほとんどではこのアプローチが可能であり、ドメイン モデル クラスがインフラストラクチャに結合されないようになっています。</span><span class="sxs-lookup"><span data-stu-id="b0045-171">Most modern ORM frameworks like Entity Framework Core allow this approach, so that your domain model classes are not coupled to the infrastructure.</span></span> <span data-ttu-id="b0045-172">しかし、特定の NoSQL データベースとフレームワークを使用する場合 (Azure Service Fabric の Actors と Reliable Collections など) は、POCO エンティティを使用することがいつでも可能とは限りません。</span><span class="sxs-lookup"><span data-stu-id="b0045-172">However, having POCO entities is not always possible when using certain NoSQL databases and frameworks, like Actors and Reliable Collections in Azure Service Fabric.</span></span>

<span data-ttu-id="b0045-173">ドメイン モデルで永続化非依存の原則に従うことが重要な場合でも、永続化に関する問題を無視してはなりません。</span><span class="sxs-lookup"><span data-stu-id="b0045-173">Even when it is important to follow the Persistence Ignorance principle for your Domain model, you should not ignore persistence concerns.</span></span> <span data-ttu-id="b0045-174">物理的なデータ モデルと、それがどのようにエンティティ オブジェクト モデルにマップされるかを理解しておくことが引き続き重要です。</span><span class="sxs-lookup"><span data-stu-id="b0045-174">It is still important to understand the physical data model and how it maps to your entity object model.</span></span> <span data-ttu-id="b0045-175">そうしないと、不可能な設計を作成してしまう可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b0045-175">Otherwise you can create impossible designs.</span></span>

<span data-ttu-id="b0045-176">また、この側面は、リレーショナル データベース用に設計されたモデルを採用して、それを NoSQL またはドキュメント指向のデータベースに直接移行できるという意味ではありません。</span><span class="sxs-lookup"><span data-stu-id="b0045-176">Also, this aspect does not mean you can take a model designed for a relational database and directly move it to a NoSQL or document-oriented database.</span></span> <span data-ttu-id="b0045-177">このモデルが適合するエンティティ モデルもありますが、たいていは適合しません。</span><span class="sxs-lookup"><span data-stu-id="b0045-177">In some entity models, the model might fit, but usually it does not.</span></span> <span data-ttu-id="b0045-178">ストレージ テクノロジと ORM テクノロジの両方に基づき、エンティティ モデルが従う必要のある制約はまだあります。</span><span class="sxs-lookup"><span data-stu-id="b0045-178">There are still constraints that your entity model must adhere to, based both on the storage technology and ORM technology.</span></span>

### <a name="the-application-layer"></a><span data-ttu-id="b0045-179">アプリケーション レイヤー</span><span class="sxs-lookup"><span data-stu-id="b0045-179">The application layer</span></span>

<span data-ttu-id="b0045-180">アプリケーション レイヤーに移ります。ここでも、Eric Evans の著書「[Domain Driven Design](https://domainlanguage.com/ddd/)」の引用を示します。</span><span class="sxs-lookup"><span data-stu-id="b0045-180">Moving on to the application layer, we can again cite Eric Evans's book [Domain Driven Design](https://domainlanguage.com/ddd/):</span></span>

<span data-ttu-id="b0045-181">**アプリケーション レイヤー:** ソフトウェアが実行するはずのジョブを定義し、表現力が豊かなドメイン オブジェクトに問題解決を指示します。</span><span class="sxs-lookup"><span data-stu-id="b0045-181">**Application Layer:** Defines the jobs the software is supposed to do and directs the expressive domain objects to work out problems.</span></span> <span data-ttu-id="b0045-182">このレイヤーが担当するタスクは、ビジネスにとって重要であるか、他のシステムのアプリケーション レイヤーとの対話に必要です。</span><span class="sxs-lookup"><span data-stu-id="b0045-182">The tasks this layer is responsible for are meaningful to the business or necessary for interaction with the application layers of other systems.</span></span> <span data-ttu-id="b0045-183">このレイヤーは小さなものに保ちます。</span><span class="sxs-lookup"><span data-stu-id="b0045-183">This layer is kept thin.</span></span> <span data-ttu-id="b0045-184">これにはビジネス ルールもナレッジも含まれません。これは、ただ各タスクを調整して、下方にある次のレイヤーのドメイン オブジェクトのコラボレーションに作業を委任するに過ぎません。</span><span class="sxs-lookup"><span data-stu-id="b0045-184">It does not contain business rules or knowledge, but only coordinates tasks and delegates work to collaborations of domain objects in the next layer down.</span></span> <span data-ttu-id="b0045-185">このレイヤーは、ビジネス状況を反映する状態を持ちませんが、ユーザーまたはプログラムのタスクの進行状況を反映する状態を持つことはできます。</span><span class="sxs-lookup"><span data-stu-id="b0045-185">It does not have state reflecting the business situation, but it can have state that reflects the progress of a task for the user or the program.</span></span>

<span data-ttu-id="b0045-186">.NET 内のマイクロサービスのアプリケーション レイヤーは、一般に ASP.NET Core Web API プロジェクトとしてコーディングされます。</span><span class="sxs-lookup"><span data-stu-id="b0045-186">A microservice's application layer in .NET is commonly coded as an ASP.NET Core Web API project.</span></span> <span data-ttu-id="b0045-187">プロジェクトでは、マイクロサービスの相互作用、リモート ネットワーク アクセス、UI またはクライアント アプリから使用される外部の Web API が実装されます。</span><span class="sxs-lookup"><span data-stu-id="b0045-187">The project implements the microservice's interaction, remote network access, and the external Web APIs used from the UI or client apps.</span></span> <span data-ttu-id="b0045-188">これには、クエリ (CQRS アプローチを使用する場合)、マイクロサービスによって受け付けられるコマンド、さらにはマイクロサービス (統合イベント) 間のイベント駆動通信さえも含まれます。</span><span class="sxs-lookup"><span data-stu-id="b0045-188">It includes queries if using a CQRS approach, commands accepted by the microservice, and even the event-driven communication between microservices (integration events).</span></span> <span data-ttu-id="b0045-189">アプリケーション レイヤーを表す ASP.NET Core Web API には、ビジネス ルールもドメインに関するナレッジも含まれていてはなりません (特にトランザクションまたは更新のドメイン ルール)。つまり、これらを所有するのはドメイン モデル クラス ライブラリでなければなりません。</span><span class="sxs-lookup"><span data-stu-id="b0045-189">The ASP.NET Core Web API that represents the application layer must not contain business rules or domain knowledge (especially domain rules for transactions or updates); these should be owned by the domain model class library.</span></span> <span data-ttu-id="b0045-190">アプリケーション レイヤーでは、各タスクの調整だけを行うべきであり、ドメインの状態 (ドメイン モデル) の保持も定義も行ってはなりません。</span><span class="sxs-lookup"><span data-stu-id="b0045-190">The application layer must only coordinate tasks and must not hold or define any domain state (domain model).</span></span> <span data-ttu-id="b0045-191">ビジネス ルールの実行はドメイン モデル クラス自体 (集約ルートとドメイン エンティティ) に委任され、その結果、それらのドメイン エンティティ内でデータが最終的に更新されます。</span><span class="sxs-lookup"><span data-stu-id="b0045-191">It delegates the execution of business rules to the domain model classes themselves (aggregate roots and domain entities), which will ultimately update the data within those domain entities.</span></span>

<span data-ttu-id="b0045-192">基本的に言って、アプリケーション ロジックには、特定のフロント エンドを利用するすべてのユース ケースを実装します。</span><span class="sxs-lookup"><span data-stu-id="b0045-192">Basically, the application logic is where you implement all use cases that depend on a given front end.</span></span> <span data-ttu-id="b0045-193">たとえば、Web API サービスに関連する実装です。</span><span class="sxs-lookup"><span data-stu-id="b0045-193">For example, the implementation related to a Web API service.</span></span>

<span data-ttu-id="b0045-194">目標は、ドメイン モデル レイヤー内のドメイン ロジック、その不変条件、データ モデル、関連するビジネス ルールを、プレゼンテーション レイヤーとアプリケーション レイヤーから完全に独立させなければならないということです。</span><span class="sxs-lookup"><span data-stu-id="b0045-194">The goal is that the domain logic in the domain model layer, its invariants, the data model, and related business rules must be completely independent from the presentation and application layers.</span></span> <span data-ttu-id="b0045-195">第一に、ドメイン モデル レイヤーは、どのインフラストラクチャ フレームワークにも直接的に依存していてはなりません。</span><span class="sxs-lookup"><span data-stu-id="b0045-195">Most of all, the domain model layer must not directly depend on any infrastructure framework.</span></span>

### <a name="the-infrastructure-layer"></a><span data-ttu-id="b0045-196">インフラストラクチャ レイヤー</span><span class="sxs-lookup"><span data-stu-id="b0045-196">The infrastructure layer</span></span>

<span data-ttu-id="b0045-197">インフラストラクチャ レイヤーは、最初にドメイン エンティティ (メモリ内) に保持されているデータを、データベースまたは別の永続ストアに永続化する方法を表します。</span><span class="sxs-lookup"><span data-stu-id="b0045-197">The infrastructure layer is how the data that is initially held in domain entities (in memory) is persisted in databases or another persistent store.</span></span> <span data-ttu-id="b0045-198">一例は、Entity Framework Core コードを使用して、DbContext でリレーショナル データベースにデータを永続化するリポジトリ パターン クラスを実装することです。</span><span class="sxs-lookup"><span data-stu-id="b0045-198">An example is using Entity Framework Core code to implement the Repository pattern classes that use a DBContext to persist data in a relational database.</span></span>

<span data-ttu-id="b0045-199">上で説明した[永続化非依存](https://deviq.com/persistence-ignorance/)の原則と[インフラストラクチャ非依存](https://ayende.com/blog/3137/infrastructure-ignorance)の原則に従って、インフラストラクチャ レイヤーはドメイン モデル レイヤーを "汚染" してはなりません。</span><span class="sxs-lookup"><span data-stu-id="b0045-199">In accordance with the previously mentioned [Persistence Ignorance](https://deviq.com/persistence-ignorance/) and [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, the infrastructure layer must not "contaminate" the domain model layer.</span></span> <span data-ttu-id="b0045-200">ドメイン モデル エンティティ クラスは、データの保存に使用するインフラストラクチャ (EF または他のフレームワーク) にとらわれないようにしておく必要があります。そのために、フレームワークに対する強い依存関係を持たせないようにします。</span><span class="sxs-lookup"><span data-stu-id="b0045-200">You must keep the domain model entity classes agnostic from the infrastructure that you use to persist data (EF or any other framework) by not taking hard dependencies on frameworks.</span></span> <span data-ttu-id="b0045-201">ドメイン モデル レイヤー クラス ライブラリには、ソフトウェアの中核部分を実装するドメイン コード、つまり [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) エンティティ クラスだけを含め、インフラストラクチャ テクノロジからは完全に分離させる必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0045-201">Your domain model layer class library should have only your domain code, just [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) entity classes implementing the heart of your software and completely decoupled from infrastructure technologies.</span></span>

<span data-ttu-id="b0045-202">したがって、図 7-7 に示すように、レイヤーまたはクラス ライブラリとプロジェクトは、最終的にドメイン モデル レイヤー (ライブラリ) に依存するはずで、逆方向の依存はありません。</span><span class="sxs-lookup"><span data-stu-id="b0045-202">Thus, your layers or class libraries and projects should ultimately depend on your domain model layer (library), not vice versa, as shown in Figure 7-7.</span></span>

![DDD サービス レイヤー間に存在する依存関係を示す図。](./media/ddd-oriented-microservice/ddd-service-layer-dependencies.png)

<span data-ttu-id="b0045-204">**図 7-7**。</span><span class="sxs-lookup"><span data-stu-id="b0045-204">**Figure 7-7**.</span></span> <span data-ttu-id="b0045-205">DDD 内のレイヤー間の依存関係</span><span class="sxs-lookup"><span data-stu-id="b0045-205">Dependencies between layers in DDD</span></span>

<span data-ttu-id="b0045-206">DDD サービスの依存関係、アプリケーション レイヤーはドメインとインフラストラクチャに依存し、インフラストラクチャはドメインに依存しますが、ドメインはレイヤーに依存しません。</span><span class="sxs-lookup"><span data-stu-id="b0045-206">Dependencies in a DDD Service, the Application layer depends on Domain and Infrastructure, and Infrastructure depends on Domain, but Domain doesn't depend on any layer.</span></span> <span data-ttu-id="b0045-207">このレイヤー設計は、マイクロサービスごとに独立している必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0045-207">This layer design should be independent for each microservice.</span></span> <span data-ttu-id="b0045-208">上述のとおり、最も複雑なマイクロサービスは DDD のパターンに従って実装できますが、単純なデータ駆動マイクロサービス (単一レイヤーの単純な CRUD) はより単純な方法で実装します。</span><span class="sxs-lookup"><span data-stu-id="b0045-208">As noted earlier, you can implement the most complex microservices following DDD patterns, while implementing simpler data-driven microservices (simple CRUD in a single layer) in a simpler way.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="b0045-209">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="b0045-209">Additional resources</span></span>

- <span data-ttu-id="b0045-210">**DevIQ。永続性無視の原則** </span><span class="sxs-lookup"><span data-stu-id="b0045-210">**DevIQ. Persistence Ignorance principle** </span></span>\
  <https://deviq.com/persistence-ignorance/>

- <span data-ttu-id="b0045-211">**Oren Eini。インフラストラクチャの無視** </span><span class="sxs-lookup"><span data-stu-id="b0045-211">**Oren Eini. Infrastructure Ignorance** </span></span>\
  <https://ayende.com/blog/3137/infrastructure-ignorance>

- <span data-ttu-id="b0045-212">**Angel Lopez。ドメイン駆動設計での階層化アーキテクチャ** </span><span class="sxs-lookup"><span data-stu-id="b0045-212">**Angel Lopez. Layered Architecture In Domain-Driven Design** </span></span>\
  <https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/>

>[!div class="step-by-step"]
><span data-ttu-id="b0045-213">[前へ](cqrs-microservice-reads.md)
>[次へ](microservice-domain-model.md)</span><span class="sxs-lookup"><span data-stu-id="b0045-213">[Previous](cqrs-microservice-reads.md)
[Next](microservice-domain-model.md)</span></span>
