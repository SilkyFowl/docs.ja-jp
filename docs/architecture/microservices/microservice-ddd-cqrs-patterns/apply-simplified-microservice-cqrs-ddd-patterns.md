---
title: マイクロサービスに簡略化された CQRS と DDD パターンを適用する
description: コンテナー化された .NET アプリケーションの .NET マイクロサービス アーキテクチャ | CQRS と DDD のパターンの全体的な関係を理解する。
ms.date: 01/13/2021
ms.openlocfilehash: c1a990689a446e2efba48beafe4b55d614b54427
ms.sourcegitcommit: a4cecb7389f02c27e412b743f9189bd2a6dea4d6
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/14/2021
ms.locfileid: "98188960"
---
# <a name="apply-simplified-cqrs-and-ddd-patterns-in-a-microservice"></a><span data-ttu-id="783e5-103">マイクロサービスに簡略化された CQRS と DDD のパターンを適用する</span><span class="sxs-lookup"><span data-stu-id="783e5-103">Apply simplified CQRS and DDD patterns in a microservice</span></span>

<span data-ttu-id="783e5-104">CQRS は、データを読み取りと書き込みのモデルを分離するアーキテクチャ パターンです。</span><span class="sxs-lookup"><span data-stu-id="783e5-104">CQRS is an architectural pattern that separates the models for reading and writing data.</span></span> <span data-ttu-id="783e5-105">関連する用語の [コマンド クエリ分離 (CQS: Command Query Separation)](https://martinfowler.com/bliki/CommandQuerySeparation.html) は、元々 Bertrand Meyer 氏が著作の『*Object Oriented Software Construction*』(オブジェクト指向のソフトウェア構築) で定義した用語です。</span><span class="sxs-lookup"><span data-stu-id="783e5-105">The related term [Command Query Separation (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html) was originally defined by Bertrand Meyer in his book *Object-Oriented Software Construction*.</span></span> <span data-ttu-id="783e5-106">基本的な考え方は、システムの操作は 2 つの別のカテゴリにはっきりと分けることができるということです。</span><span class="sxs-lookup"><span data-stu-id="783e5-106">The basic idea is that you can divide a system's operations into two sharply separated categories:</span></span>

- <span data-ttu-id="783e5-107">クエリ。</span><span class="sxs-lookup"><span data-stu-id="783e5-107">Queries.</span></span> <span data-ttu-id="783e5-108">これらのクエリによって結果が返され、システムの状態は変更されません。また、副作用はありません。</span><span class="sxs-lookup"><span data-stu-id="783e5-108">These queries return a result and do not change the state of the system, and they are free of side effects.</span></span>

- <span data-ttu-id="783e5-109">コマンド。</span><span class="sxs-lookup"><span data-stu-id="783e5-109">Commands.</span></span> <span data-ttu-id="783e5-110">これらのコマンドによってシステムの状態が変更されます。</span><span class="sxs-lookup"><span data-stu-id="783e5-110">These commands change the state of a system.</span></span>

<span data-ttu-id="783e5-111">CQS はシンプルな概念です。つまり、同じオブジェクト内のメソッドはクエリまたはコマンドである、というものです。</span><span class="sxs-lookup"><span data-stu-id="783e5-111">CQS is a simple concept: it is about methods within the same object being either queries or commands.</span></span> <span data-ttu-id="783e5-112">各メソッドは、状態を返すか、状態を変更しますが、両方を行うことはありません。</span><span class="sxs-lookup"><span data-stu-id="783e5-112">Each method either returns state or mutates state, but not both.</span></span> <span data-ttu-id="783e5-113">1 つのリポジトリ パターン オブジェクトでも、CQS に準拠する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="783e5-113">Even a single repository pattern object can comply with CQS.</span></span> <span data-ttu-id="783e5-114">CQS は CQRS の基本原則と考えることができます。</span><span class="sxs-lookup"><span data-stu-id="783e5-114">CQS can be considered a foundational principle for CQRS.</span></span>

<span data-ttu-id="783e5-115">[コマンド クエリ責務分離 (CQRS: Command and Query Responsibility Segregation)](https://martinfowler.com/bliki/CQRS.html) は Greg Young によって導入され、Udi Dahan などによって強く推進されました。</span><span class="sxs-lookup"><span data-stu-id="783e5-115">[Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) was introduced by Greg Young and strongly promoted by Udi Dahan and others.</span></span> <span data-ttu-id="783e5-116">CQRS は CQS の原則に基づいていますが、より詳細です。</span><span class="sxs-lookup"><span data-stu-id="783e5-116">It is based on the CQS principle, although it is more detailed.</span></span> <span data-ttu-id="783e5-117">コマンドとイベントに加え、必要に応じて非同期メッセージに基づくパターンと考えることができます。</span><span class="sxs-lookup"><span data-stu-id="783e5-117">It can be considered a pattern based on commands and events plus optionally on asynchronous messages.</span></span> <span data-ttu-id="783e5-118">CQRS は多くの場合、書き込み (更新) 用ではなく読み取り (クエリ) 用に異なる物理データベースを持つなど、より高度なシナリオに関連しています。</span><span class="sxs-lookup"><span data-stu-id="783e5-118">In many cases, CQRS is related to more advanced scenarios, like having a different physical database for reads (queries) than for writes (updates).</span></span> <span data-ttu-id="783e5-119">さらに進化した CQRS システムでは、更新プログラム データベースに[イベント ソーシング (ES)](https://martinfowler.com/eaaDev/EventSourcing.html) を実装することができるため、現在の状態のデータを格納するのではなく、ドメイン モデルにのみイベントを格納します。</span><span class="sxs-lookup"><span data-stu-id="783e5-119">Moreover, a more evolved CQRS system might implement [Event-Sourcing (ES)](https://martinfowler.com/eaaDev/EventSourcing.html) for your updates database, so you would only store events in the domain model instead of storing the current-state data.</span></span> <span data-ttu-id="783e5-120">ただし、この方法はこのガイドでは使用しません。</span><span class="sxs-lookup"><span data-stu-id="783e5-120">However, this approach is not used in this guide.</span></span> <span data-ttu-id="783e5-121">このガイドでは、クエリとコマンドを分離するだけの最も単純な CQRS アプローチを使用しています。</span><span class="sxs-lookup"><span data-stu-id="783e5-121">This guide uses the simplest CQRS approach, which consists of just separating the queries from the commands.</span></span>

<span data-ttu-id="783e5-122">CQRS の分離の側面は、あるレイヤーにクエリ操作を、別のレイヤーにコマンドをそれぞれグループ化することによって実現されます。</span><span class="sxs-lookup"><span data-stu-id="783e5-122">The separation aspect of CQRS is achieved by grouping query operations in one layer and commands in another layer.</span></span> <span data-ttu-id="783e5-123">各レイヤーには独自のデータ モデルがあります (モデルと言っている点に注意してください。必ずしも異なるデータベースではありません)。各レイヤーは独自のパターンとテクノロジの組み合わせを使用して構築されています。</span><span class="sxs-lookup"><span data-stu-id="783e5-123">Each layer has its own data model (note that we say model, not necessarily a different database) and is built using its own combination of patterns and technologies.</span></span> <span data-ttu-id="783e5-124">さらに重要な点は、このガイドで使用されている例 (注文マイクロサービス) のように、2 つのレイヤーが同じ階層またはマイクロサービス内に存在する可能性がある、ということです。</span><span class="sxs-lookup"><span data-stu-id="783e5-124">More importantly, the two layers can be within the same tier or microservice, as in the example (ordering microservice) used for this guide.</span></span> <span data-ttu-id="783e5-125">また、別のマイクロサービスまたはプロセス上に実装できるので、互いに影響を与えることなく個別に最適化およびスケールアウトすることができます。</span><span class="sxs-lookup"><span data-stu-id="783e5-125">Or they could be implemented on different microservices or processes so they can be optimized and scaled out separately without affecting one another.</span></span>

<span data-ttu-id="783e5-126">CQRS は、他のコンテキストでは 1 つのオブジェクトの場合でも、読み取り/書き込み操作のために 2 つのオブジェクトを持つことを意味します。</span><span class="sxs-lookup"><span data-stu-id="783e5-126">CQRS means having two objects for a read/write operation where in other contexts there is one.</span></span> <span data-ttu-id="783e5-127">非正規化された読み取りデータベースを持つことには理由があります。詳細については、より高度な CQRS のドキュメントを参照してください。</span><span class="sxs-lookup"><span data-stu-id="783e5-127">There are reasons to have a denormalized reads database, which you can learn about in more advanced CQRS literature.</span></span> <span data-ttu-id="783e5-128">ただし、ここではこのアプローチを使用していません。ここでは、集計のような DDD パターンの制約があるクエリを制限するのではなく、クエリに柔軟性を持たせることを目標としています。</span><span class="sxs-lookup"><span data-stu-id="783e5-128">But we are not using that approach here, where the goal is to have more flexibility in the queries instead of limiting the queries with constraints from DDD patterns like aggregates.</span></span>

<span data-ttu-id="783e5-129">この種のサービスの例として、eShopOnContainers 参照アプリケーションの注文マイクロサービスがあります。</span><span class="sxs-lookup"><span data-stu-id="783e5-129">An example of this kind of service is the ordering microservice from the eShopOnContainers reference application.</span></span> <span data-ttu-id="783e5-130">このサービスは、簡略化された CQRS アプローチに基づくマイクロサービスを実装しています。</span><span class="sxs-lookup"><span data-stu-id="783e5-130">This service implements a microservice based on a simplified CQRS approach.</span></span> <span data-ttu-id="783e5-131">また、図 7-2 に示すように、単一のデータ ソースまたはデータベースを使用しますが、トランザクション ドメインには 2 つの論理モデルと DDD パターンを使用します。</span><span class="sxs-lookup"><span data-stu-id="783e5-131">It uses a single data source or database, but two logical models plus DDD patterns for the transactional domain, as shown in Figure 7-2.</span></span>

![簡略化された CQRS と DDD マイクロサービスの概要を示す図](./media/apply-simplified-microservice-cqrs-ddd-patterns/simplified-cqrs-ddd-microservice.png)

<span data-ttu-id="783e5-133">**図 7-2**。</span><span class="sxs-lookup"><span data-stu-id="783e5-133">**Figure 7-2**.</span></span> <span data-ttu-id="783e5-134">簡略化された CQRS および DDD ベースのマイクロサービス</span><span class="sxs-lookup"><span data-stu-id="783e5-134">Simplified CQRS- and DDD-based microservice</span></span>

<span data-ttu-id="783e5-135">この論理的な "注文" マイクロサービスには、注文データベースが含まれています。これは、同じ Docker ホストの可能性もありますが、同じである必要はありません。</span><span class="sxs-lookup"><span data-stu-id="783e5-135">The Logical "Ordering" Microservice includes its Ordering database, which can be, but doesn't have to be, the same Docker host.</span></span> <span data-ttu-id="783e5-136">同じ Docker ホストにデータベースを置くことは開発の場合にお勧めしますが、運用の場合はお勧めしません。</span><span class="sxs-lookup"><span data-stu-id="783e5-136">Having the database in the same Docker host is good for development, but not for production.</span></span>

<span data-ttu-id="783e5-137">アプリケーション レイヤーは、Web API の可能性があります。</span><span class="sxs-lookup"><span data-stu-id="783e5-137">The application layer can be the Web API itself.</span></span> <span data-ttu-id="783e5-138">ここで重要な設計の側面は、マイクロサービスが、CQRS パターンに従って、クエリと ViewModel (特にクライアント アプリケーション用に作成されたデータ モデル) を、コマンド、ドメイン モデル、トランザクションから分離していることです。</span><span class="sxs-lookup"><span data-stu-id="783e5-138">The important design aspect here is that the microservice has split the queries and ViewModels (data models especially created for the client applications) from the commands, domain model, and transactions following the CQRS pattern.</span></span> <span data-ttu-id="783e5-139">このアプローチによって、トランザクションと更新にのみ意味のある DDD パターンに由来する制限と制約から、クエリを独立させることができます。詳細については、以降のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="783e5-139">This approach keeps the queries independent from restrictions and constraints coming from DDD patterns that only make sense for transactions and updates, as explained in later sections.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="783e5-140">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="783e5-140">Additional resources</span></span>

- <span data-ttu-id="783e5-141">**Greg Young。「Versioning in an Event Sourced System」** (オンライン電子書籍で無料提供) </span><span class="sxs-lookup"><span data-stu-id="783e5-141">**Greg Young. Versioning in an Event Sourced System** (Free to read online e-book) </span></span>\
   <https://leanpub.com/esversioning/read>

>[!div class="step-by-step"]
><span data-ttu-id="783e5-142">[前へ](index.md)
>[次へ](eshoponcontainers-cqrs-ddd-microservice.md)</span><span class="sxs-lookup"><span data-stu-id="783e5-142">[Previous](index.md)
[Next](eshoponcontainers-cqrs-ddd-microservice.md)</span></span>
