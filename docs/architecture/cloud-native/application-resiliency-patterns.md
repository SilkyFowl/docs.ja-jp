---
title: アプリケーションの回復性パターン
description: Azure 向けのクラウドネイティブ .NET アプリの設計 |アプリケーションの回復性パターン
author: robvet
ms.date: 01/19/2021
ms.openlocfilehash: 9a59a7d93b61b0dea11680f6caf0bd3b68a0f853
ms.sourcegitcommit: f2ab02d9a780819ca2e5310bbcf5cfe5b7993041
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/03/2021
ms.locfileid: "99505922"
---
# <a name="application-resiliency-patterns"></a><span data-ttu-id="0eaa7-103">アプリケーションの回復性パターン</span><span class="sxs-lookup"><span data-stu-id="0eaa7-103">Application resiliency patterns</span></span>

<span data-ttu-id="0eaa7-104">最初の防御ラインは、アプリケーションの回復性です。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-104">The first line of defense is application resiliency.</span></span>

<span data-ttu-id="0eaa7-105">独自の回復性フレームワークの作成にかなりの時間を費やすことができますが、このような製品は既に存在しています。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-105">While you could invest considerable time writing your own resiliency framework, such products already exist.</span></span> <span data-ttu-id="0eaa7-106">これは、開発者が堅牢性とスレッドセーフの方法で回復性ポリシーを表すことができる、包括的な .NET 復元と一時的な障害処理[ライブラリです。](http://www.thepollyproject.org/)</span><span class="sxs-lookup"><span data-stu-id="0eaa7-106">[Polly](http://www.thepollyproject.org/) is a comprehensive .NET resilience and transient-fault-handling library that allows developers to express resiliency policies in a fluent and thread-safe manner.</span></span> <span data-ttu-id="0eaa7-107">.NET Framework または .NET 5 でビルドされたアプリケーションを対象にしています。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-107">Polly targets applications built with either the .NET Framework or .NET 5.</span></span> <span data-ttu-id="0eaa7-108">次の表では、と呼ばれる回復性機能について説明し `policies` ます。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-108">The following table describes the resiliency features, called `policies`, available in the Polly Library.</span></span> <span data-ttu-id="0eaa7-109">個別に適用することも、グループ化することもできます。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-109">They can be applied individually or grouped together.</span></span>

| <span data-ttu-id="0eaa7-110">ポリシー</span><span class="sxs-lookup"><span data-stu-id="0eaa7-110">Policy</span></span> | <span data-ttu-id="0eaa7-111">エクスペリエンス</span><span class="sxs-lookup"><span data-stu-id="0eaa7-111">Experience</span></span> |
| :-------- | :-------- |
| <span data-ttu-id="0eaa7-112">[再試行]</span><span class="sxs-lookup"><span data-stu-id="0eaa7-112">Retry</span></span> | <span data-ttu-id="0eaa7-113">指定された操作に対する再試行操作を構成します。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-113">Configures retry operations on designated operations.</span></span> |
| <span data-ttu-id="0eaa7-114">サーキット ブレーカー</span><span class="sxs-lookup"><span data-stu-id="0eaa7-114">Circuit Breaker</span></span> | <span data-ttu-id="0eaa7-115">エラーが構成されたしきい値を超えると、事前に定義された期間、要求された操作をブロックする</span><span class="sxs-lookup"><span data-stu-id="0eaa7-115">Blocks requested operations for a predefined period when faults exceed a configured threshold</span></span> |
| <span data-ttu-id="0eaa7-116">タイムアウト</span><span class="sxs-lookup"><span data-stu-id="0eaa7-116">Timeout</span></span> | <span data-ttu-id="0eaa7-117">呼び出し元が応答を待機できる期間に制限を配置します。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-117">Places limit on the duration for which a caller can wait for a response.</span></span> |
| <span data-ttu-id="0eaa7-118">バルクヘッド</span><span class="sxs-lookup"><span data-stu-id="0eaa7-118">Bulkhead</span></span> | <span data-ttu-id="0eaa7-119">は、リソースプールの swamping からの呼び出しが失敗するのを防ぐために、固定サイズのリソースプールにアクションを制限します。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-119">Constrains actions to fixed-size resource pool to prevent failing calls from swamping a resource.</span></span> |
| <span data-ttu-id="0eaa7-120">キャッシュ</span><span class="sxs-lookup"><span data-stu-id="0eaa7-120">Cache</span></span> | <span data-ttu-id="0eaa7-121">応答を自動的に保存します。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-121">Stores responses automatically.</span></span> |
| <span data-ttu-id="0eaa7-122">フォールバック</span><span class="sxs-lookup"><span data-stu-id="0eaa7-122">Fallback</span></span> | <span data-ttu-id="0eaa7-123">エラー発生時の構造化動作を定義します。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-123">Defines structured behavior upon a failure.</span></span> |

<span data-ttu-id="0eaa7-124">前の図では、外部クライアントとバックエンドサービスのどちらであるかにかかわらず、回復性ポリシーが要求メッセージに適用されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-124">Note how in the previous figure the resiliency policies apply to request messages, whether coming from an external client or back-end service.</span></span> <span data-ttu-id="0eaa7-125">目標は、一時的に使用できなくなる可能性があるサービスの要求を補正することです。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-125">The goal is to compensate the request for a service that might be momentarily unavailable.</span></span> <span data-ttu-id="0eaa7-126">これらの短時間の中断は通常、次の表に示す HTTP 状態コードを使用してマニフェストに含まれます。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-126">These short-lived interruptions typically manifest themselves with the HTTP status codes shown in the following table.</span></span>

| <span data-ttu-id="0eaa7-127">HTTP 状態コード</span><span class="sxs-lookup"><span data-stu-id="0eaa7-127">HTTP Status Code</span></span>| <span data-ttu-id="0eaa7-128">原因</span><span class="sxs-lookup"><span data-stu-id="0eaa7-128">Cause</span></span> |
| :-------- | :-------- |
| <span data-ttu-id="0eaa7-129">404</span><span class="sxs-lookup"><span data-stu-id="0eaa7-129">404</span></span> | <span data-ttu-id="0eaa7-130">見つかりません</span><span class="sxs-lookup"><span data-stu-id="0eaa7-130">Not Found</span></span> |
| <span data-ttu-id="0eaa7-131">408</span><span class="sxs-lookup"><span data-stu-id="0eaa7-131">408</span></span> | <span data-ttu-id="0eaa7-132">要求タイムアウト</span><span class="sxs-lookup"><span data-stu-id="0eaa7-132">Request timeout</span></span> |
| <span data-ttu-id="0eaa7-133">429</span><span class="sxs-lookup"><span data-stu-id="0eaa7-133">429</span></span> | <span data-ttu-id="0eaa7-134">要求が多すぎます (おそらく、調整されている可能性があります)</span><span class="sxs-lookup"><span data-stu-id="0eaa7-134">Too many requests (you've most likely been throttled)</span></span> |
| <span data-ttu-id="0eaa7-135">502</span><span class="sxs-lookup"><span data-stu-id="0eaa7-135">502</span></span> | <span data-ttu-id="0eaa7-136">Bad gateway</span><span class="sxs-lookup"><span data-stu-id="0eaa7-136">Bad gateway</span></span> |
| <span data-ttu-id="0eaa7-137">503</span><span class="sxs-lookup"><span data-stu-id="0eaa7-137">503</span></span> | <span data-ttu-id="0eaa7-138">Service unavailable (サービス利用不可)</span><span class="sxs-lookup"><span data-stu-id="0eaa7-138">Service unavailable</span></span> |
| <span data-ttu-id="0eaa7-139">504</span><span class="sxs-lookup"><span data-stu-id="0eaa7-139">504</span></span> | <span data-ttu-id="0eaa7-140">ゲートウェイのタイムアウト</span><span class="sxs-lookup"><span data-stu-id="0eaa7-140">Gateway timeout</span></span> |

<span data-ttu-id="0eaa7-141">質問: HTTP 状態コード 403-許可されていないことを再試行しますか?</span><span class="sxs-lookup"><span data-stu-id="0eaa7-141">Question: Would you retry an HTTP Status Code of 403 - Forbidden?</span></span> <span data-ttu-id="0eaa7-142">いいえ。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-142">No.</span></span> <span data-ttu-id="0eaa7-143">ここでは、システムは正常に機能していますが、要求された操作を実行する権限がないことを呼び出し元に通知しています。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-143">Here, the system is functioning properly, but informing the caller that they aren't authorized to perform the requested operation.</span></span> <span data-ttu-id="0eaa7-144">障害によって発生した操作のみを再試行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-144">Care must be taken to retry only those operations caused by failures.</span></span>

<span data-ttu-id="0eaa7-145">第1章で推奨されているように、クラウドネイティブアプリケーションを構築する Microsoft 開発者は、.NET プラットフォームを対象とする必要があります。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-145">As recommended in Chapter 1, Microsoft developers constructing cloud-native applications should target the .NET platform.</span></span> <span data-ttu-id="0eaa7-146">バージョン2.1 では、URL ベースのリソースと対話するための HTTP クライアントインスタンスを作成するための [HTTPClientFactory](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore) ライブラリが導入されました。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-146">Version 2.1 introduced the [HTTPClientFactory](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore) library for creating HTTP Client instances for interacting with URL-based resources.</span></span> <span data-ttu-id="0eaa7-147">ファクトリクラスは、元の HTTPClient クラスを置き換えることで、多くの強化された機能をサポートしています。その1つは、厳密な回復性ライブラリとの [緊密な統合](../microservices/implement-resilient-applications/implement-http-call-retries-exponential-backoff-polly.md) です。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-147">Superseding the original HTTPClient class, the factory class supports many enhanced features, one of which is [tight integration](../microservices/implement-resilient-applications/implement-http-call-retries-exponential-backoff-polly.md) with the Polly resiliency library.</span></span> <span data-ttu-id="0eaa7-148">これを使用すると、アプリケーションのスタートアップクラスで復元ポリシーを簡単に定義して、部分的なエラーと接続の問題を処理することができます。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-148">With it, you can easily define resiliency policies in the application Startup class to handle partial failures and connectivity issues.</span></span>

<span data-ttu-id="0eaa7-149">次に、再試行とサーキットブレーカーパターンについて説明します。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-149">Next, let's expand on retry and circuit breaker patterns.</span></span>

### <a name="retry-pattern"></a><span data-ttu-id="0eaa7-150">再試行パターン</span><span class="sxs-lookup"><span data-stu-id="0eaa7-150">Retry pattern</span></span>

<span data-ttu-id="0eaa7-151">分散型クラウドネイティブ環境では、一時的な (有効期間が短い) エラーによって、サービスとクラウドリソースへの呼び出しが失敗することがあります。これは、通常、短時間の経過後に自動的に修正されます。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-151">In a distributed cloud-native environment, calls to services and cloud resources can fail because of transient (short-lived) failures, which typically correct themselves after a brief period of time.</span></span> <span data-ttu-id="0eaa7-152">再試行戦略を実装することは、クラウドネイティブサービスがこれらのシナリオを軽減するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-152">Implementing a retry strategy helps a cloud-native service mitigate these scenarios.</span></span>

<span data-ttu-id="0eaa7-153">[再試行パターン](/azure/architecture/patterns/retry)を使用すると、サービスは失敗した要求操作を (構成可能な) 回数指数関数的に増加する待機時間で再試行できます。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-153">The [Retry pattern](/azure/architecture/patterns/retry) enables a service to retry a failed request operation a (configurable) number of times with an exponentially increasing wait time.</span></span> <span data-ttu-id="0eaa7-154">図6-2 は、アクションの再試行を示しています。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-154">Figure 6-2 shows a retry in action.</span></span>

![再試行パターンのアクション](./media/retry-pattern.png)

<span data-ttu-id="0eaa7-156">**図 6-2**。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-156">**Figure 6-2**.</span></span> <span data-ttu-id="0eaa7-157">再試行パターンのアクション</span><span class="sxs-lookup"><span data-stu-id="0eaa7-157">Retry pattern in action</span></span>

<span data-ttu-id="0eaa7-158">前の図では、要求操作に対して再試行パターンが実装されています。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-158">In the previous figure, a retry pattern has been implemented for a request operation.</span></span> <span data-ttu-id="0eaa7-159">2秒間に最大で4回の再試行を許可するように構成されています。これは、後続の試行ごとに指数関数的に倍倍になります。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-159">It's configured to allow up to four retries before failing with a backoff interval (wait time) starting at two seconds, which exponentially doubles for each subsequent attempt.</span></span>

- <span data-ttu-id="0eaa7-160">最初の呼び出しは失敗し、HTTP 状態コード500が返されます。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-160">The first invocation fails and returns an HTTP status code of 500.</span></span> <span data-ttu-id="0eaa7-161">アプリケーションは2秒間待機し、呼び出しを再試行します。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-161">The application waits for two seconds and retries the call.</span></span>
- <span data-ttu-id="0eaa7-162">2番目の呼び出しも失敗し、HTTP 状態コード500が返されます。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-162">The second invocation also fails and returns an HTTP status code of 500.</span></span> <span data-ttu-id="0eaa7-163">これで、アプリケーションは、バックオフ間隔を4秒に2倍にし、呼び出しを再試行します。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-163">The application now doubles the backoff interval to four seconds and retries the call.</span></span>
- <span data-ttu-id="0eaa7-164">最後に、3番目の呼び出しが成功します。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-164">Finally, the third call succeeds.</span></span>
- <span data-ttu-id="0eaa7-165">このシナリオでは、再試行操作で最大4回の再試行が試行され、呼び出しが失敗する前にバックオフ期間が2倍になりました。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-165">In this scenario, the retry operation would have attempted up to four retries while doubling the backoff duration before failing the call.</span></span>
- <span data-ttu-id="0eaa7-166">4回目の再試行が失敗した場合、フォールバックポリシーが呼び出され、問題を適切に処理します。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-166">Had the 4th retry attempt failed, a fallback policy would be invoked to gracefully handle the problem.</span></span>

<span data-ttu-id="0eaa7-167">サービス時間が自己修正されるように、呼び出しを再試行する前にバックオフ期間を長くすることが重要です。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-167">It's important to increase the backoff period before retrying the call to allow the service time to self-correct.</span></span> <span data-ttu-id="0eaa7-168">最適な修正時間を実現するには、指数関数的に増加するバックオフを実装することをお勧めします (再試行ごとに期間を2倍にします)。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-168">It's a best practice to implement an exponentially increasing backoff (doubling the period on each retry) to allow adequate correction time.</span></span>

## <a name="circuit-breaker-pattern"></a><span data-ttu-id="0eaa7-169">サーキットブレーカーパターン</span><span class="sxs-lookup"><span data-stu-id="0eaa7-169">Circuit breaker pattern</span></span>

<span data-ttu-id="0eaa7-170">再試行パターンを使用すると、部分的な障害で要求を減らすことができますが、予期しないイベントが原因でエラーが発生する可能性があります。これは、解決に長時間かかることがあります。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-170">While the retry pattern can help salvage a request entangled in a partial failure, there are situations where failures can be caused by unanticipated events that will require longer periods of time to resolve.</span></span> <span data-ttu-id="0eaa7-171">このような障害の重大度は、部分的な接続の損失からサービスの完全な不具合まで多岐にわたります。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-171">These faults can range in severity from a partial loss of connectivity to the complete failure of a service.</span></span> <span data-ttu-id="0eaa7-172">このような状況では、アプリケーションが成功する可能性の低い操作を継続的に再試行することは無意味です。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-172">In these situations, it's pointless for an application to continually retry an operation that is unlikely to succeed.</span></span>

<span data-ttu-id="0eaa7-173">問題を悪化させるために、応答しないサービスに対して継続的な再試行操作を実行すると、継続的な呼び出しによってサービスがあふれ、メモリ、スレッド、データベース接続などのリソースが枯渇し、同じリソースを使用するシステムの関連しない部分で障害が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-173">To make things worse, executing continual retry operations on a non-responsive service can move you into a self-imposed denial of service scenario where you flood your service with continual calls exhausting resources such as memory, threads and database connections, causing failure in unrelated parts of the system that use the same resources.</span></span>

<span data-ttu-id="0eaa7-174">このような状況では、操作が直ちに失敗し、成功する可能性がある場合にのみサービスの呼び出しを試行することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-174">In these situations, it would be preferable for the operation to fail immediately and only attempt to invoke the service if it's likely to succeed.</span></span>

<span data-ttu-id="0eaa7-175">[サーキットブレーカーパターン](/azure/architecture/patterns/circuit-breaker)を使用すると、失敗する可能性のある操作をアプリケーションが繰り返し試行するのを防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-175">The [Circuit Breaker pattern](/azure/architecture/patterns/circuit-breaker) can prevent an application from repeatedly trying to execute an operation that's likely to fail.</span></span> <span data-ttu-id="0eaa7-176">事前に定義された回数の失敗した呼び出しは、サービスへのすべてのトラフィックをブロックします。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-176">After a pre-defined number of failed calls, it blocks all traffic to the service.</span></span> <span data-ttu-id="0eaa7-177">定期的に、試用版によってエラーが解決されたかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-177">Periodically, it will allow a trial call to determine whether the fault has resolved.</span></span> <span data-ttu-id="0eaa7-178">図6-3 は、動作中のサーキットブレーカーパターンを示しています。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-178">Figure 6-3 shows the Circuit Breaker pattern in action.</span></span>

![サーキットブレーカーパターンの動作](./media/circuit-breaker-pattern.png)

<span data-ttu-id="0eaa7-180">**図 6-3**。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-180">**Figure 6-3**.</span></span> <span data-ttu-id="0eaa7-181">サーキットブレーカーパターンの動作</span><span class="sxs-lookup"><span data-stu-id="0eaa7-181">Circuit breaker pattern in action</span></span>

<span data-ttu-id="0eaa7-182">前の図では、サーキットブレーカーパターンが元の再試行パターンに追加されています。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-182">In the previous figure, a Circuit Breaker pattern has been added to the original retry pattern.</span></span> <span data-ttu-id="0eaa7-183">100要求が失敗すると、サーキットブレーカーが開き、サービスの呼び出しが許可されなくなることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-183">Note how after 100 failed requests, the circuit breakers opens and no longer allows calls to the service.</span></span> <span data-ttu-id="0eaa7-184">[CheckCircuit] の値は30秒で設定され、ライブラリが1つの要求をサービスに継続することを許可する頻度を指定します。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-184">The CheckCircuit value, set at 30 seconds, specifies how often the library allows one request to proceed to the service.</span></span> <span data-ttu-id="0eaa7-185">その呼び出しが成功すると、回線が閉じられ、サービスはトラフィックに再び使用できるようになります。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-185">If that call succeeds, the circuit closes and the service is once again available to traffic.</span></span>

<span data-ttu-id="0eaa7-186">サーキットブレーカーパターンの目的は、再試行パターンとは *異なる* ことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-186">Keep in mind that the intent of the Circuit Breaker pattern is *different* than that of the Retry pattern.</span></span> <span data-ttu-id="0eaa7-187">再試行パターンを使用すると、アプリケーションは成功すると想定して操作を再試行できます。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-187">The Retry pattern enables an application to retry an operation in the expectation that it will succeed.</span></span> <span data-ttu-id="0eaa7-188">サーキットブレーカーパターンは、アプリケーションが失敗する可能性のある操作を実行できないようにします。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-188">The Circuit Breaker pattern prevents an application from doing an operation that is likely to fail.</span></span> <span data-ttu-id="0eaa7-189">通常、アプリケーションは、サーキットブレーカーを使用して操作を呼び出す再試行パターンを使用して、これら2つのパターンを *結合* します。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-189">Typically, an application will *combine* these two patterns by using the Retry pattern to invoke an operation through a circuit breaker.</span></span>

## <a name="testing-for-resiliency"></a><span data-ttu-id="0eaa7-190">回復性のテスト</span><span class="sxs-lookup"><span data-stu-id="0eaa7-190">Testing for resiliency</span></span>

<span data-ttu-id="0eaa7-191">回復性のテストは、(単体テストや統合テストなどを実行して) アプリケーション機能をテストする場合と同じ方法では、常に実行することはできません。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-191">Testing for resiliency cannot always be done the same way that you test application functionality (by running unit tests, integration tests, and so on).</span></span> <span data-ttu-id="0eaa7-192">代わりに、断続的に発生するのではなく、障害条件下でエンドツーエンドのワークロードがどのように実行されるかをテストする必要があります。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-192">Instead, you must test how the end-to-end workload performs under failure conditions, which only occur intermittently.</span></span> <span data-ttu-id="0eaa7-193">たとえば、クラッシュしたプロセス、期限切れの証明書、依存サービスを利用できないなどによってエラーを挿入します。混乱などのフレームワークは [、](https://github.com/Netflix/chaosmonkey) このような混乱テストに使用できます。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-193">For example: inject failures by crashing processes, expired certificates, make dependent services unavailable etc. Frameworks like [chaos-monkey](https://github.com/Netflix/chaosmonkey) can be used for such chaos testing.</span></span>

<span data-ttu-id="0eaa7-194">アプリケーションの回復性は、要求された問題のある操作を処理するためのものです。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-194">Application resiliency is a must for handling problematic requested operations.</span></span> <span data-ttu-id="0eaa7-195">しかし、これはストーリーの半分にすぎません。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-195">But, it's only half of the story.</span></span> <span data-ttu-id="0eaa7-196">次に、Azure クラウドで使用できる回復機能について説明します。</span><span class="sxs-lookup"><span data-stu-id="0eaa7-196">Next, we cover resiliency features available in the Azure cloud.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="0eaa7-197">[前へ](resiliency.md)
>[次へ](infrastructure-resiliency-azure.md)</span><span class="sxs-lookup"><span data-stu-id="0eaa7-197">[Previous](resiliency.md)
[Next](infrastructure-resiliency-azure.md)</span></span>
