---
description: 詳細については、.NET Framework 4.5 の Windows Communication Foundation 用語集を参照してください。
title: .NET Framework 4.5 の Windows Communication Foundation 用語集
ms.date: 03/30/2017
helpviewer_keywords:
- Windows Communication Foundation [WCF], glossary
- WCF [WCF], glossary
ms.assetid: 39cd36f4-8a28-4d0b-a830-98d55c9d30ae
ms.openlocfilehash: c0d46f25ddda1d4d56a7be5f2641f5f22109cc7d
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/06/2021
ms.locfileid: "99779440"
---
# <a name="windows-communication-foundation-glossary-for-net-framework-45"></a><span data-ttu-id="b1eb4-103">.NET Framework 4.5 の Windows Communication Foundation 用語集</span><span class="sxs-lookup"><span data-stu-id="b1eb4-103">Windows Communication Foundation Glossary for .NET Framework 4.5</span></span>

<span data-ttu-id="b1eb4-104">次の表に、Windows Communication Foundation のドキュメントで使用する用語の定義を示します。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-104">The following terms are defined for Windows Communication Foundation documentation.</span></span>

## <a name="terms"></a><span data-ttu-id="b1eb4-105">用語</span><span class="sxs-lookup"><span data-stu-id="b1eb4-105">Terms</span></span>

|<span data-ttu-id="b1eb4-106">期間</span><span class="sxs-lookup"><span data-stu-id="b1eb4-106">Term</span></span>|<span data-ttu-id="b1eb4-107">定義</span><span class="sxs-lookup"><span data-stu-id="b1eb4-107">Definition</span></span>|
|----------|----------------|
|<span data-ttu-id="b1eb4-108">address</span><span class="sxs-lookup"><span data-stu-id="b1eb4-108">address</span></span>|<span data-ttu-id="b1eb4-109">メッセージを受信する場所を指定します。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-109">Specifies the location where messages are received.</span></span> <span data-ttu-id="b1eb4-110">アドレスは、URI (Uniform Resource Identifier) として指定されます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-110">It is specified as a Uniform Resource Identifier (URI).</span></span> <span data-ttu-id="b1eb4-111">URI のスキーマ部分では、そのアドレスに到達するために使用するトランスポート機構 (HTTP、TCP など) を指定します。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-111">The URI schema part names the transport mechanism to use to reach the address, such as HTTP and TCP.</span></span> <span data-ttu-id="b1eb4-112">URI の階層部分には一意の場所が含まれ、その形式はトランスポート機構によって異なります。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-112">The hierarchical part of the URI contains a unique location whose format is dependent on the transport mechanism.</span></span>|
|<span data-ttu-id="b1eb4-113">アプリケーション エンドポイント</span><span class="sxs-lookup"><span data-stu-id="b1eb4-113">application endpoint</span></span>|<span data-ttu-id="b1eb4-114">アプリケーションによって公開されるエンドポイントです。アプリケーション エンドポイントは、アプリケーションで実装されるサービス コントラクトに対応しています。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-114">An endpoint exposed by the application and that corresponds to a service contract implemented by the application.</span></span>|
|<span data-ttu-id="b1eb4-115">動作</span><span class="sxs-lookup"><span data-stu-id="b1eb4-115">behavior</span></span>|<span data-ttu-id="b1eb4-116">動作とは、サービス、エンドポイント、特定の操作、またはクライアントの実行時のさまざまな状況を制御するコンポーネントです。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-116">A behavior is a component that controls various run-time aspects of a service, an endpoint, a particular operation, or a client.</span></span> <span data-ttu-id="b1eb4-117">動作はスコープに従ってグループ化されます。共通動作は、すべてのエンドポイントにグローバルに作用し、サービス動作は、サービスに関連する側面にのみ作用します。また、エンドポイントの動作は、エンドポイントに関連するプロパティにのみ作用し、操作レベルの動作は特定の操作に作用します。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-117">Behaviors are grouped according to scope: common behaviors affect all endpoints globally, service behaviors affect only service-related aspects, endpoint behaviors affect only endpoint-related properties, and operation-level behaviors affect particular operations.</span></span>|
|<span data-ttu-id="b1eb4-118">binding</span><span class="sxs-lookup"><span data-stu-id="b1eb4-118">binding</span></span>|<span data-ttu-id="b1eb4-119">WCF サービスとの通信に使用する通信プロトコルを指定します。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-119">Defines which communication protocols are used to communicate with WCF services.</span></span> <span data-ttu-id="b1eb4-120">バインディングは、バインド要素と呼ばれる一連のコンポーネントで構成されます。各バインド要素を積み重ねることで、通信インフラストラクチャが作成されます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-120">It is constructed of a set of components called binding elements that stack one on top of the other to create the communication infrastructure.</span></span>  <span data-ttu-id="b1eb4-121">「エンドポイント」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-121">See endpoint.</span></span>|
|<span data-ttu-id="b1eb4-122">channel</span><span class="sxs-lookup"><span data-stu-id="b1eb4-122">channel</span></span>|<span data-ttu-id="b1eb4-123">バインド要素の具象実装です。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-123">A concrete implementation of a binding element.</span></span> <span data-ttu-id="b1eb4-124">バインディングは構成を表し、チャネルはその構成に関連付けられた実装です。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-124">The binding represents the configuration, and the channel is the implementation associated with that configuration.</span></span> <span data-ttu-id="b1eb4-125">したがって、各バインディング要素に関連付けられたチャネルが存在します。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-125">Therefore, there is a channel associated with each binding element.</span></span> <span data-ttu-id="b1eb4-126">チャネルが積み重ねられて、バインディングの具象実装 (チャネル スタック) が作成されます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-126">Channels stack on top of each other to create the concrete implementation of the binding: the channel stack.</span></span>|
|<span data-ttu-id="b1eb4-127">クレーム ベース セキュリティ</span><span class="sxs-lookup"><span data-stu-id="b1eb4-127">claims-based security</span></span>|<span data-ttu-id="b1eb4-128">クレームに基づいて、保護されているリソースへの承認されたアクセスを許可します。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-128">Allows authorized access to protected resources based on claims.</span></span>|
|<span data-ttu-id="b1eb4-129">クライアント アプリケーション (client application)</span><span class="sxs-lookup"><span data-stu-id="b1eb4-129">client application</span></span>|<span data-ttu-id="b1eb4-130">クライアント アプリケーションは、1 つ以上のエンドポイントとメッセージを交換するプログラムです。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-130">A client application is a program that exchanges messages with one or more endpoints.</span></span> <span data-ttu-id="b1eb4-131">クライアント アプリケーションは、WCF クライアントのインスタンスを作成し、WCF クライアントのメソッドを呼び出すことによって開始されます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-131">The client application begins by creating an instance of a WCF client and calling methods of the WCF client.</span></span> <span data-ttu-id="b1eb4-132">1 つのアプリケーションがクライアントとサービスの両方として機能できることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-132">It is important to note that a single application can be both a client and a service.</span></span>|
|<span data-ttu-id="b1eb4-133">コーディング</span><span class="sxs-lookup"><span data-stu-id="b1eb4-133">coding</span></span>|<span data-ttu-id="b1eb4-134">開発者は、サービスまたはクライアントのすべてのコンポーネントに対する厳密な制御を保持できます。構成によって行われた設定を検査し、必要に応じてコードによってオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-134">Allows the developer to retain strict control over all components of the service or client, and any settings done through the configuration can be inspected and if needed overridden by the code.</span></span> <span data-ttu-id="b1eb4-135">アプリケーションは、コーディング、構成、またはこの 2 つの組み合わせによって制御できます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-135">Control of an application can be done either through coding, through configuration, or through a combination of both.</span></span>|
|<span data-ttu-id="b1eb4-136">configuration</span><span class="sxs-lookup"><span data-stu-id="b1eb4-136">configuration</span></span>|<span data-ttu-id="b1eb4-137">構成には、コードの作成後、再コンパイルを必要とせずに、開発者以外のユーザー (ネットワーク管理者など) がクライアントとサービスのパラメーターを設定できるという利点があります。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-137">Configuration has the advantage of allowing someone other than the developer (for example, a network administrator) to set client and service parameters after the code is written and without having to recompile.</span></span> <span data-ttu-id="b1eb4-138">構成では、エンドポイント アドレスなどの値を設定できるだけでなく、エンドポイント、バインディング、および動作の追加が可能であるため、制御を強化することもできます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-138">Configuration not only enables you to set values like endpoint addresses, but also allows further control by enabling you to add endpoints, bindings, and behaviors.</span></span> <span data-ttu-id="b1eb4-139">アプリケーションは、構成、コーディング、またはこの 2 つの組み合わせによって制御できます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-139">Control of an application can be done either through configuration, through coding, or through a combination of both.</span></span>|
|<span data-ttu-id="b1eb4-140">コントラクト (contract)</span><span class="sxs-lookup"><span data-stu-id="b1eb4-140">contract</span></span>|<span data-ttu-id="b1eb4-141">コントラクトは、特定の種類のコントラクトに対するサポート仕様です。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-141">A contract is a specification of support for the particular type of contract that it is.</span></span> <span data-ttu-id="b1eb4-142">たとえば、サービス コントラクトは、操作のグループに対する仕様です。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-142">A service contract, for example, is a specification for a group of operations.</span></span> <span data-ttu-id="b1eb4-143">WCF では、コントラクトは階層構造を持ち、これは System.ServiceModel.Description 名前空間に存在する説明オブジェクトにミラー化されています。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-143">In WCF, contracts have a hierarchy that is mirrored in the description objects located in the System.ServiceModel.Description namespace.</span></span> <span data-ttu-id="b1eb4-144">サービス コントラクトは、WCF で最も大きなコントラクト スコープです。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-144">A service contract is the largest contract scope in WCF.</span></span> <span data-ttu-id="b1eb4-145">サービス コントラクトの各サービス操作には、エラー メッセージを含め、操作により交換されるメッセージとその交換方向を規定した操作コントラクトがあります。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-145">Each service operation in a service contract has an operation contract, which specifies the messages -- including fault messages -- the operation can exchange, and in which direction.</span></span> <span data-ttu-id="b1eb4-146">操作の各メッセージには、メッセージ コントラクト、つまり SOAP メッセージ エンベロープの構造仕様があり、個々のメッセージ コントラクトには、メッセージに含まれるデータ構造を規定したデータ コントラクトがあります。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-146">Each message in an operation has a message contract, a specification for the structure of the SOAP message envelope, and each message contract has a data contract, which specifies the data structures contained in the messages.</span></span>|
|<span data-ttu-id="b1eb4-147">データ コントラクト</span><span class="sxs-lookup"><span data-stu-id="b1eb4-147">data contract</span></span>|<span data-ttu-id="b1eb4-148">サービスが使用するデータ型をメタデータに記述して、他のサービスがそのサービスと相互運用できるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-148">The data types a service uses must be described in metadata to enable others to interoperate with the service.</span></span> <span data-ttu-id="b1eb4-149">データ型の記述は、データ コントラクトと呼ばれます。型は、メッセージの任意の部分で使用できます (パラメーターや戻り値の型など)。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-149">The descriptions of the data types are known as the data contract, and the types can be used in any part of a message, for example, as parameters or return types.</span></span> <span data-ttu-id="b1eb4-150">サービスが単純型だけを使用している場合、データ コントラクトを明示的に使用する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-150">If the service is using only simple types, there is no need to explicitly use data contracts.</span></span>|
|<span data-ttu-id="b1eb4-151">宣言アプリケーション</span><span class="sxs-lookup"><span data-stu-id="b1eb4-151">declarative application</span></span>|<span data-ttu-id="b1eb4-152">命令を実行しなくても実行時に作成されるように記述されたアプリケーションです。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-152">An application that is described sufficiently to be created at runtime without running imperative instructions.</span></span>|
|<span data-ttu-id="b1eb4-153">endpoint</span><span class="sxs-lookup"><span data-stu-id="b1eb4-153">endpoint</span></span>|<span data-ttu-id="b1eb4-154">WCF サービスとの通信に使用されるアドレス、バインディング、およびコントラクトで構成されます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-154">Consists of an address, a binding, and a contract used for communicating with a WCF service.</span></span>|
|<span data-ttu-id="b1eb4-155">エンドポイント アドレス</span><span class="sxs-lookup"><span data-stu-id="b1eb4-155">endpoint address</span></span>|<span data-ttu-id="b1eb4-156">サービスのエンドポイントごとに一意のエンドポイント アドレスを作成できます。また、一定の条件下では、エンドポイント間でアドレスを共有することもできます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-156">Enables you to create unique endpoint addresses for each endpoint in a service, or under certain conditions share an address across endpoints.</span></span>|
|<span data-ttu-id="b1eb4-157">エラー コントラクト</span><span class="sxs-lookup"><span data-stu-id="b1eb4-157">fault contract</span></span>|<span data-ttu-id="b1eb4-158">エラー コントラクトをサービス操作に関連付けることにより、呼び出し元に返すことのできるエラーを示すことができます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-158">A fault contract can be associated with a service operation to denote errors that can be returned to the caller.</span></span> <span data-ttu-id="b1eb4-159">操作には、0 個以上のエラーを関連付けることができます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-159">An operation can have zero or more faults associated with it.</span></span> <span data-ttu-id="b1eb4-160">これらのエラーは、プログラミング モデルで例外としてモデル化される SOAP エラーです。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-160">These errors are SOAP faults that are modeled as exceptions in the programming model.</span></span> <span data-ttu-id="b1eb4-161">例外は SOAP エラーに変換され、その後、クライアントに送信されます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-161">The exception is converted into a SOAP fault that can then be sent to the client.</span></span>|
|<span data-ttu-id="b1eb4-162">ホスティング</span><span class="sxs-lookup"><span data-stu-id="b1eb4-162">hosting</span></span>|<span data-ttu-id="b1eb4-163">サービスは、何らかのプロセス内でホストされている必要があります。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-163">A service must be hosted in some process.</span></span> <span data-ttu-id="b1eb4-164">ホストは、サービスの有効期間を制御するアプリケーションです。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-164">A host is an application that controls the lifetime of the service.</span></span> <span data-ttu-id="b1eb4-165">サービスは、自己ホスト型であっても、既存のホスティング プロセスによって管理されていてもかまいません。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-165">Services can be self-hosted or managed by an existing hosting process.</span></span>|
|<span data-ttu-id="b1eb4-166">ホスト プロセス</span><span class="sxs-lookup"><span data-stu-id="b1eb4-166">hosting process</span></span>|<span data-ttu-id="b1eb4-167">ホスティング プロセスとは、サービスをホストするように設計されたアプリケーションです。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-167">A hosting process is an application that is designed to host services.</span></span> <span data-ttu-id="b1eb4-168">ホスティング プロセスには、インターネット インフォメーション サービス (IIS)、Windows アクティブ化サービス (WAS)、Windows サービスなどがあります。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-168">These include Internet Information Services (IIS), Windows Activation Services (WAS), and Windows Services.</span></span> <span data-ttu-id="b1eb4-169">これらのホスト シナリオでは、ホストがサービスの有効期間を制御します。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-169">In these hosted scenarios, the host controls the lifetime of the service.</span></span> <span data-ttu-id="b1eb4-170">たとえば、IIS を使用して、サービス アセンブリや構成ファイルを格納する仮想ディレクトリを設定できます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-170">For example, using IIS you can set up a virtual directory that contains the service assembly and configuration file.</span></span> <span data-ttu-id="b1eb4-171">メッセージを受信すると、IIS はサービスを開始し、その有効期間を制御します。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-171">When a message is received, IIS starts the service and controls its lifetime.</span></span>|
|<span data-ttu-id="b1eb4-172">開始操作</span><span class="sxs-lookup"><span data-stu-id="b1eb4-172">initiating operation</span></span>|<span data-ttu-id="b1eb4-173">新しいセッションの最初の操作として呼び出される操作です。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-173">An operation that is called as the first operation of a new session.</span></span> <span data-ttu-id="b1eb4-174">開始操作以外の操作は、少なくとも 1 つの開始操作が呼び出された後にしか呼び出すことはできません。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-174">Non-initiating operations can be called only after at least one initiating operation has been called.</span></span>|
|<span data-ttu-id="b1eb4-175">インスタンス化モデル</span><span class="sxs-lookup"><span data-stu-id="b1eb4-175">instancing model</span></span>|<span data-ttu-id="b1eb4-176">サービスには、インスタンス化モデルが含まれます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-176">A service has an instancing model.</span></span> <span data-ttu-id="b1eb4-177">1つの &quot; &quot; CLR オブジェクトがすべてのクライアント &quot; をサービスする、次の3つのインスタンス化モデルがあります。呼び出しごとに、 &quot; 各クライアントの呼び出しを処理するために新しい clr オブジェクトが作成されます。また、各セッションに対して、 &quot; &quot; clr オブジェクトのセットが1つずつ作成されます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-177">There are three instancing models: &quot;single,&quot; in which a single CLR object services all the clients; &quot;per call,&quot; in which a new CLR object is created to handle each client call; and &quot;per session,&quot; in which a set of CLR objects are created, one for each separate session.</span></span> <span data-ttu-id="b1eb4-178">インスタンス化モデルの選択は、アプリケーション要件とサービスの予想される使用パターンによって異なります。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-178">The choice of an instancing model depends on the application requirements and the expected usage pattern of the service.</span></span>|
|<span data-ttu-id="b1eb4-179">message</span><span class="sxs-lookup"><span data-stu-id="b1eb4-179">message</span></span>|<span data-ttu-id="b1eb4-180">メッセージとは、本文やヘッダーなどの複数の部分で構成できるデータの内部格納ユニットです。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-180">A message is a self-contained unit of data that may consist of several parts, including a body and headers.</span></span>|
|<span data-ttu-id="b1eb4-181">メッセージ コントラクト</span><span class="sxs-lookup"><span data-stu-id="b1eb4-181">message contract</span></span>|<span data-ttu-id="b1eb4-182">メッセージ コントラクトとは、メッセージの形式を記述したものです。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-182">A message contract describes the format of a message.</span></span> <span data-ttu-id="b1eb4-183">たとえば、メッセージ要素をヘッダーと本文のどちらに入れるか、メッセージのどの要素にどのレベルのセキュリティを適用するかなどを宣言します。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-183">For example, it declares whether message elements should go in headers versus the body, what level of security should be applied to what elements of the message, and so on.</span></span>|
|<span data-ttu-id="b1eb4-184">メッセージ セキュリティ モード</span><span class="sxs-lookup"><span data-stu-id="b1eb4-184">message security mode</span></span>|<span data-ttu-id="b1eb4-185">メッセージ セキュリティ モードでは、セキュリティ仕様の 1 つまたは複数を実装することによりセキュリティが提供されます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-185">Message security mode specifies that security is provided by implementing one or more of the security specifications.</span></span> <span data-ttu-id="b1eb4-186">各メッセージには、メッセージ送信中のセキュリティを確保し、受信側による改ざんの検出とメッセージの復号化を可能にするために必要な機構が含まれます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-186">Each message contains the necessary mechanisms to provide security during its transit, and to enable the receivers to detect tampering and to decrypt the messages.</span></span> <span data-ttu-id="b1eb4-187">この意味で、セキュリティはすべてのメッセージ内にカプセル化されるため、複数のホップにわたるエンド ツー エンドのセキュリティが実現します。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-187">In this sense, the security is encapsulated within every message, providing end-to-end security across multiple hops.</span></span> <span data-ttu-id="b1eb4-188">セキュリティ情報はメッセージの一部になるため、メッセージと共に複数の種類の資格情報を含めることもできます (これらはクレームと呼ばれます)。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-188">Because security information becomes part of the message, it is also possible to include multiple kinds of credentials with the message (these are referred to as claims).</span></span> <span data-ttu-id="b1eb4-189">この方法には、送信元と送信先の間の複数のトランスポートを含め、どのトランスポート上でもメッセージを安全に送信できるという利点もあります。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-189">This approach also has the advantage of enabling the message to travel securely over any transport, including multiple transports between its origin and destination.</span></span> <span data-ttu-id="b1eb4-190">この方法の欠点は、使用される暗号化機構が複雑であるため、パフォーマンスに影響することです。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-190">The disadvantage of this approach is the complexity of the cryptographic mechanisms employed, resulting in performance implications.</span></span>|
|<span data-ttu-id="b1eb4-191">metadata</span><span class="sxs-lookup"><span data-stu-id="b1eb4-191">metadata</span></span>|<span data-ttu-id="b1eb4-192">サービスのメタデータは、外部エンティティがそのサービスと通信するために認識しておく必要のあるサービスの特性を示します。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-192">The metadata of a service describes the characteristics of the service that an external entity needs to understand to communicate with the service.</span></span> <span data-ttu-id="b1eb4-193">ServiceModel メタデータ ユーティリティ ツール (Svcutil.exe) でメタデータを使用することにより、クライアント アプリケーションがサービスとやり取りするために使用できる、WCF クライアントと付随する構成を生成できます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-193">Metadata can be consumed by the ServiceModel Metadata Utility Tool (Svcutil.exe) to generate a WCF client and accompanying configuration that a client application can use to interact with the service.</span></span>  <span data-ttu-id="b1eb4-194">サービスが公開するメタデータには、サービスのデータ コントラクトが定義された XML スキーマ ドキュメントと、サービスのメソッドが記載された WSDL ドキュメントが含まれます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-194">The metadata exposed by the service includes XML schema documents, which define the data contract of the service, and WSDL documents, which describe the methods of the service.</span></span>  <span data-ttu-id="b1eb4-195">メタデータを有効にすると、WCF によってサービスとそのエンドポイントが検査され、サービスのメタデータが自動的に生成されます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-195">When enabled, metadata for the service is automatically generated by WCF by inspecting the service and its endpoints.</span></span> <span data-ttu-id="b1eb4-196">サービスからメタデータを公開するには、メタデータの動作を明示的に有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-196">To publish metadata from a service, you must explicitly enable the metadata behavior.</span></span>|
|<span data-ttu-id="b1eb4-197">操作コントラクト</span><span class="sxs-lookup"><span data-stu-id="b1eb4-197">operation contract</span></span>|<span data-ttu-id="b1eb4-198">操作コントラクトは、操作のパラメーターと戻り値の型を定義します。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-198">An operation contract defines the parameters and return type of an operation.</span></span> <span data-ttu-id="b1eb4-199">サービス コントラクトを定義するインターフェイスの作成時に、コントラクトに含まれる各メソッド定義に T:System.ServiceModel.OperationContractAttribute 属性を適用することによって、操作コントラクトを表します。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-199">When creating an interface that defines the service contract, you signify an operation contract by applying the T:System.ServiceModel.OperationContractAttribute attribute to each method definition that is part of the contract.</span></span> <span data-ttu-id="b1eb4-200">各操作は、単一のメッセージを取得し、単一のメッセージを返すようにモデル化することも、一連の型を取得し、型を返すようにモデル化することもできます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-200">The operations can be modeled as taking a single message and returning a single message, or as taking a set of types and returning a type.</span></span> <span data-ttu-id="b1eb4-201">後者の場合、その操作用に交換する必要のあるメッセージの形式がシステムによって決定されます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-201">In the latter case, the system determines the format for the messages that are exchanged for that operation.</span></span>|
|<span data-ttu-id="b1eb4-202">投影 (projection)</span><span class="sxs-lookup"><span data-stu-id="b1eb4-202">projection</span></span>|<span data-ttu-id="b1eb4-203">ネットワーク上でのデータの表現です。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-203">The representation of data on the wire.</span></span> <span data-ttu-id="b1eb4-204">たとえば、メッセージは、SOAP 射影では SOAP エンベロープとして送信され、Web 射影では JSON 形式で送信されます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-204">For example, a SOAP projection sends messages as SOAP envelopes and a Web projection sends messages in JSON format.</span></span>|
|<span data-ttu-id="b1eb4-205">security</span><span class="sxs-lookup"><span data-stu-id="b1eb4-205">security</span></span>|<span data-ttu-id="b1eb4-206">WCF のセキュリティには、機密性 (盗聴を防ぐためのメッセージの暗号化)、整合性 (メッセージの改ざんを検出するための手段)、認証 (サービスとクライアントを検証する方法)、承認 (リソースへのアクセスの制御) が含まれます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-206">Security in WCF includes confidentiality (encryption of messages to prevent eavesdropping), integrity (the means for detection of tampering with the message), authentication (the means for validation of servers and clients), and authorization (the control of access to resources).</span></span> <span data-ttu-id="b1eb4-207">これらの機能は、TLS over HTTP (HTTPS とも呼ばれます) などの既存のセキュリティ機構を利用するか、さまざまな WS-\* セキュリティ仕様の中から 1 つ以上の仕様を実装することによって実現されます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-207">These functions are provided by either leveraging existing security mechanisms, such as TLS over HTTP (also known as HTTPS), or by implementing one or more of the various WS-\* security specifications.</span></span>|
|<span data-ttu-id="b1eb4-208">自己ホスト サービス</span><span class="sxs-lookup"><span data-stu-id="b1eb4-208">self-hosted service</span></span>|<span data-ttu-id="b1eb4-209">自己ホスト型サービスとは、開発者が作成したプロセス アプリケーション内で実行されるサービスです。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-209">A self-hosted service is one that runs within a process application that the developer created.</span></span> <span data-ttu-id="b1eb4-210">開発者は、サービスの有効期間を制御し、サービスのプロパティを設定します。また、サービスを開き (サービスをリッスン モードに設定する)、サービスを閉じることも開発者が行います。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-210">The developer controls its lifetime, sets the properties of the service, opens the service (which sets it into a listening mode), and closes the service.</span></span>|
|<span data-ttu-id="b1eb4-211">service</span><span class="sxs-lookup"><span data-stu-id="b1eb4-211">service</span></span>|<span data-ttu-id="b1eb4-212">1 つ以上のエンドポイントを公開するプログラムまたはプロセスです。各エンドポイントは、1 つ以上の操作を公開します。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-212">A program or process that exposes one or more endpoints, with each endpoint exposing one or more operations.</span></span>|
|<span data-ttu-id="b1eb4-213">サービス コントラクト</span><span class="sxs-lookup"><span data-stu-id="b1eb4-213">service contract</span></span>|<span data-ttu-id="b1eb4-214">サービス コントラクトは、関連する複数の操作を 1 つの機能単位に関連付けます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-214">The service contract ties together multiple related operations into a single functional unit.</span></span> <span data-ttu-id="b1eb4-215">コントラクトでは、サービスの名前空間や対応するコールバック コントラクトなど、サービス レベルの設定を定義できます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-215">The contract can define service-level settings, such as the namespace of the service, a corresponding callback contract, and other such settings.</span></span> <span data-ttu-id="b1eb4-216">ほとんどの場合、開発者は選択したプログラミング言語でインターフェイスを作成し、このインターフェイスに T:System.ServiceModel.ServiceContractAttribute 属性を適用することによって、コントラクトを定義します。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-216">In most cases, the contract is defined by creating an interface in the programming language of your choice and applying the T:System.ServiceModel.ServiceContractAttribute attribute to the interface.</span></span> <span data-ttu-id="b1eb4-217">実際のサービス コードは、インターフェイスを実装することによって作成されます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-217">The actual service code results by implementing the interface.</span></span>|
|<span data-ttu-id="b1eb4-218">サービス操作</span><span class="sxs-lookup"><span data-stu-id="b1eb4-218">service operation</span></span>|<span data-ttu-id="b1eb4-219">サービス操作とは、操作の機能を実装するためにサービスのコードに定義された手順です。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-219">A service operation is a procedure defined in a service's code that implements the functionality for an operation.</span></span> <span data-ttu-id="b1eb4-220">この操作は、WCF クライアントのメソッドとしてクライアントに公開されます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-220">This operation is exposed to clients as methods on a WCF client.</span></span> <span data-ttu-id="b1eb4-221">メソッドは、値を返すこともあれば、任意の数の引数を受け取ることもあります。また、引数を受け取らず、応答を返さないこともあります。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-221">The method may return a value, and may take an optional number of arguments, or take no arguments, and return no response.</span></span> <span data-ttu-id="b1eb4-222">たとえば、Hello として機能する操作は、 &quot; &quot; クライアントの存在の通知として使用したり、一連の操作を開始したりすることができます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-222">For example, an operation that functions as a &quot;Hello&quot; can be used as a notification of a client's presence and to begin a series of operations.</span></span>|
|<span data-ttu-id="b1eb4-223">システム指定のバインディング</span><span class="sxs-lookup"><span data-stu-id="b1eb4-223">system-provided bindings</span></span>|<span data-ttu-id="b1eb4-224">WCF には、システム指定のバインディングが多数用意されています。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-224">WCF includes a number of system-provided bindings.</span></span> <span data-ttu-id="b1eb4-225">これらは、特定のシナリオ用に最適化されたバインディング要素の集まりです。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-225">These are collections of binding elements that are optimized for specific scenarios.</span></span> <span data-ttu-id="b1eb4-226">たとえば、T:System.ServiceModel.WSHttpBinding は、さまざまな WS-\* 仕様を実装するサービスと相互運用できるようにデザインされています。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-226">For example, the T:System.ServiceModel.WSHttpBinding is designed for interoperability with services that implement various WS-\* specifications.</span></span> <span data-ttu-id="b1eb4-227">これらのバインディングでは、特定のシナリオに適切に適用できるオプションだけが提供されるため、時間を節約できます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-227">These bindings save time by presenting only those options that can be correctly applied to the specific scenario.</span></span> <span data-ttu-id="b1eb4-228">これらのバインディングでは要件が満たされない場合は、独自のカスタム バインドを作成できます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-228">If one of these bindings does not meet your requirements, you can create your own custom binding.</span></span>|
|<span data-ttu-id="b1eb4-229">終了操作</span><span class="sxs-lookup"><span data-stu-id="b1eb4-229">terminating operation</span></span>|<span data-ttu-id="b1eb4-230">既存セッションの最後のメッセージとして呼び出される操作です。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-230">An operation that is called as the last message in an existing session.</span></span> <span data-ttu-id="b1eb4-231">既定では、WCF は、サービスが関連付けられているセッションが閉じられた後に、サービス オブジェクトとそのコンテキストを再利用します。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-231">In the default case, WCF recycles the service object and its context after the session with which the service was associated is closed.</span></span>|
|<span data-ttu-id="b1eb4-232">トランスポート セキュリティ モード</span><span class="sxs-lookup"><span data-stu-id="b1eb4-232">transport security mode</span></span>|<span data-ttu-id="b1eb4-233">セキュリティは、トランスポート モード、メッセージ セキュリティ モード、およびメッセージ資格情報付きトランスポート モードのいずれかによって提供できます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-233">Security can be provided by one of three modes: transport mode, message security mode, and transport with message credential mode.</span></span> <span data-ttu-id="b1eb4-234">トランスポート セキュリティ モードは、トランスポート層の機構 (HTTPS など) によって、機密性、整合性、および認証を提供することを示します。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-234">The transport security mode specifies that confidentiality, integrity, and authentication are provided by the transport layer mechanisms (such as HTTPS).</span></span> <span data-ttu-id="b1eb4-235">HTTPS のようなトランスポートを使用する場合、このモードには、パフォーマンスの面で効率的であることと、インターネットで普及しているため、十分に認識されているという利点があります。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-235">When using a transport like HTTPS, this mode has the advantage of being efficient in its performance, and well understood because of its prevalence on the Internet.</span></span> <span data-ttu-id="b1eb4-236">欠点は、この種のセキュリティは通信パスのホップごとに個別に適用されるため、中間者攻撃の影響を受けやすくなり &quot; &quot; ます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-236">The disadvantage is that this kind of security is applied separately on each hop in the communication path, making the communication susceptible to a &quot;man in the middle&quot; attack.</span></span>|
|<span data-ttu-id="b1eb4-237">メッセージ資格情報付きトランスポート セキュリティ モード</span><span class="sxs-lookup"><span data-stu-id="b1eb4-237">transport with message credential security mode</span></span>|<span data-ttu-id="b1eb4-238">このモードは、トランスポート層を使用してメッセージの機密性、認証、および整合性を提供します。各メッセージには、メッセージの受信側で必要とされる複数の資格情報 (クレーム) を含めることができます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-238">This mode uses the transport layer to provide confidentiality, authentication, and integrity of the messages, while each of the messages can contain multiple credentials (claims) required by the receivers of the message.</span></span>|
|<span data-ttu-id="b1eb4-239">型コンバーター</span><span class="sxs-lookup"><span data-stu-id="b1eb4-239">type converter</span></span>|<span data-ttu-id="b1eb4-240">CLR 型は、CLR 型のインスタンスと他の型のインスタンスを変換する 1 つまたは複数の System.ComponentModel.TypeConverter 派生型に関連付けることができます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-240">A CLR type can be associated with one or more System.ComponentModel.TypeConverter derived types that enable converting instances of the CLR type to and from instances of other types.</span></span> <span data-ttu-id="b1eb4-241">型コンバーターは、System.componentmodel TypeConverterAttribute 属性を使用して CLR 型に関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-241">A type converter is associated with a CLR type using the System.ComponentModel.TypeConverterAttribute attribute.</span></span>  <span data-ttu-id="b1eb4-242">TypeConverterAttribute は、CLR 型またはプロパティで直接指定できます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-242">A TypeConverterAttribute can be specified directly on the CLR type or on a property.</span></span> <span data-ttu-id="b1eb4-243">プロパティで指定された型コンバーターは、プロパティの CLR 型で指定された型コンバーターよりも常に優先されます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-243">A type converter specified on a property always takes precedence over a type converter specified on the CLR type of the property.</span></span>|
|<span data-ttu-id="b1eb4-244">WCF クライアント</span><span class="sxs-lookup"><span data-stu-id="b1eb4-244">WCF client</span></span>|<span data-ttu-id="b1eb4-245">WCF クライアントは、サービス操作を (Visual Basic や Visual C# など、開発者が選択した .NET Framework プログラミング言語の) メソッドとして公開するクライアント アプリケーション構造体です。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-245">A WCF client is a client-application construct that exposes the service operations as methods (in the .NET Framework programming language of your choice, such as Visual Basic or Visual C#).</span></span> <span data-ttu-id="b1eb4-246">サービスをホストするアプリケーションも含め、すべてのアプリケーションが WCF クライアントをホストできます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-246">Any application can host a WCF client, including an application that hosts a service.</span></span> <span data-ttu-id="b1eb4-247">したがって、他のサービスの WCF クライアントを含むサービスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-247">Therefore, it is possible to create a service that includes WCF clients of other services.</span></span>  <span data-ttu-id="b1eb4-248">ServiceModel メタデータ ユーティリティ ツール (Svcutil.exe) を使用し、メタデータを公開する実行中のサービスでメタデータを指定することによって、WCF クライアントを自動的に生成できます。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-248">A WCF client can be automatically generated by using the ServiceModel Metadata Utility Tool (Svcutil.exe) and pointing it at a running service that publishes metadata.</span></span>|
|<span data-ttu-id="b1eb4-249">ワークフロー サービス</span><span class="sxs-lookup"><span data-stu-id="b1eb4-249">workflow services</span></span>|<span data-ttu-id="b1eb4-250">ワークフロー サービスは、ワークフローとして実装される WCF サービスです。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-250">A workflow service is a WCF service that is implemented as a workflow.</span></span> <span data-ttu-id="b1eb4-251">ワークフローには、WCF メッセージを送受信するメッセージング アクティビティが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-251">The workflow contains messaging activities that send and/or receive WCF messages.</span></span>|
|<span data-ttu-id="b1eb4-252">WS-\*</span><span class="sxs-lookup"><span data-stu-id="b1eb4-252">WS-\*</span></span>|<span data-ttu-id="b1eb4-253">WCF に実装された一連の Web サービス (WS) 仕様 (WS-Security や WS-ReliableMessaging など) の略称です。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-253">Shorthand for the growing set of Web Service (WS) specifications, such as WS-Security, WS-ReliableMessaging, and so on, that are implemented in WCF.</span></span>|
|<span data-ttu-id="b1eb4-254">XAML</span><span class="sxs-lookup"><span data-stu-id="b1eb4-254">XAML</span></span>|<span data-ttu-id="b1eb4-255">eXtensible Application Markup Language</span><span class="sxs-lookup"><span data-stu-id="b1eb4-255">eXtensible Application Markup Language</span></span>|
|<span data-ttu-id="b1eb4-256">XAML スキーマ</span><span class="sxs-lookup"><span data-stu-id="b1eb4-256">XAML schema</span></span>|<span data-ttu-id="b1eb4-257">XAML でカスタム型を定義するために使用されるマークアップスキーマ。</span><span class="sxs-lookup"><span data-stu-id="b1eb4-257">A markup schema used to define custom types in XAML.</span></span>|
