---
description: '詳細情報: クライアントを使用したサービスへのアクセス'
title: クライアントを使用したサービスへのアクセス
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: c8329832-bf66-4064-9034-bf39f153fc2d
ms.openlocfilehash: 112e401f96fb1bf4231fb6bef3e5a57b6f40949e
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/06/2021
ms.locfileid: "99793884"
---
# <a name="accessing-services-using-a-client"></a><span data-ttu-id="48a13-103">クライアントを使用したサービスへのアクセス</span><span class="sxs-lookup"><span data-stu-id="48a13-103">Accessing Services Using a Client</span></span>

<span data-ttu-id="48a13-104">クライアントアプリケーションは、サービスと通信するために、WCF クライアントオブジェクトまたはチャネルオブジェクトを作成、構成、および使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="48a13-104">Client applications must create, configure, and use WCF client or channel objects to communicate with services.</span></span> <span data-ttu-id="48a13-105">[WCF クライアントの概要](../wcf-client-overview.md)に関するトピックでは、基本的なクライアントオブジェクトとチャネルオブジェクトを作成し、それらを使用する際に必要なオブジェクトと手順の概要を説明します。</span><span class="sxs-lookup"><span data-stu-id="48a13-105">The [WCF Client Overview](../wcf-client-overview.md) topic provides an overview of the objects and steps involved in creating basic client and channel objects and using them.</span></span>  
  
 <span data-ttu-id="48a13-106">このトピックでは、ユーザーのシナリオに応じて役立つ、クライアント アプリケーション、クライアント オブジェクト、およびチャネル オブジェクトに関するいくつかの問題について詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="48a13-106">This topic provides in-depth information about some of the issues with client applications and client and channel objects that may be useful depending upon your scenario.</span></span>  
  
## <a name="overview"></a><span data-ttu-id="48a13-107">概要</span><span class="sxs-lookup"><span data-stu-id="48a13-107">Overview</span></span>  

 <span data-ttu-id="48a13-108">ここでは、以下の項目に関連する動作と問題について説明します。</span><span class="sxs-lookup"><span data-stu-id="48a13-108">This topic describes behavior and issues relating to:</span></span>  
  
- <span data-ttu-id="48a13-109">チャネルとセッションの有効期間</span><span class="sxs-lookup"><span data-stu-id="48a13-109">Channel and session lifetimes.</span></span>  
  
- <span data-ttu-id="48a13-110">例外処理</span><span class="sxs-lookup"><span data-stu-id="48a13-110">Handling exceptions.</span></span>  
  
- <span data-ttu-id="48a13-111">ブロックの問題について</span><span class="sxs-lookup"><span data-stu-id="48a13-111">Understanding blocking issues.</span></span>  
  
- <span data-ttu-id="48a13-112">対話方式によるチャネルの初期化</span><span class="sxs-lookup"><span data-stu-id="48a13-112">Initializing channels interactively.</span></span>  
  
### <a name="channel-and-session-lifetimes"></a><span data-ttu-id="48a13-113">チャネルとセッションの有効期間</span><span class="sxs-lookup"><span data-stu-id="48a13-113">Channel and Session Lifetimes</span></span>  

 <span data-ttu-id="48a13-114">Windows Communication Foundation (WCF) アプリケーションには、データグラムとセッションフルという2つのカテゴリがあります。</span><span class="sxs-lookup"><span data-stu-id="48a13-114">Windows Communication Foundation (WCF) applications includes two categories of channels, datagram and sessionful.</span></span>  
  
 <span data-ttu-id="48a13-115">*データグラム* チャネルは、すべてのメッセージが非相関されるチャネルです。</span><span class="sxs-lookup"><span data-stu-id="48a13-115">A *datagram* channel is a channel in which all messages are uncorrelated.</span></span> <span data-ttu-id="48a13-116">データグラム チャネルでは、入出力操作が失敗しても、通常、次の操作は影響を受けないので、同じチャネルの再利用が可能です。</span><span class="sxs-lookup"><span data-stu-id="48a13-116">With a datagram channel, if an input or output operation fails, the next operation is typically unaffected, and the same channel can be reused.</span></span> <span data-ttu-id="48a13-117">したがって、通常、データグラム チャネルは失敗になりません。</span><span class="sxs-lookup"><span data-stu-id="48a13-117">Because of this, datagram channels typically do not fault.</span></span>  
  
 <span data-ttu-id="48a13-118">ただし、*セッションフル* チャネルは、他のエンドポイントに接続されているチャネルです。</span><span class="sxs-lookup"><span data-stu-id="48a13-118">*Sessionful* channels, however, are channels with a connection to the other endpoint.</span></span> <span data-ttu-id="48a13-119">一方のセッション内のメッセージは、他方の同じセッションと常に関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="48a13-119">Messages in a session on one side are always correlated with the same session on the other side.</span></span> <span data-ttu-id="48a13-120">さらに、セッションが成功したとみなされるためには、セッションの両参加要素が、メッセージ交換要件が満たされたということに同意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="48a13-120">In addition, both participants in a session must agree that the requirements of their conversation were met for that session to be considered successful.</span></span> <span data-ttu-id="48a13-121">両参加要素が同意できない場合、セッション チャネルは失敗になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="48a13-121">If they cannot agree, the sessionful channel may fault.</span></span>  
  
 <span data-ttu-id="48a13-122">クライアントを明示的に開く場合も暗黙的に開く場合も、最初の操作を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="48a13-122">Open clients explicitly or implicitly by calling the first operation.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="48a13-123">一般的に、障害が生じたセッションフル チャネルを明示的に検出することは有用ではありません。通知されるタイミングがセッションの実装により異なるためです。</span><span class="sxs-lookup"><span data-stu-id="48a13-123">Trying to explicitly detect faulted sessionful channels is not typically useful, because when you are notified depends upon the session implementation.</span></span> <span data-ttu-id="48a13-124">たとえば、<xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> (信頼できるセッションは無効) では TCP 接続のセッションが表面に出るため、サービスまたはクライアントで <xref:System.ServiceModel.ICommunicationObject.Faulted?displayProperty=nameWithType> イベントをリッスンしていれば、ネットワーク エラーが発生すると直ちに通知される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="48a13-124">For example, because the <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> (with the reliable session disabled) surfaces the session of the TCP connection, if you listen to the <xref:System.ServiceModel.ICommunicationObject.Faulted?displayProperty=nameWithType> event on the service or the client you are likely to be notified quickly in the event of a network failure.</span></span> <span data-ttu-id="48a13-125">一方、信頼できるセッション (<xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType> を有効化したバインディングにより確立される) は、サービスが小さなネットワーク エラーから分離されるように設計されています。</span><span class="sxs-lookup"><span data-stu-id="48a13-125">But reliable sessions (established by bindings in which the <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType> is enabled) are designed to insulate services from small network failures.</span></span> <span data-ttu-id="48a13-126">妥当な期間内にセッションの再確立が可能な場合、信頼できるセッション用に構成された、この同じバインディングは、中断が長期間発生し続けるまでエラーにならない場合があります。</span><span class="sxs-lookup"><span data-stu-id="48a13-126">If the session can be reestablished within a reasonable period of time, the same binding—configured for reliable sessions—might not fault until the interruption continued for a longer period of time.</span></span>  
  
 <span data-ttu-id="48a13-127">アプリケーション層にチャネルを公開するほとんどのシステム提供のバインディングでは、既定でセッションが使用されますが、<xref:System.ServiceModel.BasicHttpBinding?displayProperty=nameWithType> では使用されません。</span><span class="sxs-lookup"><span data-stu-id="48a13-127">Most of the system-provided bindings (which expose channels to the application layer) use sessions by default, but the <xref:System.ServiceModel.BasicHttpBinding?displayProperty=nameWithType> does not.</span></span> <span data-ttu-id="48a13-128">詳細については、「 [セッションの使用](../using-sessions.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="48a13-128">For more information, see [Using Sessions](../using-sessions.md).</span></span>  
  
### <a name="the-proper-use-of-sessions"></a><span data-ttu-id="48a13-129">セッションの適切な使用</span><span class="sxs-lookup"><span data-stu-id="48a13-129">The Proper Use of Sessions</span></span>  

 <span data-ttu-id="48a13-130">セッションを使用すると、メッセージ交換全体が完了したかどうか、そしてメッセージ交換が成功したと両側が見なしたかどうかを認識できます。</span><span class="sxs-lookup"><span data-stu-id="48a13-130">Sessions provide a way to know if the entire message exchange is complete, and if both sides considered it successful.</span></span> <span data-ttu-id="48a13-131">呼び出し側のアプリケーションでは、チャネルを開き、使用して、閉じるまでを 1 つの try ブロック内で処理することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="48a13-131">It is recommended that a calling application open the channel, use it, and close the channel inside one try block.</span></span> <span data-ttu-id="48a13-132">セッション チャネルが開いているときに、<xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> メソッドを 1 回呼び出して、その呼び出しが正常に返された場合、セッションは成功しています。</span><span class="sxs-lookup"><span data-stu-id="48a13-132">If a session channel is open, and the <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> method is called once, and that call returns successfully, then the session was successful.</span></span> <span data-ttu-id="48a13-133">この場合の成功とは、バインディングにより指定されているすべての配信保証が満たされ、もう一方の側では <xref:System.ServiceModel.ICommunicationObject.Abort%2A?displayProperty=nameWithType> を呼び出す前にチャネルに対して <xref:System.ServiceModel.ICommunicationObject.Close%2A> を呼び出さなかったことを意味します。</span><span class="sxs-lookup"><span data-stu-id="48a13-133">Successful in this case means that all delivery guarantees the binding specified were met, and the other side did not call <xref:System.ServiceModel.ICommunicationObject.Abort%2A?displayProperty=nameWithType> on the channel before calling <xref:System.ServiceModel.ICommunicationObject.Close%2A>.</span></span>  
  
 <span data-ttu-id="48a13-134">次のセクションで、このクライアントによる方法の例を示します。</span><span class="sxs-lookup"><span data-stu-id="48a13-134">The following section provides an example of this client approach.</span></span>  
  
### <a name="handling-exceptions"></a><span data-ttu-id="48a13-135">例外処理</span><span class="sxs-lookup"><span data-stu-id="48a13-135">Handling Exceptions</span></span>  

 <span data-ttu-id="48a13-136">クライアント アプリケーションで例外を処理することは簡単です。</span><span class="sxs-lookup"><span data-stu-id="48a13-136">Handling exceptions in client applications is straightforward.</span></span> <span data-ttu-id="48a13-137">try ブロック内部でチャネルを開き、使用して、閉じた場合、例外がスローされない限り、メッセージ交換は正常に行われています。</span><span class="sxs-lookup"><span data-stu-id="48a13-137">If a channel is opened, used, and closed inside a try block, then the conversation has succeeded, unless an exception is thrown.</span></span> <span data-ttu-id="48a13-138">通常、例外がスローされた場合は、メッセージ交換が中止されます。</span><span class="sxs-lookup"><span data-stu-id="48a13-138">Typically, if an exception is thrown the conversation is aborted.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="48a13-139">`using`ステートメント ( `Using` Visual Basic) は使用しないことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="48a13-139">Use of the `using` statement (`Using` in Visual Basic) is not recommended.</span></span> <span data-ttu-id="48a13-140">その理由は、`using` ステートメントの最後で例外が発生し、認識する必要のある他の例外がマスクされる可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="48a13-140">This is because the end of the `using` statement can cause exceptions that can mask other exceptions you may need to know about.</span></span> <span data-ttu-id="48a13-141">詳細については、「 [Close と Abort を使用して WCF クライアントリソースを解放する](../samples/use-close-abort-release-wcf-client-resources.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="48a13-141">For more information, see [Use Close and Abort to release WCF client resources](../samples/use-close-abort-release-wcf-client-resources.md).</span></span>  
  
 <span data-ttu-id="48a13-142">次のコード例は、`using` 文ではなく try/catch ブロックを使用する、推奨されるクライアント パターンを示しています。</span><span class="sxs-lookup"><span data-stu-id="48a13-142">The following code example shows the recommended client pattern using a try/catch block and not the `using` statement.</span></span>  
  
 [!code-csharp[FaultContractAttribute#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/client.cs#3)]
 [!code-vb[FaultContractAttribute#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/client.vb#3)]  
  
> [!NOTE]
> <span data-ttu-id="48a13-143"><xref:System.ServiceModel.ICommunicationObject.State%2A?displayProperty=nameWithType> プロパティの値を確認すると競合状態になるので、チャネルを再利用するかどうか、またはチャネルを閉じるかどうかを決定するのにこの値を確認することは推奨されません。</span><span class="sxs-lookup"><span data-stu-id="48a13-143">Checking the value of the <xref:System.ServiceModel.ICommunicationObject.State%2A?displayProperty=nameWithType> property is a race condition and is not recommended to determine whether to reuse or close a channel.</span></span>  
  
 <span data-ttu-id="48a13-144">データグラム チャネルを閉じるときに例外が発生しても、データグラム チャネルはエラーになりません。</span><span class="sxs-lookup"><span data-stu-id="48a13-144">Datagram channels never fault even if exceptions occur when they are closed.</span></span> <span data-ttu-id="48a13-145">さらに、非双方向クライアントがセキュリティで保護されたメッセージ交換を使用して認証に失敗した場合、通常、<xref:System.ServiceModel.Security.MessageSecurityException?displayProperty=nameWithType> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="48a13-145">In addition, non-duplex clients that fail to authenticate using a secure conversation typically throw a <xref:System.ServiceModel.Security.MessageSecurityException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="48a13-146">しかし、双方向クライアントがセキュリティで保護されたメッセージ交換を使用して認証に失敗した場合、クライアントは代わりに <xref:System.TimeoutException?displayProperty=nameWithType> を受信します。</span><span class="sxs-lookup"><span data-stu-id="48a13-146">However if the duplex client using a secure conversation fails to authenticate, the client receives a <xref:System.TimeoutException?displayProperty=nameWithType> instead.</span></span>  
  
 <span data-ttu-id="48a13-147">アプリケーションレベルでのエラー情報の使用に関する詳細については、「 [コントラクトとサービスのエラーの指定と処理](../specifying-and-handling-faults-in-contracts-and-services.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="48a13-147">For more complete information about working with error information at the application level, see [Specifying and Handling Faults in Contracts and Services](../specifying-and-handling-faults-in-contracts-and-services.md).</span></span> <span data-ttu-id="48a13-148">[予期](../samples/expected-exceptions.md) される例外は、予期される例外とその処理方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="48a13-148">[Expected Exceptions](../samples/expected-exceptions.md) describes expected exceptions and shows how to handle them.</span></span> <span data-ttu-id="48a13-149">チャネルの開発時に発生するエラーの処理方法の詳細については、「 [例外と](../extending/handling-exceptions-and-faults.md)エラーの処理」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="48a13-149">For more information about how to handle errors when developing channels, see [Handling Exceptions and Faults](../extending/handling-exceptions-and-faults.md).</span></span>  
  
### <a name="client-blocking-and-performance"></a><span data-ttu-id="48a13-150">クライアントのブロックとパフォーマンス</span><span class="sxs-lookup"><span data-stu-id="48a13-150">Client Blocking and Performance</span></span>  

 <span data-ttu-id="48a13-151">アプリケーションが要求/応答操作を同期的に呼び出す場合、戻り値が受信されるか例外 (<xref:System.TimeoutException?displayProperty=nameWithType> など) がスローされるまで、クライアントはブロックされます。</span><span class="sxs-lookup"><span data-stu-id="48a13-151">When an application synchronously calls a request-reply operation, the client blocks until a return value is received or an exception (such as a <xref:System.TimeoutException?displayProperty=nameWithType>) is thrown.</span></span> <span data-ttu-id="48a13-152">この動作はローカルの動作と似ています。</span><span class="sxs-lookup"><span data-stu-id="48a13-152">This behavior is similar to local behavior.</span></span> <span data-ttu-id="48a13-153">アプリケーションが WCF クライアントオブジェクトまたはチャネルで操作を同期的に呼び出すと、クライアントは、チャネル層がデータをネットワークに書き込むことができるようになるまで、または例外がスローされるまで、を返しません。</span><span class="sxs-lookup"><span data-stu-id="48a13-153">When an application synchronously invokes an operation on a WCF client object or channel, the client does not return until the channel layer can write the data to the network or until an exception is thrown.</span></span> <span data-ttu-id="48a13-154">また、一方向メッセージ交換パターン (<xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A?displayProperty=nameWithType> が `true` に設定された操作をマークすることで指定される) では、クライアントの応答性が向上する可能性がありますが、バインディングや送信済みのメッセージによっては、一方向操作でもブロックが生じる場合があります。</span><span class="sxs-lookup"><span data-stu-id="48a13-154">And while the one-way message exchange pattern (specified by marking an operation with <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A?displayProperty=nameWithType> set to `true`) can make some clients more responsive, one-way operations can also block, depending upon the binding and what messages have already been sent.</span></span> <span data-ttu-id="48a13-155">一方向操作とはメッセージ交換のみを指しています。</span><span class="sxs-lookup"><span data-stu-id="48a13-155">One-way operations are only about the message exchange, no more and no less.</span></span> <span data-ttu-id="48a13-156">詳細については、「 [一方向サービス](one-way-services.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="48a13-156">For more information, see [One-Way Services](one-way-services.md).</span></span>  
  
 <span data-ttu-id="48a13-157">メッセージ交換パターンに関係なく、大規模データのチャンクによりクライアント処理が遅延する場合があります。</span><span class="sxs-lookup"><span data-stu-id="48a13-157">Large data chunks can slow client processing no matter what the message exchange pattern.</span></span> <span data-ttu-id="48a13-158">これらの問題の対処方法については、「 [大規模なデータとストリーミング](large-data-and-streaming.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="48a13-158">To understand how to handle these issues, see [Large Data and Streaming](large-data-and-streaming.md).</span></span>  
  
 <span data-ttu-id="48a13-159">操作の完了中にアプリケーションでより多くの作業を行う必要がある場合は、WCF クライアントが実装するサービスコントラクトインターフェイスに非同期メソッドペアを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="48a13-159">If your application must do more work while an operation completes, you should create an asynchronous method pair on the service contract interface that your WCF client implements.</span></span> <span data-ttu-id="48a13-160">これを行う最も簡単な方法は、 `/async` [ServiceModel メタデータユーティリティツール (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md)でスイッチを使用することです。</span><span class="sxs-lookup"><span data-stu-id="48a13-160">The easiest way to do this is to use the `/async` switch on the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="48a13-161">例については、「 [方法: サービス操作を非同期に呼び出す](how-to-call-wcf-service-operations-asynchronously.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="48a13-161">For an example, see [How to: Call Service Operations Asynchronously](how-to-call-wcf-service-operations-asynchronously.md).</span></span>  
  
 <span data-ttu-id="48a13-162">クライアントパフォーマンスの向上の詳細については、「 [中間層クライアントアプリケーション](middle-tier-client-applications.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="48a13-162">For more information about increasing client performance, see [Middle-Tier Client Applications](middle-tier-client-applications.md).</span></span>  
  
### <a name="enabling-the-user-to-select-credentials-dynamically"></a><span data-ttu-id="48a13-163">ユーザーによる資格情報の動的選択の有効化</span><span class="sxs-lookup"><span data-stu-id="48a13-163">Enabling the User to Select Credentials Dynamically</span></span>  

 <span data-ttu-id="48a13-164"><xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer> インターフェイスを使用すると、アプリケーションによりユーザー インターフェイスが表示され、ユーザーが資格情報を選択できるようになります。この資格情報は、タイムアウト タイマーが開始される前に、チャネルの作成に使用されます。</span><span class="sxs-lookup"><span data-stu-id="48a13-164">The <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer> interface enables applications to display a user interface that enables the user to choose credentials with which a channel is created before the timeout timers start.</span></span>  
  
 <span data-ttu-id="48a13-165">アプリケーション開発者は、挿入された <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer> を 2 つの方法で利用できます。</span><span class="sxs-lookup"><span data-stu-id="48a13-165">Application developers can make use of an inserted <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer> in two ways.</span></span> <span data-ttu-id="48a13-166">クライアントアプリケーションは、チャネルを <xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> 開く前にまたは (または非同期バージョン) を呼び出すか ( *明示的* なアプローチ)、最初の操作を呼び出すことができます ( *暗黙的* な方法)。</span><span class="sxs-lookup"><span data-stu-id="48a13-166">The client application can call either <xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> (or an asynchronous version) prior to opening the channel (the *explicit* approach) or call the first operation (the *implicit* approach).</span></span>  
  
 <span data-ttu-id="48a13-167">暗黙的方法を使用する場合、アプリケーションは最初の操作を <xref:System.ServiceModel.ClientBase%601> または <xref:System.ServiceModel.IClientChannel> 拡張に対して呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="48a13-167">If using the implicit approach, the application must call the first operation on a <xref:System.ServiceModel.ClientBase%601> or <xref:System.ServiceModel.IClientChannel> extension.</span></span> <span data-ttu-id="48a13-168">アプリケーションが最初の操作以外の何かを呼び出した場合、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="48a13-168">If it calls anything other than the first operation, an exception is thrown.</span></span>  
  
 <span data-ttu-id="48a13-169">明示的方法を使用する場合、アプリケーションで次の手順を順番に実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="48a13-169">If using the explicit approach, the application must perform the following steps in order:</span></span>  
  
1. <span data-ttu-id="48a13-170"><xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> または <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> (または非同期バージョン) を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="48a13-170">Call either <xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> (or an asynchronous version).</span></span>  
  
2. <span data-ttu-id="48a13-171">初期化子が返された場合は、<xref:System.ServiceModel.ICommunicationObject.Open%2A> オブジェクトまたは <xref:System.ServiceModel.IClientChannel> プロパティで返された <xref:System.ServiceModel.IClientChannel> オブジェクトの <xref:System.ServiceModel.ClientBase%601.InnerChannel%2A?displayProperty=nameWithType> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="48a13-171">When the initializers have returned, call either the <xref:System.ServiceModel.ICommunicationObject.Open%2A> method on the <xref:System.ServiceModel.IClientChannel> object or on the <xref:System.ServiceModel.IClientChannel> object returned from the <xref:System.ServiceModel.ClientBase%601.InnerChannel%2A?displayProperty=nameWithType> property.</span></span>  
  
3. <span data-ttu-id="48a13-172">操作を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="48a13-172">Call operations.</span></span>  
  
 <span data-ttu-id="48a13-173">製品品質のアプリケーションでは、明示的な方法を採用することによってユーザー インターフェイスのプロセスを制御することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="48a13-173">It is recommended that production-quality applications control the user-interface process by adopting the explicit approach.</span></span>  
  
 <span data-ttu-id="48a13-174">暗黙的な方法を使用するアプリケーションでは、ユーザー インターフェイス初期化子が呼び出されますが、このアプリケーションのユーザーがバインディングの送信タイムアウト期間内に応答できない場合、ユーザー インターフェイスが復帰すると例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="48a13-174">Applications that use the implicit approach invoke the user-interface initializers, but if the user of the application fails to respond within the send timeout period of the binding, an exception is thrown when the user interface returns.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="48a13-175">関連項目</span><span class="sxs-lookup"><span data-stu-id="48a13-175">See also</span></span>

- [<span data-ttu-id="48a13-176">双方向サービス</span><span class="sxs-lookup"><span data-stu-id="48a13-176">Duplex Services</span></span>](duplex-services.md)
- [<span data-ttu-id="48a13-177">方法: 一方向コントラクトと要求/応答コントラクトを使用してサービスにアクセスする</span><span class="sxs-lookup"><span data-stu-id="48a13-177">How to: Access Services with One-Way and Request-Reply Contracts</span></span>](how-to-access-wcf-services-with-one-way-and-request-reply-contracts.md)
- [<span data-ttu-id="48a13-178">方法: 双方向コントラクトを使用してサービスにアクセスする</span><span class="sxs-lookup"><span data-stu-id="48a13-178">How to: Access Services with a Duplex Contract</span></span>](how-to-access-services-with-a-duplex-contract.md)
- [<span data-ttu-id="48a13-179">方法: WSE 3.0 サービスにアクセスする</span><span class="sxs-lookup"><span data-stu-id="48a13-179">How to: Access a WSE 3.0 Service</span></span>](how-to-access-a-wse-3-0-service-with-a-wcf-client.md)
- [<span data-ttu-id="48a13-180">方法: ChannelFactory を使用する</span><span class="sxs-lookup"><span data-stu-id="48a13-180">How to: Use the ChannelFactory</span></span>](how-to-use-the-channelfactory.md)
- [<span data-ttu-id="48a13-181">方法: サービス操作を非同期に呼び出す</span><span class="sxs-lookup"><span data-stu-id="48a13-181">How to: Call Service Operations Asynchronously</span></span>](how-to-call-wcf-service-operations-asynchronously.md)
- [<span data-ttu-id="48a13-182">中間層クライアント アプリケーション</span><span class="sxs-lookup"><span data-stu-id="48a13-182">Middle-Tier Client Applications</span></span>](middle-tier-client-applications.md)
