---
description: 詳細については、「特権の昇格」を参照してください。
title: 特権の昇格
ms.date: 03/30/2017
helpviewer_keywords:
- elevation of privilege [WCF]
- security [WCF], elevation of privilege
ms.assetid: 146e1c66-2a76-4ed3-98a5-fd77851a06d9
ms.openlocfilehash: 65aff3b8a1f258f68333fe39a2c980ae523d9ee9
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/06/2021
ms.locfileid: "99704941"
---
# <a name="elevation-of-privilege"></a><span data-ttu-id="b1cae-103">特権の昇格</span><span class="sxs-lookup"><span data-stu-id="b1cae-103">Elevation of Privilege</span></span>

<span data-ttu-id="b1cae-104">*特権の昇格* によって、最初に許可された権限以外に攻撃者の承認アクセス許可が付与されます。</span><span class="sxs-lookup"><span data-stu-id="b1cae-104">*Elevation of privilege* results from giving an attacker authorization permissions beyond those initially granted.</span></span> <span data-ttu-id="b1cae-105">たとえば、"読み取り専用" アクセス許可の権限セットを持つ攻撃者が、何らかの方法で権限セットを "読み取り/書き込み" アクセス許可を含むものに昇格させます。</span><span class="sxs-lookup"><span data-stu-id="b1cae-105">For example, an attacker with a privilege set of "read only" permissions somehow elevates the set to include "read and write."</span></span>  
  
## <a name="trusted-sts-should-sign-saml-token-claims"></a><span data-ttu-id="b1cae-106">SAML トークンのクレームには信頼された STS による署名が必要</span><span class="sxs-lookup"><span data-stu-id="b1cae-106">Trusted STS Should Sign SAML Token Claims</span></span>  

 <span data-ttu-id="b1cae-107">SAML (Security Assertions Markup Language) トークンは、発行済みトークンの既定の型である汎用 XML トークンです。</span><span class="sxs-lookup"><span data-stu-id="b1cae-107">A Security Assertions Markup Language (SAML) token is a generic XML token that is the default type for issued tokens.</span></span> <span data-ttu-id="b1cae-108">SAML トークンは、通常の交換においてエンド Web サービスから信頼されたセキュリティ トークン サービス (STS) によって作成できます。</span><span class="sxs-lookup"><span data-stu-id="b1cae-108">A SAML token can be constructed by a Security Token Service (STS) that the end Web service trusts in a typical exchange.</span></span> <span data-ttu-id="b1cae-109">SAML トークンには、ステートメント内にクレームが格納されます。</span><span class="sxs-lookup"><span data-stu-id="b1cae-109">SAML tokens contain claims in statements.</span></span> <span data-ttu-id="b1cae-110">攻撃者は、有効なトークンからクレームをコピーして新しい SAML トークンを作成し、別の発行者による署名を行うことがあります。</span><span class="sxs-lookup"><span data-stu-id="b1cae-110">An attacker may copy the claims from a valid token, create a new SAML token, and sign it with a different issuer.</span></span> <span data-ttu-id="b1cae-111">この目的は、サーバーが発行者を検証するかどうかを確認し、検証しない場合に、この脆弱性を利用して信頼された STS が意図したものよりも高い権限を与える SAML トークンを作成することです。</span><span class="sxs-lookup"><span data-stu-id="b1cae-111">The intent is to determine whether the server is validating issuers and, if not, utilize the weakness to construct SAML tokens that allow privileges beyond those intended by a trusted STS.</span></span>  
  
 <span data-ttu-id="b1cae-112"><xref:System.IdentityModel.Tokens.SamlAssertion> クラスは、SAML トークンに含まれるデジタル署名を検証します。<xref:System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator> クラスの <xref:System.ServiceModel.Security.IssuedTokenServiceCredential.CertificateValidationMode%2A> が <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> に設定されている場合、既定の <xref:System.ServiceModel.Security.X509CertificateValidationMode.ChainTrust> は、SAML トークンが有効な X.509 証明書によって署名されていることを要求します。</span><span class="sxs-lookup"><span data-stu-id="b1cae-112">The <xref:System.IdentityModel.Tokens.SamlAssertion> class verifies the digital signature contained within a SAML token, and the default <xref:System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator> requires that SAML tokens be signed by an X.509 certificate that is valid when the <xref:System.ServiceModel.Security.IssuedTokenServiceCredential.CertificateValidationMode%2A> of the <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> class is set to <xref:System.ServiceModel.Security.X509CertificateValidationMode.ChainTrust>.</span></span> <span data-ttu-id="b1cae-113">SAML トークンの発行者を信頼できるかどうか判断するには、`ChainTrust` モードだけでは不十分です。</span><span class="sxs-lookup"><span data-stu-id="b1cae-113">`ChainTrust` mode alone is insufficient to determine whether the issuer of the SAML token is trusted.</span></span> <span data-ttu-id="b1cae-114">より詳細な信頼モデルを必要とするサービスは、承認ポリシーと強制ポリシーを使用して、発行済みトークン認証によって生成されたクレーム セットの発行者をチェックするか、<xref:System.ServiceModel.Security.IssuedTokenServiceCredential> の X.509 検証設定を使用して、許可する署名証明書のセットを制限できます。</span><span class="sxs-lookup"><span data-stu-id="b1cae-114">Services that require a more granular trust model can either use authorization and enforcement policies to check the issuer of the claim sets produced by issued token authentication or use the X.509 validation settings on <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> to restrict the set of allowed signing certificates.</span></span> <span data-ttu-id="b1cae-115">詳細については、「Id モデルと[フェデレーションおよび発行済みトークン](federation-and-issued-tokens.md)[を使用したクレームと承認の管理](managing-claims-and-authorization-with-the-identity-model.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b1cae-115">For more information, see [Managing Claims and Authorization with the Identity Model](managing-claims-and-authorization-with-the-identity-model.md) and [Federation and Issued Tokens](federation-and-issued-tokens.md).</span></span>  
  
## <a name="switching-identity-without-a-security-context"></a><span data-ttu-id="b1cae-116">セキュリティ コンテキストを使用しない ID の切り替え</span><span class="sxs-lookup"><span data-stu-id="b1cae-116">Switching Identity Without a Security Context</span></span>  

 <span data-ttu-id="b1cae-117">次の例は、WinFX にのみ適用されます。</span><span class="sxs-lookup"><span data-stu-id="b1cae-117">The following applies only to WinFX.</span></span>  
  
 <span data-ttu-id="b1cae-118">クライアントとサーバーの間に接続が確立されている場合、クライアントの id は変更されません。ただし、次の条件がすべて当てはまる場合は、WCF クライアントが開かれた後であることが条件となります。</span><span class="sxs-lookup"><span data-stu-id="b1cae-118">When a connection is established between a client and server, the identity of the client does not change, except in one situation: after the WCF client is opened, if all of the following conditions are true:</span></span>  
  
- <span data-ttu-id="b1cae-119">(トランスポートセキュリティセッションまたはメッセージセキュリティセッションを使用して) セキュリティコンテキストを確立する手順はオフになってい <xref:System.ServiceModel.NonDualMessageSecurityOverHttp.EstablishSecurityContext%2A> ます (メッセージセキュリティの場合は、プロパティはに設定され、トランスポート `false` セキュリティの場合はセキュリティセッションを確立できません)。</span><span class="sxs-lookup"><span data-stu-id="b1cae-119">The procedures to establish a security context (using a transport security session or message security session) is switched off (<xref:System.ServiceModel.NonDualMessageSecurityOverHttp.EstablishSecurityContext%2A> property is set to `false` in case of message security or transport not capable of establishing security sessions is used in transport security case.</span></span> <span data-ttu-id="b1cae-120">トランスポート セキュリティの場合は、セキュリティ セッションを確立できないトランスポート (HTTPS など) が使用されている)。</span><span class="sxs-lookup"><span data-stu-id="b1cae-120">HTTPS is one example of such transport).</span></span>  
  
- <span data-ttu-id="b1cae-121">Windows 認証を使用している。</span><span class="sxs-lookup"><span data-stu-id="b1cae-121">You are using Windows authentication.</span></span>  
  
- <span data-ttu-id="b1cae-122">資格情報を明示的に設定していない。</span><span class="sxs-lookup"><span data-stu-id="b1cae-122">You do not explicitly set the credential.</span></span>  
  
- <span data-ttu-id="b1cae-123">偽装されたセキュリティ コンテキストでサービスを呼び出している。</span><span class="sxs-lookup"><span data-stu-id="b1cae-123">You are calling the service under the impersonated security context.</span></span>  
  
 <span data-ttu-id="b1cae-124">これらの条件に該当する場合は、サービスに対するクライアントの認証に使用される id が変更される可能性があります (偽装された id ではなく、プロセス id ではなく、WCF クライアントが開かれた後)。</span><span class="sxs-lookup"><span data-stu-id="b1cae-124">If these conditions are true, the identity used to authenticate the client to the service might change (it might not be the impersonated identity but the process identity instead) after the WCF client is opened.</span></span> <span data-ttu-id="b1cae-125">この状況が発生するのは、サービスに対するクライアントの認証に使用する Windows 資格情報がすべてのメッセージと共に送信され、認証に使用する資格情報が現在のスレッドの Windows ID から取得されるためです。</span><span class="sxs-lookup"><span data-stu-id="b1cae-125">This occurs because the Windows credential used to authenticate the client to the service is transmitted with every message, and the credential used for authentication is obtained from the current thread's Windows identity.</span></span> <span data-ttu-id="b1cae-126">(たとえば、別の呼び出し元を偽装することによって) 現在のスレッドの Windows ID が変更された場合、メッセージに添付され、サービスに対するクライアントの認証に使用する資格情報も変更される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b1cae-126">If the Windows identity of the current thread changes (for example, by impersonating a different caller), the credential that is attached to the message and used to authenticate the client to the service might also change.</span></span>  
  
 <span data-ttu-id="b1cae-127">偽装と共に Windows 認証を使用する場合に動作を確定する必要があるときは、Windows 資格情報を明示的に設定するか、サービスでセキュリティ コンテキストを確立する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b1cae-127">If you want to have deterministic behavior when using Windows authentication together with impersonation you need to explicitly set the Windows credential or you need to establish a security context with the service.</span></span> <span data-ttu-id="b1cae-128">これを行うには、メッセージ セキュリティ セッションまたはトランスポート セキュリティ セッションを使用します。</span><span class="sxs-lookup"><span data-stu-id="b1cae-128">To do this, use a message security session or a transport security session.</span></span> <span data-ttu-id="b1cae-129">たとえば、net.tcp トランスポートは、トランスポート セキュリティ セッションを提供します。</span><span class="sxs-lookup"><span data-stu-id="b1cae-129">For example, the net.tcp transport can provide a transport security session.</span></span> <span data-ttu-id="b1cae-130">また、サービスの呼び出し時に、クライアント操作の同期バージョンだけを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b1cae-130">Additionally, you must use only a synchronous version of client operations when calling the service.</span></span> <span data-ttu-id="b1cae-131">メッセージ セキュリティ コンテキストを確立する場合は、構成済みセッションの更新時間よりも長い時間、サービスへの接続を開いたままにしないようにしてください。セッション更新プロセスの間にも ID が変更される可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="b1cae-131">If you establish a message security context, you should not keep the connection to the service open longer than the configured session renewal period, because the identity can also change during the session renewal process.</span></span>  
  
### <a name="credentials-capture"></a><span data-ttu-id="b1cae-132">資格情報のキャプチャ</span><span class="sxs-lookup"><span data-stu-id="b1cae-132">Credentials Capture</span></span>  

 <span data-ttu-id="b1cae-133">.NET Framework 3.5、およびそれ以降のバージョンには、次のものが適用されます。</span><span class="sxs-lookup"><span data-stu-id="b1cae-133">The following applies to .NET Framework 3.5, and subsequent versions.</span></span>  
  
 <span data-ttu-id="b1cae-134">クライアントまたはサービスが使用する資格情報は、現在のコンテキストのスレッドに基づきます。</span><span class="sxs-lookup"><span data-stu-id="b1cae-134">Credentials used by the client or the service are based on the current context thread.</span></span> <span data-ttu-id="b1cae-135">資格情報は、クライアントまたはサービスの `Open` メソッド (または、非同期呼び出しの場合は `BeginOpen`) が呼び出された場合に取得されます。</span><span class="sxs-lookup"><span data-stu-id="b1cae-135">The credentials are obtained when the `Open` method (or `BeginOpen`, for asynchronous calls) of the client or service is called.</span></span> <span data-ttu-id="b1cae-136"><xref:System.ServiceModel.ServiceHost> クラスおよび <xref:System.ServiceModel.ClientBase%601> クラスのいずれの場合も、`Open` メソッドおよび `BeginOpen` メソッドは、<xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> クラスの <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> メソッドおよび <xref:System.ServiceModel.Channels.CommunicationObject> メソッドから継承されます。</span><span class="sxs-lookup"><span data-stu-id="b1cae-136">For both the <xref:System.ServiceModel.ServiceHost> and <xref:System.ServiceModel.ClientBase%601> classes, the `Open` and `BeginOpen` methods inherit from the <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> and <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> methods of the <xref:System.ServiceModel.Channels.CommunicationObject> class.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="b1cae-137">`BeginOpen` メソッドを使用する場合、キャプチャされた資格情報は、このメソッドを呼び出したプロセスの資格情報であることが保証されません。</span><span class="sxs-lookup"><span data-stu-id="b1cae-137">When using the `BeginOpen` method, the credentials captured cannot be guaranteed to be the credentials of the process that calls the method.</span></span>  
  
## <a name="token-caches-allow-replay-using-obsolete-data"></a><span data-ttu-id="b1cae-138">トークン キャッシュによる以前のデータを使用した再生の許可</span><span class="sxs-lookup"><span data-stu-id="b1cae-138">Token Caches Allow Replay Using Obsolete Data</span></span>  

 <span data-ttu-id="b1cae-139">WCF では、 `LogonUser` ユーザー名とパスワードによってユーザーを認証するために、ローカルセキュリティ機関 (LSA) の機能が使用されます。</span><span class="sxs-lookup"><span data-stu-id="b1cae-139">WCF uses the local security authority (LSA) `LogonUser` function to authenticate users by user name and password.</span></span> <span data-ttu-id="b1cae-140">Logon 関数はコストのかかる操作なので、WCF では、認証されたユーザーを表すトークンをキャッシュしてパフォーマンスを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="b1cae-140">Because the logon function is a costly operation, WCF allows you to cache tokens that represent authenticated users to increase performance.</span></span> <span data-ttu-id="b1cae-141">キャッシュ機構は、それ以降に使用できるように `LogonUser` の結果を保存します。</span><span class="sxs-lookup"><span data-stu-id="b1cae-141">The caching mechanism saves the results from `LogonUser` for subsequent uses.</span></span> <span data-ttu-id="b1cae-142">このメカニズムは、既定では無効になっています。有効にするには、 <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CacheLogonTokens%2A> プロパティをに設定する `true` か `cacheLogonTokens` 、の属性を使用し [\<userNameAuthentication>](../../configure-apps/file-schema/wcf/usernameauthentication.md) ます。</span><span class="sxs-lookup"><span data-stu-id="b1cae-142">This mechanism is disabled by default; to enable it, set the <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CacheLogonTokens%2A> property to `true`, or use the `cacheLogonTokens` attribute of the [\<userNameAuthentication>](../../configure-apps/file-schema/wcf/usernameauthentication.md).</span></span>  
  
 <span data-ttu-id="b1cae-143"><xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CachedLogonTokenLifetime%2A> プロパティを <xref:System.TimeSpan> に設定するか、`cachedLogonTokenLifetime` 要素の `userNameAuthentication` 属性を使用することで、キャッシュされたトークンの有効期間 (TTL) を設定できます。既定値は 15 分です。</span><span class="sxs-lookup"><span data-stu-id="b1cae-143">You can set a Time to Live (TTL) for the cached tokens by setting the <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CachedLogonTokenLifetime%2A> property to a <xref:System.TimeSpan>, or use the `cachedLogonTokenLifetime` attribute of the `userNameAuthentication` element; the default is 15 minutes.</span></span> <span data-ttu-id="b1cae-144">Windows からユーザー アカウントが削除された場合や、パスワードが変更されている場合でも、トークンがキャッシュされている間は、同じユーザー名とパスワードを指定すると、どのクライアントもこのトークンを使用できます。</span><span class="sxs-lookup"><span data-stu-id="b1cae-144">Note that while a token is cached, any client that presents the same user name and password can use the token, even if the user account is deleted from Windows or if its password has been changed.</span></span> <span data-ttu-id="b1cae-145">TTL が期限切れになり、トークンがキャッシュから削除されるまで、WCF では (悪意のある可能性がある) ユーザーの認証を許可します。</span><span class="sxs-lookup"><span data-stu-id="b1cae-145">Until the TTL expires and the token is removed from the cache, WCF allows the (possibly malicious) user to authenticate.</span></span>  
  
 <span data-ttu-id="b1cae-146">これをできるだけ防ぐには、`cachedLogonTokenLifetime` の設定値をユーザーが必要とする最低の期間に限定して攻撃領域を減らします。</span><span class="sxs-lookup"><span data-stu-id="b1cae-146">To mitigate this: Decrease the attack window by setting the `cachedLogonTokenLifetime` value to the shortest time span your users need.</span></span>  
  
## <a name="issued-token-authorization-expiration-reset-to-large-value"></a><span data-ttu-id="b1cae-147">発行済みトークンの承認 : 大きな値にリセットされた有効期限</span><span class="sxs-lookup"><span data-stu-id="b1cae-147">Issued Token Authorization: Expiration Reset to Large Value</span></span>  

 <span data-ttu-id="b1cae-148">一定の条件下で、<xref:System.IdentityModel.Policy.AuthorizationContext.ExpirationTime%2A> の <xref:System.IdentityModel.Policy.AuthorizationContext> プロパティが予期しない大きな値 (<xref:System.DateTime.MaxValue> フィールド値から 1 日引いた値 (December 20, 9999)) に設定される場合があります。</span><span class="sxs-lookup"><span data-stu-id="b1cae-148">Under certain conditions, the <xref:System.IdentityModel.Policy.AuthorizationContext.ExpirationTime%2A> property of the <xref:System.IdentityModel.Policy.AuthorizationContext> may be set to an unexpectedly larger value (the <xref:System.DateTime.MaxValue> field value minus one day, or December 20, 9999).</span></span>  
  
 <span data-ttu-id="b1cae-149">これは、<xref:System.ServiceModel.WSFederationHttpBinding>、およびクライアント資格情報の種類が発行済みトークンであるシステム提供のバインディングを使用している場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="b1cae-149">This occurs when using the <xref:System.ServiceModel.WSFederationHttpBinding> and any of the system-provided bindings that have an issued token as the client credential type.</span></span>  
  
 <span data-ttu-id="b1cae-150">また、以下のメソッドのいずれかを使用して、カスタム バインドを作成した場合にも発生します。</span><span class="sxs-lookup"><span data-stu-id="b1cae-150">This also occurs when you create custom bindings by using one of the following methods:</span></span>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForCertificateBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForSslBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenOverTransportBindingElement%2A>  
  
 <span data-ttu-id="b1cae-151">これをできるだけ防ぐには、承認ポリシーによって各承認ポリシーのアクションと有効期限をチェックする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b1cae-151">To mitigate this, the authorization policy must check the action and the expiration time of each authorization policy.</span></span>  
  
## <a name="the-service-uses-a-different-certificate-than-the-client-intended"></a><span data-ttu-id="b1cae-152">クライアントで予定していたものと異なる証明書をサービスで使用する場合</span><span class="sxs-lookup"><span data-stu-id="b1cae-152">The Service Uses a Different Certificate Than the Client Intended</span></span>  

 <span data-ttu-id="b1cae-153">一定の条件下で、クライアントが X.509 証明書を使用してメッセージにデジタル署名したときに、予定していたものと異なる証明書をサービスが取得する場合があります。</span><span class="sxs-lookup"><span data-stu-id="b1cae-153">Under certain conditions, a client can digitally sign a message with an X.509 certificate and have the service retrieve a different certificate than the intended one.</span></span>  
  
 <span data-ttu-id="b1cae-154">これは、次のような状況で発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b1cae-154">This can occur under the following circumstances:</span></span>  
  
- <span data-ttu-id="b1cae-155">クライアントが X.509 証明書を使用してメッセージにデジタル署名したときに、その X.509 証明書をメッセージに添付するのではなく、サブジェクト キー識別子を使用して証明書を参照しているだけの場合。</span><span class="sxs-lookup"><span data-stu-id="b1cae-155">The client digitally signs a message using an X.509 certificate and does not attach the X.509 certificate to the message, but rather just references the certificate using its subject key identifier.</span></span>  
  
- <span data-ttu-id="b1cae-156">サービスのコンピューターに同じ公開キーを持つ複数の証明書が格納されており、それらの証明書に含まれる情報が異なる場合。</span><span class="sxs-lookup"><span data-stu-id="b1cae-156">The service's computer contains two or more certificates with the same public key, but they contain different information.</span></span>  
  
- <span data-ttu-id="b1cae-157">サービスがサブジェクト キー識別子と一致する証明書を取得したが、クライアントが使用する予定だったものではない場合。</span><span class="sxs-lookup"><span data-stu-id="b1cae-157">The service retrieves a certificate that matches the subject key identifier, but it is not the one the client intended to use.</span></span> <span data-ttu-id="b1cae-158">WCF は、メッセージを受信して署名を検証するときに、意図しない x.509 証明書の情報を、クライアントが期待するものとは異なる、または昇格された可能性のある一連のクレームにマップします。</span><span class="sxs-lookup"><span data-stu-id="b1cae-158">When WCF receives the message and verifies the signature, WCF maps the information in the unintended X.509 certificate to a set of claims that are different and potentially elevated from what the client expected.</span></span>  
  
 <span data-ttu-id="b1cae-159">これをできるだけ防ぐには、X.509 証明書を別の方法 (<xref:System.ServiceModel.Security.Tokens.X509KeyIdentifierClauseType.IssuerSerial> の使用など) で参照します。</span><span class="sxs-lookup"><span data-stu-id="b1cae-159">To mitigate this, reference the X.509 certificate another way, such as using <xref:System.ServiceModel.Security.Tokens.X509KeyIdentifierClauseType.IssuerSerial>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b1cae-160">関連項目</span><span class="sxs-lookup"><span data-stu-id="b1cae-160">See also</span></span>

- [<span data-ttu-id="b1cae-161">セキュリティに関する考慮事項</span><span class="sxs-lookup"><span data-stu-id="b1cae-161">Security Considerations</span></span>](security-considerations-in-wcf.md)
- [<span data-ttu-id="b1cae-162">情報漏えい</span><span class="sxs-lookup"><span data-stu-id="b1cae-162">Information Disclosure</span></span>](information-disclosure.md)
- [<span data-ttu-id="b1cae-163">サービス拒否</span><span class="sxs-lookup"><span data-stu-id="b1cae-163">Denial of Service</span></span>](denial-of-service.md)
- [<span data-ttu-id="b1cae-164">リプレイ攻撃</span><span class="sxs-lookup"><span data-stu-id="b1cae-164">Replay Attacks</span></span>](replay-attacks.md)
- [<span data-ttu-id="b1cae-165">改ざん</span><span class="sxs-lookup"><span data-stu-id="b1cae-165">Tampering</span></span>](tampering.md)
- [<span data-ttu-id="b1cae-166">サポートされていないシナリオ</span><span class="sxs-lookup"><span data-stu-id="b1cae-166">Unsupported Scenarios</span></span>](unsupported-scenarios.md)
