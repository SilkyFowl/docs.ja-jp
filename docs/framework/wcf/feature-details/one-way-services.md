---
description: 詳細については、「One-Way Services」を参照してください。
title: 一方向サービス
ms.date: 03/30/2017
helpviewer_keywords:
- Windows Communication Foundation [WCF], one-way service contracts
- WCF [WCF], one-way service contracts
- service contracts [WCF], defining one-way
ms.assetid: 19053a36-4492-45a3-bfe6-0365ee0205a3
ms.openlocfilehash: c614db0103506022da72e8f4659ae09e8b949a27
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/06/2021
ms.locfileid: "99733698"
---
# <a name="one-way-services"></a><span data-ttu-id="f9d98-103">一方向サービス</span><span class="sxs-lookup"><span data-stu-id="f9d98-103">One-Way Services</span></span>

<span data-ttu-id="f9d98-104">サービス操作の既定の動作は、要求/応答パターンです。</span><span class="sxs-lookup"><span data-stu-id="f9d98-104">The default behavior of a service operation is the request-reply pattern.</span></span> <span data-ttu-id="f9d98-105">要求/応答パターンでは、サービス操作がコードで `void` 型のメソッドとして表される場合であっても、クライアントは応答メッセージを待機します。</span><span class="sxs-lookup"><span data-stu-id="f9d98-105">In a request-reply pattern, the client waits for the reply message, even if the service operation is represented in code as a `void` method.</span></span> <span data-ttu-id="f9d98-106">一方向操作では、メッセージが 1 つ送信されるだけです。</span><span class="sxs-lookup"><span data-stu-id="f9d98-106">With a one-way operation, only one message is transmitted.</span></span> <span data-ttu-id="f9d98-107">受信者は応答メッセージを送信せず、送信者もこれを待機しません。</span><span class="sxs-lookup"><span data-stu-id="f9d98-107">The receiver does not send a reply message, nor does the sender expect one.</span></span>  
  
 <span data-ttu-id="f9d98-108">一方向デザイン パターンは次の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="f9d98-108">Use the one-way design pattern:</span></span>  
  
- <span data-ttu-id="f9d98-109">クライアントが操作を呼び出す必要があり、操作レベルで操作の結果に影響を受けない場合。</span><span class="sxs-lookup"><span data-stu-id="f9d98-109">When the client must call operations and is not affected by the result of the operation at the operation level.</span></span>  
  
- <span data-ttu-id="f9d98-110"><xref:System.ServiceModel.NetMsmqBinding> クラスまたは <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> クラスを使用している場合 </span><span class="sxs-lookup"><span data-stu-id="f9d98-110">When using the <xref:System.ServiceModel.NetMsmqBinding> or the <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> class.</span></span> <span data-ttu-id="f9d98-111">(このシナリオの詳細については、「 [WCF のキュー](queues-in-wcf.md)」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="f9d98-111">(For more information about this scenario, see [Queues in WCF](queues-in-wcf.md).)</span></span>  
  
 <span data-ttu-id="f9d98-112">操作が一方向の場合、エラー情報をクライアントに伝達する応答メッセージはありません。</span><span class="sxs-lookup"><span data-stu-id="f9d98-112">When an operation is one-way, there is no response message to carry error information back to the client.</span></span> <span data-ttu-id="f9d98-113">エラー状態を検出するには、信頼できるセッションのような基になるバインディングの機能を使用できます。また、2 つの一方向操作 (1 つは、サービス操作を呼び出すための、クライアントからサービスへの一方向コントラクト、もう 1 つは、クライアントが実装するコールバックを使用してサービスがエラーを返せるようにする、サービスとクライアントの間の一方向コントラクト) を使用する双方向サービス コントラクトをデザインすることもできます。</span><span class="sxs-lookup"><span data-stu-id="f9d98-113">You can detect error conditions by using features of the underlying binding, such as reliable sessions, or by designing a duplex service contract that uses two one-way operations—a one-way contract from the client to the service to call service operation and another one-way contract between the service and the client so that the service can send back faults to the client using a callback that the client implements.</span></span>  
  
 <span data-ttu-id="f9d98-114">一方向サービス コントラクトを作成するには、サービス コントラクトを定義し、<xref:System.ServiceModel.OperationContractAttribute> クラスを各操作に適用し、<xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> プロパティを `true` に設定します。次のコードを参照してください。</span><span class="sxs-lookup"><span data-stu-id="f9d98-114">To create a one-way service contract, define your service contract, apply the <xref:System.ServiceModel.OperationContractAttribute> class to each operation, and set the <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> property to `true`, as shown in the following sample code.</span></span>  
  
```csharp
[ServiceContract(Namespace="http://Microsoft.ServiceModel.Samples")]  
public interface IOneWayCalculator  
{  
    [OperationContract(IsOneWay=true)]  
    void Add(double n1, double n2);  
    [OperationContract(IsOneWay = true)]  
    void Subtract(double n1, double n2);  
    [OperationContract(IsOneWay = true)]  
    void Multiply(double n1, double n2);  
    [OperationContract(IsOneWay = true)]  
    void Divide(double n1, double n2);  
}  
```  
  
 <span data-ttu-id="f9d98-115">完全な例については、 [一方向](../samples/one-way.md) のサンプルを参照してください。</span><span class="sxs-lookup"><span data-stu-id="f9d98-115">For a complete example, see the [One-Way](../samples/one-way.md) sample.</span></span>  
  
## <a name="clients-blocking-with-one-way-operations"></a><span data-ttu-id="f9d98-116">一方向操作でのクライアントのブロック</span><span class="sxs-lookup"><span data-stu-id="f9d98-116">Clients Blocking with One-Way Operations</span></span>  

 <span data-ttu-id="f9d98-117">一部の一方向アプリケーションは、送信データがネットワーク接続に書き込まれるとすぐに戻りますが、いくつかのシナリオでは、バインディングまたはサービスの実装によって、WCF クライアントが一方向の操作を使用してブロックされる可能性があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="f9d98-117">It is important to realize that while some one-way applications return as soon as the outbound data is written to the network connection, in several scenarios the implementation of a binding or of a service can cause a WCF client to block using one-way operations.</span></span> <span data-ttu-id="f9d98-118">WCF クライアントアプリケーションでは、送信データがネットワーク接続に書き込まれるまで、WCF クライアントオブジェクトは返されません。</span><span class="sxs-lookup"><span data-stu-id="f9d98-118">In WCF client applications, the WCF client object does not return until the outbound data has been written to the network connection.</span></span> <span data-ttu-id="f9d98-119">これは一方向操作を含め、すべてのメッセージ交換パターンについて当てはまることで、トランスポートへのデータの書き込みに何らかの問題があると、クライアントが処理を終了できなくなることを意味します。</span><span class="sxs-lookup"><span data-stu-id="f9d98-119">This is true for all message exchange patterns, including one-way operations; this means that any problem writing the data to the transport prevents the client from returning.</span></span> <span data-ttu-id="f9d98-120">問題の種類によっては、例外が発生したりサービスへのメッセージの送信に遅延が発生したりする結果となることがあります。</span><span class="sxs-lookup"><span data-stu-id="f9d98-120">Depending upon the problem, the result could be an exception or a delay in sending messages to the service.</span></span>  
  
 <span data-ttu-id="f9d98-121">たとえば、トランスポートがエンドポイントを見つけられない場合、大きな遅延なしに <xref:System.ServiceModel.EndpointNotFoundException?displayProperty=nameWithType> 例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="f9d98-121">For example, if the transport cannot find the endpoint, a <xref:System.ServiceModel.EndpointNotFoundException?displayProperty=nameWithType> exception is thrown without much delay.</span></span> <span data-ttu-id="f9d98-122">ただし、サービスが何らかの理由によりデータをネットワークから読み込めないために、クライアントのトランスポート送信操作が終了しない可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="f9d98-122">However, it is also possible that the service is unable to read the data off the wire for some reason, which prevents the client transport send operation from returning.</span></span> <span data-ttu-id="f9d98-123">このような場合、クライアントのトランスポート バインディングで <xref:System.ServiceModel.Channels.Binding.SendTimeout%2A?displayProperty=nameWithType> 期間が経過すると、<xref:System.TimeoutException?displayProperty=nameWithType> がスローされますが、タイムアウト時間が経過するまで例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="f9d98-123">In these cases, if the <xref:System.ServiceModel.Channels.Binding.SendTimeout%2A?displayProperty=nameWithType> period on the client transport binding is exceeded, a <xref:System.TimeoutException?displayProperty=nameWithType> is thrown—but not until the timeout period has been exceeded.</span></span> <span data-ttu-id="f9d98-124">またサービスに多数のメッセージが集中しているために、一定の期間が経過するまでサービスがメッセージを処理できないことがあります。</span><span class="sxs-lookup"><span data-stu-id="f9d98-124">It is also possible to fire so many messages at a service that the service cannot process them past a certain point.</span></span> <span data-ttu-id="f9d98-125">この場合も、サービスがメッセージを処理できるまで、または例外がスローされるまで、一方向クライアントはブロックします。</span><span class="sxs-lookup"><span data-stu-id="f9d98-125">In this case, too, the one-way client blocks until the service can process the messages or until an exception is thrown.</span></span>  
  
 <span data-ttu-id="f9d98-126">さらに別の状況として、サービスの <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A?displayProperty=nameWithType> プロパティが <xref:System.ServiceModel.ConcurrencyMode.Single> に設定されているのに、バインディングが複数のセッションを使用する場合があります。</span><span class="sxs-lookup"><span data-stu-id="f9d98-126">Another variation is the situation in which the service <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A?displayProperty=nameWithType> property is set to <xref:System.ServiceModel.ConcurrencyMode.Single> and the binding uses sessions.</span></span> <span data-ttu-id="f9d98-127">この場合、ディスパッチャーにより受信メッセージの並び替え (セッションの要件) が強制され、サービスがそのセッションの以前のメッセージの処理を終えるまで、後続のメッセージはネットワークから読み込まれません。</span><span class="sxs-lookup"><span data-stu-id="f9d98-127">In this case, the dispatcher enforces ordering on the incoming messages (a requirement of sessions), which prevents subsequent messages from being read off the network until the service has processed the preceding message for that session.</span></span> <span data-ttu-id="f9d98-128">この場合も、クライアントはブロックしますが、例外が発生するかどうかは、サービスがこのクライアントで設定されているタイムアウト期間が経過する前に、待機中のデータを処理できるかどうかによって異なります。</span><span class="sxs-lookup"><span data-stu-id="f9d98-128">Again, the client blocks, but whether an exception occurs depends upon whether the service is able to process the waiting data prior to the timeout settings on the client.</span></span>  
  
 <span data-ttu-id="f9d98-129">この問題を軽減するには、クライアント オブジェクトとクライアントのトランスポート送信操作との間にバッファーを挿入します。</span><span class="sxs-lookup"><span data-stu-id="f9d98-129">You can mitigate some of this problem by inserting a buffer between the client object and the client transport's send operation.</span></span> <span data-ttu-id="f9d98-130">たとえば、非同期呼び出しまたはメモリ内メッセージ キューを使用すると、クライアント オブジェクトの処理を短時間で終了できます。</span><span class="sxs-lookup"><span data-stu-id="f9d98-130">For example, using asynchronous calls or using an in-memory message queue can enable the client object to return quickly.</span></span> <span data-ttu-id="f9d98-131">どちらのアプローチでも機能性は向上しますが、スレッド プールとメッセージ キューのサイズによる制限は残ります。</span><span class="sxs-lookup"><span data-stu-id="f9d98-131">Both approaches may increase functionality, but the size of the thread pool and the message queue still enforce limits.</span></span>  
  
 <span data-ttu-id="f9d98-132">代わりに、クライアントおよびサービスの各種コントロールを調べてアプリケーション シナリオをテストし、最適な構成がどちら側にあるのかを判断することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f9d98-132">It is recommended, instead, that you examine the various controls on the service as well as on the client, and then test your application scenarios to determine the best configuration on either side.</span></span> <span data-ttu-id="f9d98-133">たとえば、セッションの使用によりサービスでのメッセージの処理がブロックされている場合、<xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> プロパティを <xref:System.ServiceModel.InstanceContextMode.PerCall> に設定することによって、異なるサービス インスタンスによって各メッセージが処理されるようにし、また <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> を <xref:System.ServiceModel.ConcurrencyMode.Multiple> に設定することによって、複数のスレッドで同時にメッセージをディスパッチできるようにします。</span><span class="sxs-lookup"><span data-stu-id="f9d98-133">For example, if the use of sessions is blocking the processing of messages on your service, you can set the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property to <xref:System.ServiceModel.InstanceContextMode.PerCall> so that each message can be processed by a different service instance, and set the <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> to <xref:System.ServiceModel.ConcurrencyMode.Multiple> in order to allow more than one thread to dispatch messages at a time.</span></span> <span data-ttu-id="f9d98-134">また、別のアプローチとして、サービスとクライアント バインディングの読み取りクォータを増やすという方法もあります。</span><span class="sxs-lookup"><span data-stu-id="f9d98-134">Another approach is to increase the read quotas of the service and client bindings.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f9d98-135">関連項目</span><span class="sxs-lookup"><span data-stu-id="f9d98-135">See also</span></span>

- [<span data-ttu-id="f9d98-136">一方向</span><span class="sxs-lookup"><span data-stu-id="f9d98-136">One-Way</span></span>](../samples/one-way.md)
