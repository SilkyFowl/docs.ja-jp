---
description: 詳細については、「データ転送アーキテクチャの概要」を参照してください。
title: データ転送のアーキテクチャの概要
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- data transfer [WCF], architectural overview
ms.assetid: 343c2ca2-af53-4936-a28c-c186b3524ee9
ms.openlocfilehash: 3064797b41e146505062a07dc1786dd492a01298
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/06/2021
ms.locfileid: "99756501"
---
# <a name="data-transfer-architectural-overview"></a><span data-ttu-id="ca589-103">データ転送のアーキテクチャの概要</span><span class="sxs-lookup"><span data-stu-id="ca589-103">Data Transfer Architectural Overview</span></span>

<span data-ttu-id="ca589-104">Windows Communication Foundation (WCF) は、メッセージングインフラストラクチャと考えることができます。</span><span class="sxs-lookup"><span data-stu-id="ca589-104">Windows Communication Foundation (WCF) can be thought of as a messaging infrastructure.</span></span> <span data-ttu-id="ca589-105">WCF は、メッセージを受信し、それらのメッセージを処理し、さらにアクションを実行するためにユーザー コードにディスパッチすることができます。また、ユーザー コードで指定されたデータからメッセージを作成し、送信先に配布することもできます。</span><span class="sxs-lookup"><span data-stu-id="ca589-105">It can receive messages, process them, and dispatch them to user code for further action, or it can construct messages from data given by user code and deliver them to a destination.</span></span> <span data-ttu-id="ca589-106">ここでは、メッセージを処理するためのアーキテクチャと格納されるデータについて説明します。このトピックは、上級開発者を対象としています。</span><span class="sxs-lookup"><span data-stu-id="ca589-106">This topic, which is intended for advanced developers, describes the architecture for handling messages and the contained data.</span></span> <span data-ttu-id="ca589-107">データを送受信する方法のより簡単なタスク指向の概要については、「 [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ca589-107">For a simpler, task-oriented view of how to send and receive data, see [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="ca589-108">このトピックでは、WCF のオブジェクトモデルを調べても表示されない WCF 実装の詳細について説明します。</span><span class="sxs-lookup"><span data-stu-id="ca589-108">This topic discusses WCF implementation details that are not visible by examining the WCF object model.</span></span> <span data-ttu-id="ca589-109">文書化された実装の詳細について、2 つの注意事項があります。</span><span class="sxs-lookup"><span data-stu-id="ca589-109">Two words of caution are in order with regard to documented implementation details.</span></span> <span data-ttu-id="ca589-110">1 つは、説明が簡略化されているという点です。実際の実装は、最適化やその他の理由から、より複雑であることが考えられます。</span><span class="sxs-lookup"><span data-stu-id="ca589-110">First, the descriptions are simplified; actual implementation may be more complex due to optimizations or other reasons.</span></span> <span data-ttu-id="ca589-111">もう 1 つの注意事項として、特定の実装の詳細が文書化されていても、その詳細に依存しないようにしてください。これらの詳細は、バージョン間で予告なしに変更されることがあるからです。これは、サービス リリースにおいても同様です。</span><span class="sxs-lookup"><span data-stu-id="ca589-111">Second, you should never rely on specific implementation details, even documented ones, because these may change without notice from version to version or even in a servicing release.</span></span>  
  
## <a name="basic-architecture"></a><span data-ttu-id="ca589-112">基本アーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="ca589-112">Basic Architecture</span></span>  

 <span data-ttu-id="ca589-113">WCF メッセージ処理機能の中核となるのは、 <xref:System.ServiceModel.Channels.Message> クラスです。これについては、「 [message クラスの使用](using-the-message-class.md)」で詳しく説明されています。</span><span class="sxs-lookup"><span data-stu-id="ca589-113">At the core of WCF message-handling capabilities is the <xref:System.ServiceModel.Channels.Message> class, which is described in detail in [Using the Message Class](using-the-message-class.md).</span></span> <span data-ttu-id="ca589-114">WCF のランタイムコンポーネントは、チャネルスタックとサービスフレームワークという2つの主要部分に分けることができます。 <xref:System.ServiceModel.Channels.Message> クラスは接続ポイントです。</span><span class="sxs-lookup"><span data-stu-id="ca589-114">The run-time components of WCF can be divided into two major parts: the channel stack and the service framework, with the <xref:System.ServiceModel.Channels.Message> class being the connection point.</span></span>  
  
 <span data-ttu-id="ca589-115">チャネル スタックは、有効な <xref:System.ServiceModel.Channels.Message> インスタンスと、メッセージ データの送信または受信に対応するアクションとの間の変換を行います。</span><span class="sxs-lookup"><span data-stu-id="ca589-115">The channel stack is responsible for converting between a valid <xref:System.ServiceModel.Channels.Message> instance and some action that corresponds to the sending or receiving of message data.</span></span> <span data-ttu-id="ca589-116">送信側のチャネル スタックは、有効な <xref:System.ServiceModel.Channels.Message> インスタンスを取得し、何らかの処理を行った後、メッセージの送信に論理的に対応するアクションを実行します。</span><span class="sxs-lookup"><span data-stu-id="ca589-116">On the sending side, the channel stack takes a valid <xref:System.ServiceModel.Channels.Message> instance and, after some processing, performs some action that logically corresponds to sending the message.</span></span> <span data-ttu-id="ca589-117">このアクションには、TCP パケットまたは HTTP パケットの送信、メッセージ キューへのメッセージの配置、データベースへのメッセージの書き込み、ファイル共有へのメッセージの保存、実装によって異なるその他のアクションなどがあります。</span><span class="sxs-lookup"><span data-stu-id="ca589-117">The action may be sending TCP or HTTP packets, queuing the message in Message Queuing, writing the message to a database, saving it to a file share, or any other action, depending on the implementation.</span></span> <span data-ttu-id="ca589-118">最も一般的なアクションは、ネットワーク プロトコル上でのメッセージの送信です。</span><span class="sxs-lookup"><span data-stu-id="ca589-118">The most common action is sending the message over a network protocol.</span></span> <span data-ttu-id="ca589-119">受信側では、この逆のことが行われます。つまり、アクション (TCP パケットまたは HTTP パケットの到着の場合もあれば、その他のアクションの場合もあります) が検出され、チャネル スタックが処理を行った後に、このアクションを有効な <xref:System.ServiceModel.Channels.Message> インスタンスに変換します。</span><span class="sxs-lookup"><span data-stu-id="ca589-119">On the receive side, the opposite happens—an action is detected (which may be TCP or HTTP packets arriving or any other action), and, after processing, the channel stack converts this action into a valid <xref:System.ServiceModel.Channels.Message> instance.</span></span>  
  
 <span data-ttu-id="ca589-120">WCF を使用するには、 <xref:System.ServiceModel.Channels.Message> クラスとチャネルスタックを直接使用します。</span><span class="sxs-lookup"><span data-stu-id="ca589-120">You can use WCF by using the <xref:System.ServiceModel.Channels.Message> class and the channel stack directly.</span></span> <span data-ttu-id="ca589-121">ただし、この作業は困難であり、時間もかかります。</span><span class="sxs-lookup"><span data-stu-id="ca589-121">However, doing so is difficult and time-consuming.</span></span> <span data-ttu-id="ca589-122">また、 <xref:System.ServiceModel.Channels.Message> オブジェクトはメタデータをサポートしていないため、この方法で wcf を使用する場合は、厳密に型指定された wcf クライアントを生成することはできません。</span><span class="sxs-lookup"><span data-stu-id="ca589-122">Additionally, the <xref:System.ServiceModel.Channels.Message> object provides no metadata support, so you cannot generate strongly typed WCF clients if you use WCF in this manner.</span></span>  
  
 <span data-ttu-id="ca589-123">そのため、WCF には、オブジェクトの構築と受信に使用できる使いやすいプログラミングモデルを提供するサービスフレームワークが含まれてい `Message` ます。</span><span class="sxs-lookup"><span data-stu-id="ca589-123">Therefore, WCF includes a service framework that provides an easy-to-use programming model that you can use to construct and receive `Message` objects.</span></span> <span data-ttu-id="ca589-124">サービスフレームワークは、サービスコントラクトの概念によってサービスを .NET Framework 型にマップし、属性でマークされたメソッドを単に .NET Framework するユーザー操作にメッセージをディスパッチし <xref:System.ServiceModel.OperationContractAttribute> ます (詳細については、「 [サービスコントラクトの設計](../designing-service-contracts.md)」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="ca589-124">The service framework maps services to .NET Framework types through the notion of service contracts, and dispatches messages to user operations that are simply .NET Framework methods marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute (for more details, see [Designing Service Contracts](../designing-service-contracts.md)).</span></span> <span data-ttu-id="ca589-125">これらのメソッドは、パラメーターと戻り値を持つことができます。</span><span class="sxs-lookup"><span data-stu-id="ca589-125">These methods may have parameters and return values.</span></span> <span data-ttu-id="ca589-126">サービス側では、サービス フレームワークが受信 <xref:System.ServiceModel.Channels.Message> インスタンスをパラメーターに変換し、戻り値を送信 <xref:System.ServiceModel.Channels.Message> インスタンスに変換します。</span><span class="sxs-lookup"><span data-stu-id="ca589-126">On the service side, the service framework converts incoming <xref:System.ServiceModel.Channels.Message> instances into parameters and converts return values into outgoing <xref:System.ServiceModel.Channels.Message> instances.</span></span> <span data-ttu-id="ca589-127">クライアント側では、この逆のことが行われます。</span><span class="sxs-lookup"><span data-stu-id="ca589-127">On the client side, it does the opposite.</span></span> <span data-ttu-id="ca589-128">たとえば、次のような `FindAirfare` の操作について考えてみます。</span><span class="sxs-lookup"><span data-stu-id="ca589-128">For example, consider the `FindAirfare` operation below.</span></span>  
  
 [!code-csharp[c_DataArchitecture#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#1)]
 [!code-vb[c_DataArchitecture#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#1)]  
  
 <span data-ttu-id="ca589-129">クライアントで `FindAirfare` が呼び出されたとします。</span><span class="sxs-lookup"><span data-stu-id="ca589-129">Suppose `FindAirfare` is called on the client.</span></span> <span data-ttu-id="ca589-130">クライアントのサービス フレームワークは、 `FromCity` パラメーターと `ToCity` パラメーターを送信 <xref:System.ServiceModel.Channels.Message> インスタンスに変換し、これをチャネル スタックに渡して送信します。</span><span class="sxs-lookup"><span data-stu-id="ca589-130">The service framework on the client converts the `FromCity` and `ToCity` parameters into an outgoing <xref:System.ServiceModel.Channels.Message> instance and passes it to the channel stack to be sent.</span></span>  
  
 <span data-ttu-id="ca589-131">サービス側では、チャネル スタックから <xref:System.ServiceModel.Channels.Message> インスタンスが到着すると、サービス フレームワークがメッセージから関連データを抽出して `FromCity` パラメーターと `ToCity` パラメーターを設定し、サービス側の `FindAirfare` メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="ca589-131">On the service side, when a <xref:System.ServiceModel.Channels.Message> instance arrives from the channel stack, the service framework extracts the relevant data from the message to populate the `FromCity` and `ToCity` parameters and then calls the service-side `FindAirfare` method.</span></span> <span data-ttu-id="ca589-132">メソッドから制御が戻ると、サービス フレームワークは、返された整数値と `IsDirectFlight` 出力パラメーターを取得し、この情報を格納する <xref:System.ServiceModel.Channels.Message> オブジェクトのインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="ca589-132">When the method returns, the service framework takes the returned integer value and the `IsDirectFlight` output parameter and creates a <xref:System.ServiceModel.Channels.Message> object instance that contains this information.</span></span> <span data-ttu-id="ca589-133">次に、この `Message` インスタンスをチャネル スタックに渡して、クライアントに返送します。</span><span class="sxs-lookup"><span data-stu-id="ca589-133">It then passes the `Message` instance to the channel stack to be sent back to the client.</span></span>  
  
 <span data-ttu-id="ca589-134">クライアント側では、応答メッセージが格納された <xref:System.ServiceModel.Channels.Message> インスタンスが、チャネル スタックから取り出されます。</span><span class="sxs-lookup"><span data-stu-id="ca589-134">On the client side, a <xref:System.ServiceModel.Channels.Message> instance that contains the response message emerges from the channel stack.</span></span> <span data-ttu-id="ca589-135">サービス フレームワークは、戻り値と `IsDirectFlight` 値を抽出し、これらをクライアントの呼び出し元に返します。</span><span class="sxs-lookup"><span data-stu-id="ca589-135">The service framework extracts the return value and the `IsDirectFlight` value and returns these to the caller of the client.</span></span>  
  
## <a name="message-class"></a><span data-ttu-id="ca589-136">Message クラス</span><span class="sxs-lookup"><span data-stu-id="ca589-136">Message Class</span></span>  

 <span data-ttu-id="ca589-137"><xref:System.ServiceModel.Channels.Message> クラスはメッセージの抽象表現を意図したものですが、そのデザインは SOAP メッセージと密接に関連しています。</span><span class="sxs-lookup"><span data-stu-id="ca589-137">The <xref:System.ServiceModel.Channels.Message> class is intended to be an abstract representation of a message, but its design is strongly tied to the SOAP message.</span></span> <span data-ttu-id="ca589-138"><xref:System.ServiceModel.Channels.Message> には、情報の 3 つの主要部分であるメッセージ本文、メッセージ ヘッダー、およびメッセージ プロパティが含まれます。</span><span class="sxs-lookup"><span data-stu-id="ca589-138">A <xref:System.ServiceModel.Channels.Message> contains three major pieces of information: a message body, message headers, and message properties.</span></span>  
  
## <a name="message-body"></a><span data-ttu-id="ca589-139">メッセージ本文</span><span class="sxs-lookup"><span data-stu-id="ca589-139">Message Body</span></span>  

 <span data-ttu-id="ca589-140">メッセージ本文は、メッセージの実際のデータ ペイロードを表すためのものです。</span><span class="sxs-lookup"><span data-stu-id="ca589-140">The message body is intended to represent the actual data payload of the message.</span></span> <span data-ttu-id="ca589-141">メッセージ本文は、常に XML Infoset として表されます。</span><span class="sxs-lookup"><span data-stu-id="ca589-141">The message body is always represented as an XML Infoset.</span></span> <span data-ttu-id="ca589-142">これは、WCF で作成または受信されるすべてのメッセージが XML 形式でなければならないという意味ではありません。</span><span class="sxs-lookup"><span data-stu-id="ca589-142">This does not mean that all messages created or received in WCF must be in XML format.</span></span> <span data-ttu-id="ca589-143">メッセージ本文を解釈する方法を決定するのはチャネル スタックです。</span><span class="sxs-lookup"><span data-stu-id="ca589-143">It is up to the channel stack to decide how to interpret the message body.</span></span> <span data-ttu-id="ca589-144">チャネル スタックは、メッセージ本文を XML として出力する場合もあれば、他の形式に変換する場合もあります。また、メッセージ本文を完全に除外する場合もあります。</span><span class="sxs-lookup"><span data-stu-id="ca589-144">It may emit it as XML, convert it to some other format, or even omit it entirely.</span></span> <span data-ttu-id="ca589-145">もちろん、ほとんどのバインド WCF では、メッセージ本文は SOAP エンベロープの body セクションで XML コンテンツとして表されます。</span><span class="sxs-lookup"><span data-stu-id="ca589-145">Of course, with most of the bindings WCF supplies, the message body is represented as XML content in the body section of a SOAP envelope.</span></span>  
  
 <span data-ttu-id="ca589-146">`Message` クラスは、本文を表す XML データを保持するバッファーを必ずしも含むわけではないことを認識しておくことが重要です。</span><span class="sxs-lookup"><span data-stu-id="ca589-146">It is important to realize that the `Message` class does not necessarily contain a buffer with XML data representing the body.</span></span> <span data-ttu-id="ca589-147">`Message` には XML Infoset が論理的に含まれますが、この Infoset は動的に構築可能であると同時に、メモリ内に物理的に存在することはありません。</span><span class="sxs-lookup"><span data-stu-id="ca589-147">Logically, `Message` contains an XML Infoset, but this Infoset may be dynamically constructed and may never physically exist in memory.</span></span>  
  
### <a name="putting-data-into-the-message-body"></a><span data-ttu-id="ca589-148">メッセージ本文へのデータの配置</span><span class="sxs-lookup"><span data-stu-id="ca589-148">Putting Data into the Message Body</span></span>  

 <span data-ttu-id="ca589-149">メッセージ本文にデータを配置するための統一された機構はありません。</span><span class="sxs-lookup"><span data-stu-id="ca589-149">There is no uniform mechanism to put data into a message body.</span></span> <span data-ttu-id="ca589-150"><xref:System.ServiceModel.Channels.Message> クラスには、抽象メソッド <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>があります。このメソッドは、 <xref:System.Xml.XmlDictionaryWriter>を取得します。</span><span class="sxs-lookup"><span data-stu-id="ca589-150">The <xref:System.ServiceModel.Channels.Message> class has an abstract method, <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, which takes an <xref:System.Xml.XmlDictionaryWriter>.</span></span> <span data-ttu-id="ca589-151"><xref:System.ServiceModel.Channels.Message> クラスの各サブクラスは、このメソッドをオーバーライドし、独自のコンテンツを書き込む必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca589-151">Each subclass of the <xref:System.ServiceModel.Channels.Message> class is responsible for overriding this method and writing out its own contents.</span></span> <span data-ttu-id="ca589-152">メッセージ本文には、 `OnWriteBodyContent` によって生成された XML Infoset が論理的に含まれます。</span><span class="sxs-lookup"><span data-stu-id="ca589-152">The message body logically contains the XML Infoset that `OnWriteBodyContent` produces.</span></span> <span data-ttu-id="ca589-153">たとえば、次のような `Message` サブクラスについて考えてみます。</span><span class="sxs-lookup"><span data-stu-id="ca589-153">For example, consider the following `Message` subclass.</span></span>  
  
 [!code-csharp[c_DataArchitecture#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#2)]
 [!code-vb[c_DataArchitecture#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#2)]  
  
 <span data-ttu-id="ca589-154">物理的には、 `AirfareRequestMessage` インスタンスには 2 つの文字列 ("fromCity" と "toCity") しか含まれていません。</span><span class="sxs-lookup"><span data-stu-id="ca589-154">Physically, an `AirfareRequestMessage` instance contains only two strings ("fromCity" and "toCity").</span></span> <span data-ttu-id="ca589-155">ただし、このメッセージには、次のような XML Infoset が論理的に含まれています。</span><span class="sxs-lookup"><span data-stu-id="ca589-155">However, logically the message contains the following XML infoset:</span></span>  
  
```xml  
<airfareRequest>  
    <from>Tokyo</from>  
    <to>London</to>  
</airfareRequest>  
```  
  
 <span data-ttu-id="ca589-156">もちろん、このようにメッセージを作成することは、通常はありません。上記のようなメッセージは、サービス フレームワークを使用して、操作コントラクト パラメーターから作成できるためです。</span><span class="sxs-lookup"><span data-stu-id="ca589-156">Of course, you would normally not create messages in this manner, because you can use the service framework to create a message like the preceding one from operation contract parameters.</span></span> <span data-ttu-id="ca589-157">さらに、 <xref:System.ServiceModel.Channels.Message> クラスには、静的 `CreateMessage` メソッドもあります。このメソッドを使用すると、一般的な種類の内容を含むメッセージ (空のメッセージ、 <xref:System.Runtime.Serialization.DataContractSerializer>によって XML にシリアル化されたオブジェクトを含むメッセージ、SOAP エラーを含むメッセージ、 <xref:System.Xml.XmlReader>によって表された XML を含むメッセージなど) を作成できます。</span><span class="sxs-lookup"><span data-stu-id="ca589-157">Additionally, the <xref:System.ServiceModel.Channels.Message> class has static `CreateMessage` methods that you can use to create messages with common types of content: an empty message, a message that contains an object serialized to XML with the <xref:System.Runtime.Serialization.DataContractSerializer>, a message that contains a SOAP fault, a message that contains XML represented by an <xref:System.Xml.XmlReader>, and so on.</span></span>  
  
### <a name="getting-data-from-a-message-body"></a><span data-ttu-id="ca589-158">メッセージ本文からのデータの取得</span><span class="sxs-lookup"><span data-stu-id="ca589-158">Getting Data from a Message Body</span></span>  

 <span data-ttu-id="ca589-159">メッセージ本文に格納されたデータは、主に次の 2 とおりの方法で抽出できます。</span><span class="sxs-lookup"><span data-stu-id="ca589-159">You can extract the data stored in a message body in two main ways:</span></span>  
  
- <span data-ttu-id="ca589-160"><xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> メソッドを呼び出し、XML ライターに渡すことにより、メッセージ本文全体を一度に取得できます。</span><span class="sxs-lookup"><span data-stu-id="ca589-160">You can get the entire message body at one time by calling the <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> method and passing in an XML writer.</span></span> <span data-ttu-id="ca589-161">メッセージ本文全体がこのライターに書き込まれます。</span><span class="sxs-lookup"><span data-stu-id="ca589-161">The complete message body is written out to this writer.</span></span> <span data-ttu-id="ca589-162">メッセージ本文全体を一度に取得することを、 *メッセージの書き込み* とも呼びます。</span><span class="sxs-lookup"><span data-stu-id="ca589-162">Getting the entire message body at one time is also called *writing a message*.</span></span> <span data-ttu-id="ca589-163">書き込みは、メッセージの送信時に主にチャネル スタックによって実行されます。チャネル スタックには、通常、メッセージ本文全体にアクセスし、本文全体をエンコードして送信する部分があります。</span><span class="sxs-lookup"><span data-stu-id="ca589-163">Writing is done primarily by the channel stack when sending messages—some part of the channel stack will usually get access to the entire message body, encode it, and send it.</span></span>  
  
- <span data-ttu-id="ca589-164">メッセージ本文から情報を取得するもう 1 つの方法は、 <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> を呼び出し、XML リーダーを取得する方法です。</span><span class="sxs-lookup"><span data-stu-id="ca589-164">Another way to get information out of the message body is to call <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> and get an XML reader.</span></span> <span data-ttu-id="ca589-165">リーダーでメソッドを呼び出すことにより、必要に応じてメッセージ本文に順次アクセスできます。</span><span class="sxs-lookup"><span data-stu-id="ca589-165">The message body can then be accessed sequentially as needed by calling methods on the reader.</span></span> <span data-ttu-id="ca589-166">メッセージ本文を少しずつ取得することを、 *メッセージの読み取り* とも呼びます。</span><span class="sxs-lookup"><span data-stu-id="ca589-166">Getting the message body piece-by-piece is also called *reading a message*.</span></span> <span data-ttu-id="ca589-167">メッセージの読み取りは、メッセージの受信時にサービス フレームワークによって主に使用されます。</span><span class="sxs-lookup"><span data-stu-id="ca589-167">Reading the message is primarily used by the service framework when receiving messages.</span></span> <span data-ttu-id="ca589-168">たとえば、 <xref:System.Runtime.Serialization.DataContractSerializer> の使用時に、サービス フレームワークは本文で XML リーダーを取得し、逆シリアル化エンジンに渡します。逆シリアル化エンジンは、要素単位でメッセージを読み取り、対応するオブジェクト グラフの構築を開始します。</span><span class="sxs-lookup"><span data-stu-id="ca589-168">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> is in use, the service framework will get an XML reader over the body and pass it to the deserialization engine, which will then start reading the message element-by-element and constructing the corresponding object graph.</span></span>  
  
 <span data-ttu-id="ca589-169">メッセージ本文を取得できるのは一度だけです。</span><span class="sxs-lookup"><span data-stu-id="ca589-169">A message body can be retrieved only once.</span></span> <span data-ttu-id="ca589-170">これにより、転送専用ストリームを使用することが可能になります。</span><span class="sxs-lookup"><span data-stu-id="ca589-170">This makes it possible to work with forward-only streams.</span></span> <span data-ttu-id="ca589-171">たとえば、 <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> から読み取り、XML Infoset として結果を返す <xref:System.IO.FileStream> のオーバーライドを作成できます。</span><span class="sxs-lookup"><span data-stu-id="ca589-171">For example, you can write an <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> override that reads from a <xref:System.IO.FileStream> and returns the results as an XML Infoset.</span></span> <span data-ttu-id="ca589-172">ファイルの先頭まで "巻き戻す" 必要はありません。</span><span class="sxs-lookup"><span data-stu-id="ca589-172">You will never need to "rewind" to the beginning of the file.</span></span>  
  
 <span data-ttu-id="ca589-173">`WriteBodyContents` メソッドと `GetReaderAtBodyContents` メソッドは、メッセージ本文がこれまで一度も取得されていないことを簡単にチェックした後、それぞれ `OnWriteBodyContents` と `OnGetReaderAtBodyContents`を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="ca589-173">The `WriteBodyContents` and `GetReaderAtBodyContents` methods simply check that the message body has never been retrieved before, and then call `OnWriteBodyContents` or `OnGetReaderAtBodyContents`, respectively.</span></span>  
  
## <a name="message-usage-in-wcf"></a><span data-ttu-id="ca589-174">WCF でのメッセージの使用</span><span class="sxs-lookup"><span data-stu-id="ca589-174">Message Usage in WCF</span></span>  

 <span data-ttu-id="ca589-175">ほとんどのメッセージは、 *送信* (チャネル スタックによって送信するために、サービス フレームワークが作成するメッセージ) または *受信* (チャネル スタックから到着し、サービス フレームワークが解釈するメッセージ) のいずれかに分類できます。</span><span class="sxs-lookup"><span data-stu-id="ca589-175">Most messages can be classified as either *outgoing* (those that are created by the service framework to be sent by the channel stack) or *incoming* (those that arrive from the channel stack and are interpreted by the service framework).</span></span> <span data-ttu-id="ca589-176">さらに、チャネル スタックは、バッファー モードまたはストリーミング モードで動作できます。</span><span class="sxs-lookup"><span data-stu-id="ca589-176">Furthermore, the channel stack can operate in either buffered or streaming mode.</span></span> <span data-ttu-id="ca589-177">また、サービス フレームワークが、ストリーム プログラミング モデルを公開する場合もあれば、非ストリーム プログラミング モデルを公開する場合もあります。</span><span class="sxs-lookup"><span data-stu-id="ca589-177">The service framework may also expose a streamed or nonstreamed programming model.</span></span> <span data-ttu-id="ca589-178">この結果として生じるケースと、その実装の簡略化した詳細を次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="ca589-178">This leads to the cases listed in the following table, along with simplified details of their implementation.</span></span>  
  
|<span data-ttu-id="ca589-179">メッセージの種類</span><span class="sxs-lookup"><span data-stu-id="ca589-179">Message type</span></span>|<span data-ttu-id="ca589-180">メッセージの本文データ</span><span class="sxs-lookup"><span data-stu-id="ca589-180">Body data in message</span></span>|<span data-ttu-id="ca589-181">書き込み (OnWriteBodyContents) 実装</span><span class="sxs-lookup"><span data-stu-id="ca589-181">Write (OnWriteBodyContents) implementation</span></span>|<span data-ttu-id="ca589-182">読み取り (OnGetReaderAtBodyContents) 実装</span><span class="sxs-lookup"><span data-stu-id="ca589-182">Read (OnGetReaderAtBodyContents) Implementation</span></span>|  
|------------------|--------------------------|--------------------------------------------------|-------------------------------------------------------|  
|<span data-ttu-id="ca589-183">送信 (非ストリーム プログラミング モデルから作成)</span><span class="sxs-lookup"><span data-stu-id="ca589-183">Outgoing, created from nonstreamed programming model</span></span>|<span data-ttu-id="ca589-184">メッセージの書き込みに必要なデータ (例 : オブジェクトとそのシリアル化に必要な <xref:System.Runtime.Serialization.DataContractSerializer> インスタンス)\*</span><span class="sxs-lookup"><span data-stu-id="ca589-184">The data needed to write the message (for example, an object and the <xref:System.Runtime.Serialization.DataContractSerializer> instance needed to serialize it)\*</span></span>|<span data-ttu-id="ca589-185">格納されたデータに基づいてメッセージを書き込むためのカスタム ロジック (例 : `WriteObject` を使用している場合に、このシリアライザーで `DataContractSerializer` を呼び出す)\*</span><span class="sxs-lookup"><span data-stu-id="ca589-185">Custom logic to write out the message based on the stored data (for example, call `WriteObject` on the `DataContractSerializer` if that is the serializer in use)\*</span></span>|<span data-ttu-id="ca589-186">`OnWriteBodyContents`を呼び出し、結果をバッファーに保持し、バッファーで XML リーダーを返します。</span><span class="sxs-lookup"><span data-stu-id="ca589-186">Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer</span></span>|  
|<span data-ttu-id="ca589-187">送信 (ストリーム プログラミング モデルから作成)</span><span class="sxs-lookup"><span data-stu-id="ca589-187">Outgoing, created from streamed programming model</span></span>|<span data-ttu-id="ca589-188">書き込むデータを含む `Stream` \*</span><span class="sxs-lookup"><span data-stu-id="ca589-188">The `Stream` with the data to be written\*</span></span>|<span data-ttu-id="ca589-189"><xref:System.Xml.IStreamProvider> 機構を使用して、格納されたストリームからデータを書き込みます\*。</span><span class="sxs-lookup"><span data-stu-id="ca589-189">Write out data from the stored stream using the <xref:System.Xml.IStreamProvider> mechanism\*</span></span>|<span data-ttu-id="ca589-190">`OnWriteBodyContents`を呼び出し、結果をバッファーに保持し、バッファーで XML リーダーを返します。</span><span class="sxs-lookup"><span data-stu-id="ca589-190">Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer</span></span>|  
|<span data-ttu-id="ca589-191">ストリーミング チャネル スタックからの受信</span><span class="sxs-lookup"><span data-stu-id="ca589-191">Incoming from streaming channel stack</span></span>|<span data-ttu-id="ca589-192">ネットワーク上で到着したデータを表す `Stream` オブジェクトと、このオブジェクトに配置された <xref:System.Xml.XmlReader></span><span class="sxs-lookup"><span data-stu-id="ca589-192">A `Stream` object that represents the data coming in over the network with an <xref:System.Xml.XmlReader> over it</span></span>|<span data-ttu-id="ca589-193">`XmlReader` を使用して、格納された `WriteNode`からコンテンツを書き込みます。</span><span class="sxs-lookup"><span data-stu-id="ca589-193">Write out the contents from the stored `XmlReader` using `WriteNode`</span></span>|<span data-ttu-id="ca589-194">格納された `XmlReader`を返します。</span><span class="sxs-lookup"><span data-stu-id="ca589-194">Returns the stored `XmlReader`</span></span>|  
|<span data-ttu-id="ca589-195">非ストリーミング チャネル スタックからの受信</span><span class="sxs-lookup"><span data-stu-id="ca589-195">Incoming from nonstreaming channel stack</span></span>|<span data-ttu-id="ca589-196">本文データを格納するバッファーと、このバッファーに配置された `XmlReader`</span><span class="sxs-lookup"><span data-stu-id="ca589-196">A buffer that contains body data with an `XmlReader` over it</span></span>|<span data-ttu-id="ca589-197">`XmlReader` を使用して、格納された `WriteNode`からコンテンツを書き込みます。</span><span class="sxs-lookup"><span data-stu-id="ca589-197">Writes out the contents from the stored `XmlReader` using `WriteNode`</span></span>|<span data-ttu-id="ca589-198">格納された lang を返します。</span><span class="sxs-lookup"><span data-stu-id="ca589-198">Returns the stored lang</span></span>|  
  
 <span data-ttu-id="ca589-199">\* これらの項目は、サブクラスに直接実装されるのではなく、 `Message` クラスのサブクラスにあり <xref:System.ServiceModel.Channels.BodyWriter> ます。</span><span class="sxs-lookup"><span data-stu-id="ca589-199">\* These items are not implemented directly in `Message` subclasses, but in subclasses of the <xref:System.ServiceModel.Channels.BodyWriter> class.</span></span> <span data-ttu-id="ca589-200">の詳細については <xref:System.ServiceModel.Channels.BodyWriter> 、「 [Message クラスの使用](using-the-message-class.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ca589-200">For more information about the <xref:System.ServiceModel.Channels.BodyWriter>, see [Using the Message Class](using-the-message-class.md).</span></span>  
  
## <a name="message-headers"></a><span data-ttu-id="ca589-201">メッセージ ヘッダー</span><span class="sxs-lookup"><span data-stu-id="ca589-201">Message Headers</span></span>  

 <span data-ttu-id="ca589-202">メッセージには、ヘッダーを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="ca589-202">A message may contain headers.</span></span> <span data-ttu-id="ca589-203">ヘッダーは、名前、名前空間、および他の複数のプロパティに関連付けられた XML Infoset で論理的に構成されます。</span><span class="sxs-lookup"><span data-stu-id="ca589-203">A header logically consists of an XML Infoset that is associated with a name, a namespace, and a few other properties.</span></span> <span data-ttu-id="ca589-204">メッセージ ヘッダーには、 `Headers` の <xref:System.ServiceModel.Channels.Message>プロパティを使用してアクセスします。</span><span class="sxs-lookup"><span data-stu-id="ca589-204">Message headers are accessed using the `Headers` property on <xref:System.ServiceModel.Channels.Message>.</span></span> <span data-ttu-id="ca589-205">各ヘッダーは、 <xref:System.ServiceModel.Channels.MessageHeader> クラスによって表されます。</span><span class="sxs-lookup"><span data-stu-id="ca589-205">Each header is represented by a <xref:System.ServiceModel.Channels.MessageHeader> class.</span></span> <span data-ttu-id="ca589-206">通常、SOAP メッセージを使用するように構成されたチャネル スタックを使用している場合、メッセージ ヘッダーは SOAP メッセージ ヘッダーにマップされます。</span><span class="sxs-lookup"><span data-stu-id="ca589-206">Normally, message headers are mapped to SOAP message headers when using a channel stack configured to work with SOAP messages.</span></span>  
  
 <span data-ttu-id="ca589-207">メッセージ ヘッダーへの情報の配置と、メッセージ ヘッダーからの情報の抽出は、メッセージ本文を使用する場合と似ています。</span><span class="sxs-lookup"><span data-stu-id="ca589-207">Putting information into a message header and extracting information from it is similar to using the message body.</span></span> <span data-ttu-id="ca589-208">ストリーミングがサポートされていないため、プロセスは若干簡略化されます。</span><span class="sxs-lookup"><span data-stu-id="ca589-208">The process is somewhat simplified because streaming is not supported.</span></span> <span data-ttu-id="ca589-209">ヘッダーは常に強制的にバッファーに保持されるため、同じヘッダーの内容に何度もアクセスすることが可能であり、各ヘッダーに任意の順序でアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="ca589-209">It is possible to access the contents of the same header more than once, and headers can be accessed in arbitrary order, forcing headers to always be buffered.</span></span> <span data-ttu-id="ca589-210">ヘッダーで XML リーダーを取得するために使用できる汎用の機構はありませんが、 `MessageHeader` このような機能を備えた読み取り可能なヘッダーを表す、WCF の内部のサブクラスがあります。</span><span class="sxs-lookup"><span data-stu-id="ca589-210">There is no general-purpose mechanism available to get an XML reader over a header, but there is a `MessageHeader` subclass internal to WCF that represents a readable header with such a capability.</span></span> <span data-ttu-id="ca589-211">この種の `MessageHeader` は、カスタム アプリケーション ヘッダーを持つメッセージが到着したときにチャネル スタックによって作成されます。</span><span class="sxs-lookup"><span data-stu-id="ca589-211">This type of `MessageHeader` is created by the channel stack when a message with custom application headers comes in.</span></span> <span data-ttu-id="ca589-212">これにより、サービス フレームワークは、逆シリアル化エンジン ( <xref:System.Runtime.Serialization.DataContractSerializer>など) を使用してこれらのヘッダーを解釈できます。</span><span class="sxs-lookup"><span data-stu-id="ca589-212">This enables the service framework to use a deserialization engine, such as the <xref:System.Runtime.Serialization.DataContractSerializer>, to interpret these headers.</span></span>  
  
 <span data-ttu-id="ca589-213">詳細については、「 [Message クラスの使用](using-the-message-class.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ca589-213">For more information, see [Using the Message Class](using-the-message-class.md).</span></span>  
  
## <a name="message-properties"></a><span data-ttu-id="ca589-214">メッセージ プロパティ</span><span class="sxs-lookup"><span data-stu-id="ca589-214">Message Properties</span></span>  

 <span data-ttu-id="ca589-215">メッセージには、プロパティを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="ca589-215">A message may contain properties.</span></span> <span data-ttu-id="ca589-216">*プロパティ* は、文字列名に関連付けられている任意の .NET Framework オブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="ca589-216">A *property* is any .NET Framework object that is associated with a string name.</span></span> <span data-ttu-id="ca589-217">プロパティには、 `Properties` の `Message`プロパティからアクセスします。</span><span class="sxs-lookup"><span data-stu-id="ca589-217">Properties are accessed through the `Properties` property on `Message`.</span></span>  
  
 <span data-ttu-id="ca589-218">通常、メッセージ本文とメッセージ ヘッダーは、それぞれ SOAP 本文および SOAP ヘッダーにマップされますが、メッセージ プロパティがメッセージと共に送信または受信されることは通常ありません。</span><span class="sxs-lookup"><span data-stu-id="ca589-218">Unlike the message body and message headers (which normally map to the SOAP body and SOAP headers, respectively), message properties are normally not sent or received along with the messages.</span></span> <span data-ttu-id="ca589-219">メッセージ プロパティは、チャネル スタック内のさまざまなチャネル間、およびチャネル スタックとサービス モデルの間で、メッセージに関するデータを渡す通信機構として主に存在します。</span><span class="sxs-lookup"><span data-stu-id="ca589-219">Message properties exist primarily as a communication mechanism to pass data about the message between the various channels in the channel stack, and between the channel stack and the service model.</span></span>  
  
 <span data-ttu-id="ca589-220">たとえば、WCF の一部として含まれる HTTP トランスポートチャネルは、クライアントに応答を送信するときに、"404 (見つかりません)" や "500 (内部サーバーエラー)" などのさまざまな HTTP ステータスコードを生成することができます。</span><span class="sxs-lookup"><span data-stu-id="ca589-220">For example, the HTTP transport channel included as part of WCF is capable of producing various HTTP status codes, such as "404 (Not Found)" and "500 (Internal Server Error)," when it sends replies to clients.</span></span> <span data-ttu-id="ca589-221">応答メッセージを送信する前に、 `Properties` のに `Message` 型のオブジェクトを含む "httpresponse.cache" というプロパティが含まれているかどうかを確認し <xref:System.ServiceModel.Channels.HttpResponseMessageProperty> ます。</span><span class="sxs-lookup"><span data-stu-id="ca589-221">Before sending a reply message, it checks to see whether the `Properties` of the `Message` contain a property called "httpResponse" that contains an object of type <xref:System.ServiceModel.Channels.HttpResponseMessageProperty>.</span></span> <span data-ttu-id="ca589-222">このようなプロパティが見つかった場合、 <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> プロパティを調べ、そのステータス コードを使用します。</span><span class="sxs-lookup"><span data-stu-id="ca589-222">If such a property is found, it will look at the <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> property and use that status code.</span></span> <span data-ttu-id="ca589-223">該当のプロパティが見つからなかった場合は、既定の "200 (OK)" コードが使用されます。</span><span class="sxs-lookup"><span data-stu-id="ca589-223">If it is not found, the default "200 (OK)" code is used.</span></span>  
  
 <span data-ttu-id="ca589-224">詳細については、「 [Message クラスの使用](using-the-message-class.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ca589-224">For more information, see [Using the Message Class](using-the-message-class.md).</span></span>  
  
### <a name="the-message-as-a-whole"></a><span data-ttu-id="ca589-225">メッセージ全体</span><span class="sxs-lookup"><span data-stu-id="ca589-225">The Message as a Whole</span></span>  

 <span data-ttu-id="ca589-226">これまで、メッセージのさまざまな部分に個別にアクセスするためのメソッドについて説明してきましたが、</span><span class="sxs-lookup"><span data-stu-id="ca589-226">So far, we have discussed methods for accessing the various parts of the message in isolation.</span></span> <span data-ttu-id="ca589-227"><xref:System.ServiceModel.Channels.Message> クラスには、メッセージ全体を使用するためのメソッドも用意されています。</span><span class="sxs-lookup"><span data-stu-id="ca589-227">However, the <xref:System.ServiceModel.Channels.Message> class also provides methods to work with the entire message as a whole.</span></span> <span data-ttu-id="ca589-228">たとえば、 `WriteMessage` メソッドは、メッセージ全体を XML ライターに書き込みます。</span><span class="sxs-lookup"><span data-stu-id="ca589-228">For example, the `WriteMessage` method writes out the entire message to an XML writer.</span></span>  
  
 <span data-ttu-id="ca589-229">これを可能にするには、 `Message` インスタンス全体と XML Infoset 間のマッピングが定義されている必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca589-229">For this to be possible, a mapping must be defined between the entire `Message` instance and an XML Infoset.</span></span> <span data-ttu-id="ca589-230">実際には、このようなマッピングが存在します。 WCF は SOAP 標準を使用して、このマッピングを定義します。</span><span class="sxs-lookup"><span data-stu-id="ca589-230">Such a mapping, in fact, exists: WCF uses the SOAP standard to define this mapping.</span></span> <span data-ttu-id="ca589-231">`Message` インスタンスが XML Infoset として書き込まれると、書き込まれた Infoset はメッセージを含む有効な SOAP エンベロープになります。</span><span class="sxs-lookup"><span data-stu-id="ca589-231">When a `Message` instance is written out as an XML Infoset, the resulting Infoset is the valid SOAP envelope that contains the message.</span></span> <span data-ttu-id="ca589-232">したがって、通常、 `WriteMessage` は次の手順を実行します。</span><span class="sxs-lookup"><span data-stu-id="ca589-232">Thus, `WriteMessage` would normally perform the following steps:</span></span>  
  
1. <span data-ttu-id="ca589-233">SOAP エンベロープ要素の開始タグを書き込みます。</span><span class="sxs-lookup"><span data-stu-id="ca589-233">Write the SOAP envelope element opening tag.</span></span>  
  
2. <span data-ttu-id="ca589-234">SOAP ヘッダー要素の開始タグを書き込み、すべてのヘッダーを書き込んで、ヘッダー要素を閉じます。</span><span class="sxs-lookup"><span data-stu-id="ca589-234">Write the SOAP header element opening tag, write out all of the headers, and close the header element.</span></span>  
  
3. <span data-ttu-id="ca589-235">SOAP 本文要素の開始タグを書き込みます。</span><span class="sxs-lookup"><span data-stu-id="ca589-235">Write the SOAP body element opening tag.</span></span>  
  
4. <span data-ttu-id="ca589-236">`WriteBodyContents` または同等のメソッドを呼び出して、本文を書き込みます。</span><span class="sxs-lookup"><span data-stu-id="ca589-236">Call `WriteBodyContents` or an equivalent method to write out the body.</span></span>  
  
5. <span data-ttu-id="ca589-237">本文要素とエンベロープ要素を閉じます。</span><span class="sxs-lookup"><span data-stu-id="ca589-237">Close the body and envelope elements.</span></span>  
  
 <span data-ttu-id="ca589-238">上記の手順は、SOAP 標準に密接に関連しています。</span><span class="sxs-lookup"><span data-stu-id="ca589-238">The preceding steps are closely tied to the SOAP standard.</span></span> <span data-ttu-id="ca589-239">これは、SOAP の複数のバージョンが存在することで複雑になります。たとえば、使用している SOAP のバージョンがわからなければ、SOAP エンベロープ要素を正しく書き込むことはできません。</span><span class="sxs-lookup"><span data-stu-id="ca589-239">This is complicated by the fact that multiple versions of SOAP exist, for example, it is impossible to write out the SOAP envelope element correctly without knowing the SOAP version in use.</span></span> <span data-ttu-id="ca589-240">また、SOAP 固有のこの複雑なマッピングを完全に無効にすることが望ましい場合もあります。</span><span class="sxs-lookup"><span data-stu-id="ca589-240">Also, in some cases, it may be desirable to turn off this complex SOAP-specific mapping completely.</span></span>  
  
 <span data-ttu-id="ca589-241">このため、 `Version` には `Message`プロパティが用意されています。</span><span class="sxs-lookup"><span data-stu-id="ca589-241">For these purposes, a `Version` property is provided on `Message`.</span></span> <span data-ttu-id="ca589-242">このプロパティをメッセージの書き込み時に使用する SOAP バージョンに設定できます。また、 `None` に設定することで、SOAP 固有のマッピングを使用しないようにすることもできます。</span><span class="sxs-lookup"><span data-stu-id="ca589-242">It can be set to the SOAP version to use when writing out the message, or it can be set to `None` to prevent any SOAP-specific mappings.</span></span> <span data-ttu-id="ca589-243">`Version` プロパティを `None`に設定すると、メッセージ全体を使用するメソッドは、メッセージが本文だけで構成されている場合と同様に機能します。たとえば、 `WriteMessage` は前述の複数の手順を実行するのではなく、 `WriteBodyContents` を呼び出すだけです。</span><span class="sxs-lookup"><span data-stu-id="ca589-243">If the `Version` property is set to `None`, methods that work with the entire message act as if the message consisted of its body only, for example, `WriteMessage` would simply call `WriteBodyContents` instead of performing the multiple steps listed above.</span></span> <span data-ttu-id="ca589-244">受信メッセージでは、 `Version` が自動検出され、適切に設定されることが求められます。</span><span class="sxs-lookup"><span data-stu-id="ca589-244">It is expected that on incoming messages, `Version` will be auto-detected and set correctly.</span></span>  
  
## <a name="the-channel-stack"></a><span data-ttu-id="ca589-245">チャネル スタック</span><span class="sxs-lookup"><span data-stu-id="ca589-245">The Channel Stack</span></span>  
  
### <a name="channels"></a><span data-ttu-id="ca589-246">チャネル</span><span class="sxs-lookup"><span data-stu-id="ca589-246">Channels</span></span>  

 <span data-ttu-id="ca589-247">既に説明したように、チャネル スタックは、送信 <xref:System.ServiceModel.Channels.Message> インスタンスをアクション (ネットワーク上でのパケットの送信など) に変換したり、アクション (ネットワーク パケットの受信など) を受信 `Message` インスタンスに変換したりする役割を担います。</span><span class="sxs-lookup"><span data-stu-id="ca589-247">As stated before, the channel stack is responsible for converting outgoing <xref:System.ServiceModel.Channels.Message> instances into some action (such as sending packets over the network), or converting some action (such as receiving network packets) into incoming `Message` instances.</span></span>  
  
 <span data-ttu-id="ca589-248">チャネル スタックは、一連の順序付けられた 1 つ以上のチャネルで構成されます。</span><span class="sxs-lookup"><span data-stu-id="ca589-248">The channel stack is composed of one or more channels ordered in a sequence.</span></span> <span data-ttu-id="ca589-249">送信 `Message` インスタンスは、スタック内の最初のチャネル ( *"最上位チャネル"* とも呼ばれます) に渡され、このチャネルからスタック内の 1 つ下のチャネルに渡されます。以降、同様にスタック内の 1 つ下のチャネルに順次渡されていきます。</span><span class="sxs-lookup"><span data-stu-id="ca589-249">An outgoing `Message` instance is passed to the first channel in the stack (also called the *topmost channel*), which passes it to the next channel down in stack, and so on.</span></span> <span data-ttu-id="ca589-250">メッセージは、 *"トランスポート チャネル"* と呼ばれる最後のチャネルで終了します。</span><span class="sxs-lookup"><span data-stu-id="ca589-250">The message terminates in the last channel, which is called the *transport channel*.</span></span> <span data-ttu-id="ca589-251">受信メッセージはトランスポート チャネルから始まり、スタック内の下位のチャネルから上位のチャネルに順次渡されていきます。</span><span class="sxs-lookup"><span data-stu-id="ca589-251">Incoming messages originate in the transport channel and are passed from channel to channel up the stack.</span></span> <span data-ttu-id="ca589-252">通常、メッセージは最上位チャネルからサービス フレームワークに渡されます。</span><span class="sxs-lookup"><span data-stu-id="ca589-252">From the topmost channel, the message is usually passed into the service framework.</span></span> <span data-ttu-id="ca589-253">これは、アプリケーション メッセージの通常のパターンですが、若干動作が異なるチャネルもあります。たとえば、上のチャネルからメッセージが渡されることなく、独自のインフラストラクチャ メッセージを送信する場合があります。</span><span class="sxs-lookup"><span data-stu-id="ca589-253">While this is the usual pattern for application messages, some channels may work slightly differently, for example, they may send their own infrastructure messages without being passed a message from a channel above.</span></span>  
  
 <span data-ttu-id="ca589-254">メッセージがスタックを通過するときに、チャネルではさまざまな方法でメッセージを処理できます。</span><span class="sxs-lookup"><span data-stu-id="ca589-254">Channels may operate on the message in various ways as it passes through the stack.</span></span> <span data-ttu-id="ca589-255">最も一般的な処理は、送信メッセージにヘッダーを追加し、受信メッセージのヘッダーを読み取ることです。</span><span class="sxs-lookup"><span data-stu-id="ca589-255">The most common operation is adding a header to an outgoing message and reading headers on an incoming message.</span></span> <span data-ttu-id="ca589-256">たとえば、チャネルでメッセージのデジタル署名を計算し、ヘッダーとして追加できます。</span><span class="sxs-lookup"><span data-stu-id="ca589-256">For example, a channel may compute the digital signature of a message and add it as a header.</span></span> <span data-ttu-id="ca589-257">また、受信メッセージのこのデジタル署名ヘッダーを検査し、有効な署名のないメッセージがチャネル スタック内の上位のチャネルに渡されないようにブロックすることもできます。</span><span class="sxs-lookup"><span data-stu-id="ca589-257">A channel may also inspect this digital signature header on incoming messages and block messages that do not have a valid signature from making their way up the channel stack.</span></span> <span data-ttu-id="ca589-258">多くの場合、チャネルはメッセージ プロパティの設定や検査も行います。</span><span class="sxs-lookup"><span data-stu-id="ca589-258">Channels also often set or inspect message properties.</span></span> <span data-ttu-id="ca589-259">通常、メッセージ本文は変更されませんが、これは許可されますが、たとえば、WCF セキュリティチャネルはメッセージ本文を暗号化できます。</span><span class="sxs-lookup"><span data-stu-id="ca589-259">The message body is usually not modified, although this is allowed, for example, the WCF security channel can encrypt the message body.</span></span>  
  
### <a name="transport-channels-and-message-encoders"></a><span data-ttu-id="ca589-260">トランスポート チャネルとメッセージ エンコーダー</span><span class="sxs-lookup"><span data-stu-id="ca589-260">Transport Channels and Message Encoders</span></span>  

 <span data-ttu-id="ca589-261">他のチャネルによって変更された送信 <xref:System.ServiceModel.Channels.Message>を実際に何らかのアクションに変換するのは、スタック内の最下位チャネルです。</span><span class="sxs-lookup"><span data-stu-id="ca589-261">The bottommost channel in the stack is responsible for actually transforming an outgoing <xref:System.ServiceModel.Channels.Message>, as modified by other channels, into some action.</span></span> <span data-ttu-id="ca589-262">受信側では、このチャネルがアクションを `Message` に変換して、他のチャネルが処理できるようにします。</span><span class="sxs-lookup"><span data-stu-id="ca589-262">On the receive side, this is the channel that converts some action into a `Message` that other channels process.</span></span>  
  
 <span data-ttu-id="ca589-263">既に説明したように、アクションはさまざまです。たとえば、各種プロトコル上でのネットワーク パケットの送信/受信、データベースでのメッセージの読み取り/書き込み、メッセージ キューへのメッセージの配置/キューからのメッセージの削除などがあります。</span><span class="sxs-lookup"><span data-stu-id="ca589-263">As stated previously, the actions may be varied: sending or receiving network packets over various protocols, reading or writing the message in a database, or queuing or dequeuing the message in a Message Queuing queue, to provide but a few examples.</span></span> <span data-ttu-id="ca589-264">これらのアクションにはすべて共通するものがあります。 WCF `Message` インスタンスと、送信、受信、読み取り、書き込み、キューに登録、デキューが可能な実際のバイトグループとの間で変換を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca589-264">All these actions have one thing in common: they require a transformation between the WCF`Message` instance and an actual group of bytes that can be sent, received, read, written, queued, or dequeued.</span></span> <span data-ttu-id="ca589-265">`Message` をバイト グループに変換するプロセスは *エンコード* と呼ばれ、バイト グループから `Message` を作成する逆のプロセスは *デコード* と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="ca589-265">The process of converting a `Message` into a group of bytes is called *encoding*, and the reverse process of creating a `Message` from a group of bytes is called *decoding*.</span></span>  
  
 <span data-ttu-id="ca589-266">ほとんどのトランスポート チャネルでは、 *メッセージ エンコーダー* と呼ばれるコンポーネントを使用して、エンコードとデコードの処理を行います。</span><span class="sxs-lookup"><span data-stu-id="ca589-266">Most transport channels use components called *message encoders* to accomplish the encoding and decoding work.</span></span> <span data-ttu-id="ca589-267">メッセージ エンコーダーは、 <xref:System.ServiceModel.Channels.MessageEncoder> クラスのサブクラスです。</span><span class="sxs-lookup"><span data-stu-id="ca589-267">A message encoder is a subclass of the <xref:System.ServiceModel.Channels.MessageEncoder> class.</span></span> <span data-ttu-id="ca589-268">`MessageEncoder` には、 `ReadMessage` とバイト グループとの間の変換を行う `WriteMessage` メソッドと `Message` メソッドのさまざまなオーバーロードが含まれます。</span><span class="sxs-lookup"><span data-stu-id="ca589-268">`MessageEncoder` includes various `ReadMessage` and `WriteMessage` method overloads to convert between `Message` and groups of bytes.</span></span>  
  
 <span data-ttu-id="ca589-269">送信側では、バッファー トランスポート チャネルが上のチャネルから受け取った `Message` オブジェクトを `WriteMessage`に渡します。</span><span class="sxs-lookup"><span data-stu-id="ca589-269">On the sending side, a buffering transport channel passes the `Message` object that it received from a channel above it to `WriteMessage`.</span></span> <span data-ttu-id="ca589-270">バッファー トランスポート チャネルはバイト配列を取得し、アクション (これらのバイトを有効な TCP パケットとしてパッケージングし、適切な送信先に送信するなど) を実行するために使用します。</span><span class="sxs-lookup"><span data-stu-id="ca589-270">It gets back an array of bytes, which it then uses to perform its action (such as packaging these bytes as valid TCP packets and sending them to the correct destination).</span></span> <span data-ttu-id="ca589-271">ストリーミング トランスポート チャネルは、(たとえば、送信 TCP 接続で) まず `Stream` を作成します。次に、この `Stream` と送信に必要な `Message` の両方を適切な `WriteMessage` オーバーロードに渡し、このオーバーロードによってメッセージが書き込まれます。</span><span class="sxs-lookup"><span data-stu-id="ca589-271">A streaming transport channel first creates a `Stream` (for example, over the outgoing TCP connection), and then passes both the `Stream` and the `Message` it needs to send to the appropriate `WriteMessage` overload, which writes out the message.</span></span>  
  
 <span data-ttu-id="ca589-272">受信側では、バッファー トランスポート チャネルは、(たとえば、受信 TCP パケットから) 受信バイトを配列に抽出し、 `ReadMessage` を呼び出して、チャネル スタックの上位に渡すことができる `Message` オブジェクトを取得します。</span><span class="sxs-lookup"><span data-stu-id="ca589-272">On the receiving side, a buffering transport channel extracts incoming bytes (for example, from incoming TCP packets) into an array and calls `ReadMessage` to get a `Message` object that it can pass further up the channel stack.</span></span> <span data-ttu-id="ca589-273">ストリーミング トランスポート チャネルは、 `Stream` オブジェクト (受信 TCP 接続のネットワーク ストリームなど) を作成し、 `ReadMessage` に渡して `Message` オブジェクトを取得します。</span><span class="sxs-lookup"><span data-stu-id="ca589-273">A streaming transport channel creates a `Stream` object (for example, a network stream over the incoming TCP connection) and passes that to `ReadMessage` to get back a `Message` object.</span></span>  
  
 <span data-ttu-id="ca589-274">トランスポート チャネルとメッセージ エンコーダーの分離は必須ではありません。つまり、メッセージ エンコーダーを使用しないトランスポート チャネルの作成が可能です。</span><span class="sxs-lookup"><span data-stu-id="ca589-274">The separation between the transport channels and the message encoder is not mandatory; it is possible to write a transport channel that does not use a message encoder.</span></span> <span data-ttu-id="ca589-275">ただし、この分離には、構成しやすいという利点があります。</span><span class="sxs-lookup"><span data-stu-id="ca589-275">However, the advantage of this separation is ease of composition.</span></span> <span data-ttu-id="ca589-276">トランスポートチャネルでベースのみが使用されて <xref:System.ServiceModel.Channels.MessageEncoder> いる限り、任意の WCF またはサードパーティのメッセージエンコーダーで動作できます。</span><span class="sxs-lookup"><span data-stu-id="ca589-276">As long as a transport channel uses only the base <xref:System.ServiceModel.Channels.MessageEncoder>, it can work with any WCF or third-party message encoder.</span></span> <span data-ttu-id="ca589-277">同様に、通常はどのトランスポート チャネルでも同じエンコーダーを使用できます。</span><span class="sxs-lookup"><span data-stu-id="ca589-277">Likewise, the same encoder can normally be used in any transport channel.</span></span>  
  
### <a name="message-encoder-operation"></a><span data-ttu-id="ca589-278">メッセージ エンコーダーの動作</span><span class="sxs-lookup"><span data-stu-id="ca589-278">Message Encoder Operation</span></span>  

 <span data-ttu-id="ca589-279">エンコーダーの一般的な動作を記述する場合、次の 4 つのケースについて検討すると有益です。</span><span class="sxs-lookup"><span data-stu-id="ca589-279">To describe the typical operation of an encoder, it is useful to consider the following four cases.</span></span>  
  
|<span data-ttu-id="ca589-280">Operation</span><span class="sxs-lookup"><span data-stu-id="ca589-280">Operation</span></span>|<span data-ttu-id="ca589-281">解説</span><span class="sxs-lookup"><span data-stu-id="ca589-281">Comment</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="ca589-282">エンコード (バッファー)</span><span class="sxs-lookup"><span data-stu-id="ca589-282">Encoding, Buffered</span></span>|<span data-ttu-id="ca589-283">バッファー モードでは、通常、エンコーダーは可変サイズのバッファーを作成し、このバッファーに XML ライターを作成します。</span><span class="sxs-lookup"><span data-stu-id="ca589-283">In buffered mode, the encoder normally creates a variable-size buffer and then creates an XML writer over it.</span></span> <span data-ttu-id="ca589-284">エンコーダーは、エンコードするメッセージに対して <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> を呼び出してヘッダーを書き込みます。次に、このトピックの <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>に関するセクションで説明したように、 `Message` を使用して本文を書き込みます。</span><span class="sxs-lookup"><span data-stu-id="ca589-284">It then calls <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> on the message being encoded, which writes out the headers and then the body using <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, as explained in the preceding section about `Message` in this topic.</span></span> <span data-ttu-id="ca589-285">その後、トランスポート チャネルで使用できるように、(バイト配列として表される) バッファーの内容が返されます。</span><span class="sxs-lookup"><span data-stu-id="ca589-285">The contents of the buffer (represented as an array of bytes) are then returned for the transport channel to use.</span></span>|  
|<span data-ttu-id="ca589-286">エンコード (ストリーミング)</span><span class="sxs-lookup"><span data-stu-id="ca589-286">Encoding, Streamed</span></span>|<span data-ttu-id="ca589-287">ストリーミング モードでは、動作が上記に似ていますが、より単純です。</span><span class="sxs-lookup"><span data-stu-id="ca589-287">In streamed mode, the operation is similar to the above, but simpler.</span></span> <span data-ttu-id="ca589-288">バッファーは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="ca589-288">There is no need for a buffer.</span></span> <span data-ttu-id="ca589-289">通常、XML ライターがストリームに作成され、このライターに書き込むために <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> に対して `Message` が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="ca589-289">An XML writer is normally created over the stream and <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> is called on the `Message` to write it out to this writer.</span></span>|  
|<span data-ttu-id="ca589-290">デコード (バッファー)</span><span class="sxs-lookup"><span data-stu-id="ca589-290">Decoding, Buffered</span></span>|<span data-ttu-id="ca589-291">バッファー モードでデコードする場合、通常、バッファーされたデータを格納する特殊な `Message` サブクラスが作成されます。</span><span class="sxs-lookup"><span data-stu-id="ca589-291">When decoding in buffered mode, a special `Message` subclass that contains the buffered data is normally created.</span></span> <span data-ttu-id="ca589-292">メッセージのヘッダーが読み取られ、メッセージ本文に配置する XML リーダーが作成されます。</span><span class="sxs-lookup"><span data-stu-id="ca589-292">The headers of the message are read, and an XML reader positioned on the message body is created.</span></span> <span data-ttu-id="ca589-293">これは、 <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>で返されるリーダーです。</span><span class="sxs-lookup"><span data-stu-id="ca589-293">This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span></span>|  
|<span data-ttu-id="ca589-294">デコード (ストリーミング)</span><span class="sxs-lookup"><span data-stu-id="ca589-294">Decoding, Streamed</span></span>|<span data-ttu-id="ca589-295">ストリーミング モードでデコードする場合、通常、特殊な Message サブクラスが作成されます。</span><span class="sxs-lookup"><span data-stu-id="ca589-295">When decoding in streamed mode, a special Message subclass is normally created.</span></span> <span data-ttu-id="ca589-296">ストリームは、すべてのヘッダーを読み取り、メッセージ本文に配置できる位置まで進められます。</span><span class="sxs-lookup"><span data-stu-id="ca589-296">The stream is advanced just enough to read all the headers and position it on the message body.</span></span> <span data-ttu-id="ca589-297">次に、ストリームに XML リーダーが作成されます。</span><span class="sxs-lookup"><span data-stu-id="ca589-297">An XML reader is then created over the stream.</span></span> <span data-ttu-id="ca589-298">これは、 <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>で返されるリーダーです。</span><span class="sxs-lookup"><span data-stu-id="ca589-298">This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span></span>|  
  
 <span data-ttu-id="ca589-299">エンコーダーでは、他の機能も実行できます。</span><span class="sxs-lookup"><span data-stu-id="ca589-299">Encoders can perform other functions as well.</span></span> <span data-ttu-id="ca589-300">たとえば、エンコーダーは XML リーダーとライターをプールできます。</span><span class="sxs-lookup"><span data-stu-id="ca589-300">For example, the encoders can pool XML readers and writers.</span></span> <span data-ttu-id="ca589-301">新しい XML リーダーまたはライターが必要になるたびに作成すると負荷がかかります。</span><span class="sxs-lookup"><span data-stu-id="ca589-301">It is expensive to create a new XML reader or writer every time one is needed.</span></span> <span data-ttu-id="ca589-302">したがって、通常、エンコーダーは構成可能なサイズのリーダーのプールとライターのプールを保持しています。</span><span class="sxs-lookup"><span data-stu-id="ca589-302">Therefore, encoders normally maintain a pool of readers and a pool of writers of configurable size.</span></span> <span data-ttu-id="ca589-303">前述のエンコーダー操作の説明では、"XML リーダー/ライターの作成" という語句が使用されている場合は、通常、"プールから取得する" または "使用できない場合に1つを作成" という意味になります。</span><span class="sxs-lookup"><span data-stu-id="ca589-303">In the descriptions of encoder operation described previously, whenever the phrase "create an XML reader/writer" is used, it normally means "take one from the pool, or create one if one is not available."</span></span> <span data-ttu-id="ca589-304">エンコーダー (およびデコード時にエンコーダーが作成する `Message` サブクラス) には、リーダーとライターが必要でなくなったら ( `Message` を閉じたときなどに) プールに戻すためのロジックが含まれています。</span><span class="sxs-lookup"><span data-stu-id="ca589-304">The encoder (and the `Message` subclasses it creates while decoding) contain logic to return readers and writers to the pools once they are no longer needed (for example, when the `Message` is closed).</span></span>  
  
 <span data-ttu-id="ca589-305">WCF には3つのメッセージエンコーダーが用意されていますが、追加のカスタム型を作成することもできます。</span><span class="sxs-lookup"><span data-stu-id="ca589-305">WCF provides three message encoders, although it is possible to create additional custom types.</span></span> <span data-ttu-id="ca589-306">用意されているエンコーダーは、Text、Binary、および MTOM (Message Transmission Optimization Mechanism) の 3 種類です。</span><span class="sxs-lookup"><span data-stu-id="ca589-306">The supplied types are Text, Binary, and Message Transmission Optimization Mechanism (MTOM).</span></span> <span data-ttu-id="ca589-307">これらの詳細については、「 [Choosing a Message Encoder](choosing-a-message-encoder.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ca589-307">These are described in detail in [Choosing a Message Encoder](choosing-a-message-encoder.md).</span></span>  
  
### <a name="the-istreamprovider-interface"></a><span data-ttu-id="ca589-308">IStreamProvider インターフェイス</span><span class="sxs-lookup"><span data-stu-id="ca589-308">The IStreamProvider Interface</span></span>  

 <span data-ttu-id="ca589-309">ストリーミングされた本文を含む送信メッセージを XML ライターに書き込むときに、 <xref:System.ServiceModel.Channels.Message> は <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> 実装で次のような一連の呼び出しを使用します。</span><span class="sxs-lookup"><span data-stu-id="ca589-309">When writing an outgoing message that contains a streamed body to an XML writer, the <xref:System.ServiceModel.Channels.Message> uses a sequence of calls similar to the following in its <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> implementation:</span></span>  
  
- <span data-ttu-id="ca589-310">ストリームの前に必要な情報を書き込みます (XML 開始タグなど)。</span><span class="sxs-lookup"><span data-stu-id="ca589-310">Write any necessary information preceding the stream (for example, the opening XML tag).</span></span>  
  
- <span data-ttu-id="ca589-311">ストリームを書き込みます。</span><span class="sxs-lookup"><span data-stu-id="ca589-311">Write the stream.</span></span>  
  
- <span data-ttu-id="ca589-312">ストリームの後に情報を書き込みます (XML 終了タグなど)。</span><span class="sxs-lookup"><span data-stu-id="ca589-312">Write any information following the stream (for example, the closing XML tag).</span></span>  
  
 <span data-ttu-id="ca589-313">これは、テキスト XML エンコーディングに類似するエンコードで有効に機能します。</span><span class="sxs-lookup"><span data-stu-id="ca589-313">This works well with encodings that are similar to the textual XML encoding.</span></span> <span data-ttu-id="ca589-314">ただし、XML Infoset 情報 (XML 要素を開始および終了するためのタグなど) を、要素内に含まれるデータと共には配置しないエンコードもあります。</span><span class="sxs-lookup"><span data-stu-id="ca589-314">However, some encodings do not place XML Infoset information (for example, tags for starting and ending XML elements) together with the data contained within elements.</span></span> <span data-ttu-id="ca589-315">たとえば、MTOM エンコーディングでは、メッセージは複数の部分に分割されます。</span><span class="sxs-lookup"><span data-stu-id="ca589-315">For example, in the MTOM encoding, the message is split into multiple parts.</span></span> <span data-ttu-id="ca589-316">ある部分に XML Infoset が含まれ、要素の実際のコンテンツについては他の部分への参照が含まれている場合があります。</span><span class="sxs-lookup"><span data-stu-id="ca589-316">One part contains the XML Infoset, which may contain references to other parts for actual element contents.</span></span> <span data-ttu-id="ca589-317">通常、XML Infoset は、ストリーミングされたコンテンツと比べてサイズが小さいため、Infoset をバッファーに格納し、これを書き込んだ後に、ストリーミング方式でコンテンツを書き込むことには意味があります。</span><span class="sxs-lookup"><span data-stu-id="ca589-317">The XML Infoset is normally small compared to the streamed contents, so it makes sense to buffer the Infoset, write it out, and then write the contents in a streamed way.</span></span> <span data-ttu-id="ca589-318">これは、終了要素タグが書き込まれるまでは、ストリームを書き込むことができないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="ca589-318">This means that by the time the closing element tag is written, the stream should not have been written out yet.</span></span>  
  
 <span data-ttu-id="ca589-319">このために、 <xref:System.Xml.IStreamProvider> インターフェイスが使用されます。</span><span class="sxs-lookup"><span data-stu-id="ca589-319">For this purpose, the <xref:System.Xml.IStreamProvider> interface is used.</span></span> <span data-ttu-id="ca589-320">このインターフェイスには、書き込むストリームを返す <xref:System.Xml.IStreamProvider.GetStream> メソッドがあります。</span><span class="sxs-lookup"><span data-stu-id="ca589-320">The interface has a <xref:System.Xml.IStreamProvider.GetStream> method that returns the stream to be written.</span></span> <span data-ttu-id="ca589-321"><xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> でストリーミングされたメッセージ本文を書き込む適切な方法は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="ca589-321">The correct way to write out a streamed message body in <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> is as follows:</span></span>  
  
1. <span data-ttu-id="ca589-322">ストリームの前に必要な情報を書き込みます (XML 開始タグなど)。</span><span class="sxs-lookup"><span data-stu-id="ca589-322">Write any necessary information preceding the stream (for example, the opening XML tag).</span></span>  
  
2. <span data-ttu-id="ca589-323">書き込むストリームを返す `WriteValue` 実装で、 <xref:System.Xml.XmlDictionaryWriter> を受け取る <xref:System.Xml.IStreamProvider>に対して `IStreamProvider` オーバーロードを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="ca589-323">Call the `WriteValue` overload on the <xref:System.Xml.XmlDictionaryWriter> that takes an <xref:System.Xml.IStreamProvider>, with an `IStreamProvider` implementation that returns the stream to be written.</span></span>  
  
3. <span data-ttu-id="ca589-324">ストリームの後に情報を書き込みます (XML 終了タグなど)。</span><span class="sxs-lookup"><span data-stu-id="ca589-324">Write any information following the stream (for example, the closing XML tag).</span></span>  
  
 <span data-ttu-id="ca589-325">この方法を使用すると、XML ライターは <xref:System.Xml.IStreamProvider.GetStream> を呼び出し、ストリーミングされたデータを書き込む時期を選択できます。</span><span class="sxs-lookup"><span data-stu-id="ca589-325">With this approach, the XML writer has a choice of when to call <xref:System.Xml.IStreamProvider.GetStream> and write out the streamed data.</span></span> <span data-ttu-id="ca589-326">たとえば、テキスト XML ライターやバイナリ XML ライターは、このメソッドをすぐに呼び出し、開始タグと終了タグの間にストリーミングされたコンテンツを書き込むことができます。</span><span class="sxs-lookup"><span data-stu-id="ca589-326">For example, the textual and binary XML writers will call it immediately and write out the streamed contents in-between the start and end tags.</span></span> <span data-ttu-id="ca589-327">MTOM ライターは、メッセージの適切な部分を書き込む準備ができたときに、後で <xref:System.Xml.IStreamProvider.GetStream> を呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="ca589-327">The MTOM writer may decide to call <xref:System.Xml.IStreamProvider.GetStream> later, when it is ready to write the appropriate part of the message.</span></span>  
  
## <a name="representing-data-in-the-service-framework"></a><span data-ttu-id="ca589-328">サービス フレームワークでのデータの表現</span><span class="sxs-lookup"><span data-stu-id="ca589-328">Representing Data in the Service Framework</span></span>  

 <span data-ttu-id="ca589-329">このトピックの「基本アーキテクチャ」セクションで説明したように、サービスフレームワークは WCF の一部であり、特に、メッセージデータと実際のインスタンスのユーザーフレンドリなプログラミングモデル間の変換を行い `Message` ます。</span><span class="sxs-lookup"><span data-stu-id="ca589-329">As stated in the "Basic Architecture" section of this topic, the service framework is the part of WCF that, among other things, is responsible for converting between a user-friendly programming model for message data and actual `Message` instances.</span></span> <span data-ttu-id="ca589-330">通常、メッセージ交換は、属性でマークされた .NET Framework メソッドとしてサービスフレームワークで表され <xref:System.ServiceModel.OperationContractAttribute> ます。</span><span class="sxs-lookup"><span data-stu-id="ca589-330">Normally, a message exchange is represented in the service framework as a .NET Framework method marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute.</span></span> <span data-ttu-id="ca589-331">このメソッドは複数のパラメーターを取得でき、戻り値または出力パラメーター (または両方) を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="ca589-331">The method can take in some parameters and can return a return value or out parameters (or both).</span></span> <span data-ttu-id="ca589-332">サービス側では、入力パラメーターは受信メッセージを表し、戻り値と出力パラメーターは送信メッセージを表します。</span><span class="sxs-lookup"><span data-stu-id="ca589-332">On the service side, the input parameters represent the incoming message, and the return value and out parameters represent the outgoing message.</span></span> <span data-ttu-id="ca589-333">クライアント側では、この逆になります。</span><span class="sxs-lookup"><span data-stu-id="ca589-333">On the client side, the reverse is true.</span></span> <span data-ttu-id="ca589-334">パラメーターと戻り値を使用してメッセージを記述するためのプログラミング モデルの詳細については、「 [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ca589-334">The programming model for describing messages using parameters and the return value is described in detail in [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span></span> <span data-ttu-id="ca589-335">ここでは、概要を簡単に説明します。</span><span class="sxs-lookup"><span data-stu-id="ca589-335">However, this section will provide a brief overview.</span></span>  
  
## <a name="programming-models"></a><span data-ttu-id="ca589-336">プログラミング モデル</span><span class="sxs-lookup"><span data-stu-id="ca589-336">Programming Models</span></span>  

 <span data-ttu-id="ca589-337">WCF サービスフレームワークでは、メッセージを記述するための5つの異なるプログラミングモデルがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="ca589-337">The WCF service framework supports five different programming models for describing messages:</span></span>  
  
### <a name="1-the-empty-message"></a><span data-ttu-id="ca589-338">1.空のメッセージ</span><span class="sxs-lookup"><span data-stu-id="ca589-338">1. The Empty Message</span></span>  

 <span data-ttu-id="ca589-339">これは、最も簡単なケースです。</span><span class="sxs-lookup"><span data-stu-id="ca589-339">This is the simplest case.</span></span> <span data-ttu-id="ca589-340">空の受信メッセージを記述する場合は、次のように入力パラメーターは使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="ca589-340">To describe an empty incoming message, do not use any input parameters.</span></span>  
  
 [!code-csharp[C_DataArchitecture#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#3)]
 [!code-vb[C_DataArchitecture#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#3)]  
  
 <span data-ttu-id="ca589-341">空の送信メッセージを記述する場合は、次のように void 戻り値を使用し、出力パラメーターは使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="ca589-341">To describe an empty outgoing message, use a void return value and do not use any out parameters:</span></span>  
  
 [!code-csharp[C_DataArchitecture#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#4)]
 [!code-vb[C_DataArchitecture#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#4)]  
  
 <span data-ttu-id="ca589-342">次のように、一方向の操作コントラクトとは異なることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="ca589-342">Note that this is different from a one-way operation contract:</span></span>  
  
 [!code-csharp[C_DataArchitecture#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#5)]
 [!code-vb[C_DataArchitecture#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#5)]  
  
 <span data-ttu-id="ca589-343">`SetDesiredTemperature` の例では、双方向メッセージ交換パターンが記述されています。</span><span class="sxs-lookup"><span data-stu-id="ca589-343">In the `SetDesiredTemperature` example, a two-way message exchange pattern is described.</span></span> <span data-ttu-id="ca589-344">メッセージは操作から返されますが、このメッセージは空です。</span><span class="sxs-lookup"><span data-stu-id="ca589-344">A message is returned from the operation, but it is empty.</span></span> <span data-ttu-id="ca589-345">操作からエラーを返すことができます。</span><span class="sxs-lookup"><span data-stu-id="ca589-345">It is possible to return a fault from the operation.</span></span> <span data-ttu-id="ca589-346">"SetLightbulb" の例では、メッセージ交換パターンは一方向であるため、記述する送信メッセージはありません。</span><span class="sxs-lookup"><span data-stu-id="ca589-346">In the "Set Lightbulb" example, the message exchange pattern is one-way, so there is no outgoing message to describe.</span></span> <span data-ttu-id="ca589-347">この場合、サービスはクライアントにステータスを通知できません。</span><span class="sxs-lookup"><span data-stu-id="ca589-347">The service cannot communicate any status back to the client in this case.</span></span>  
  
### <a name="2-using-the-message-class-directly"></a><span data-ttu-id="ca589-348">2.Message クラスの直接使用</span><span class="sxs-lookup"><span data-stu-id="ca589-348">2. Using the Message Class Directly</span></span>  

 <span data-ttu-id="ca589-349">操作コントラクトで <xref:System.ServiceModel.Channels.Message> クラス (またはサブクラスのいずれか) を直接使用できます。</span><span class="sxs-lookup"><span data-stu-id="ca589-349">It is possible to use the <xref:System.ServiceModel.Channels.Message> class (or one of its subclasses) directly in an operation contract.</span></span> <span data-ttu-id="ca589-350">この場合、サービス フレームワークは、操作からチャネル スタックおよびチャネル スタックから操作に `Message` を渡すだけであり、それ以上の処理は行いません。</span><span class="sxs-lookup"><span data-stu-id="ca589-350">In this case, the service framework just passes the `Message` from the operation to the channel stack and vice versa, with no further processing.</span></span>  
  
 <span data-ttu-id="ca589-351">`Message` を直接使用するケースとして、主に 2 つのケースがあります。</span><span class="sxs-lookup"><span data-stu-id="ca589-351">There are two main use cases for using `Message` directly.</span></span> <span data-ttu-id="ca589-352">1 つは、他のプログラミング モデルでは、メッセージを記述できるだけの柔軟性を得ることができない高度なシナリオで使用します。</span><span class="sxs-lookup"><span data-stu-id="ca589-352">You can use this for advanced scenarios, when none of the other programming models gives you enough flexibility to describe your message.</span></span> <span data-ttu-id="ca589-353">たとえば、ディスク上のファイルを使用して、ファイルのプロパティがメッセージ ヘッダーになり、ファイルの内容がメッセージ本文になるようにメッセージを記述することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="ca589-353">For example, you might want to use files on disk to describe a message, with the file’s properties becoming message headers and the file’s contents becoming the message body.</span></span> <span data-ttu-id="ca589-354">これは、次のように作成できます。</span><span class="sxs-lookup"><span data-stu-id="ca589-354">You can then create something similar to the following.</span></span>  
  
 [!code-csharp[C_DataArchitecture#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#6)]
 [!code-vb[C_DataArchitecture#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#6)]  
  
 <span data-ttu-id="ca589-355">操作コントラクトで `Message` を一般的に使用するもう 1 つのケースは、サービスがメッセージの特定の内容に留意しているわけではなく、ブラック ボックスと同様にメッセージを処理する場合です。</span><span class="sxs-lookup"><span data-stu-id="ca589-355">The second common use for `Message` in an operation contract is when a service does not care about the particular message contents and acts on the message as on a black box.</span></span> <span data-ttu-id="ca589-356">たとえば、メッセージを他の複数の受信者に転送するサービスを使用することがあります。</span><span class="sxs-lookup"><span data-stu-id="ca589-356">For example, you might have a service that forwards messages to multiple other recipients.</span></span> <span data-ttu-id="ca589-357">コントラクトは、次のように作成できます。</span><span class="sxs-lookup"><span data-stu-id="ca589-357">The contract can be written as follows.</span></span>  
  
 [!code-csharp[C_DataArchitecture#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#7)]
 [!code-vb[C_DataArchitecture#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#7)]  
  
 <span data-ttu-id="ca589-358">Action = "\*" 行によって、メッセージのディスパッチが実質的にオフになり、コントラクトに送信されるすべてのメッセージが操作に対して行われるようになり `IForwardingService` `ForwardMessage` ます。</span><span class="sxs-lookup"><span data-stu-id="ca589-358">The Action="\*" line effectively turns off message dispatching and ensures that all messages sent to the `IForwardingService` contract make their way to the `ForwardMessage` operation.</span></span> <span data-ttu-id="ca589-359">(通常、ディスパッチャーは、メッセージの "Action" ヘッダーを調べて、目的の操作を判断します。</span><span class="sxs-lookup"><span data-stu-id="ca589-359">(Normally, the dispatcher would examine the message’s "Action" header to determine which operation it is intended for.</span></span> <span data-ttu-id="ca589-360">Action = " \* " は、"action header で使用可能なすべての値" を意味します。Action = "" の組み合わせ \* と、Message をパラメーターとして使用することは、すべての可能なメッセージを受信できるため、"ユニバーサルコントラクト" と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="ca589-360">Action="\*" means "all possible values of the Action header".) The combination of Action="\*" and using Message as a parameter is known as the "universal contract" because it is able to receive all possible messages.</span></span> <span data-ttu-id="ca589-361">可能なすべてのメッセージを送信できるようにするには、メッセージを戻り値として使用し、 `ReplyAction` を "" に設定し \* ます。</span><span class="sxs-lookup"><span data-stu-id="ca589-361">To be able to send all possible messages, use Message as the return value and set `ReplyAction` to "\*".</span></span> <span data-ttu-id="ca589-362">これにより、サービス フレームワークは独自の Action ヘッダーを追加できなくなるため、開発者が返す `Message` オブジェクトを使用して、このヘッダーを制御できます。</span><span class="sxs-lookup"><span data-stu-id="ca589-362">This will prevent the service framework from adding its own Action header, enabling you to control this header using the `Message` object you return.</span></span>  
  
### <a name="3-message-contracts"></a><span data-ttu-id="ca589-363">3.メッセージ コントラクト</span><span class="sxs-lookup"><span data-stu-id="ca589-363">3. Message Contracts</span></span>  

 <span data-ttu-id="ca589-364">WCF には、メッセージ *コントラクト* と呼ばれるメッセージを記述するための宣言型プログラミングモデルが用意されています。</span><span class="sxs-lookup"><span data-stu-id="ca589-364">WCF provides a declarative programming model for describing messages, called *message contracts*.</span></span> <span data-ttu-id="ca589-365">このモデルの詳細については、「 [Using Message Contracts](using-message-contracts.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ca589-365">This model is described in detail in [Using Message Contracts](using-message-contracts.md).</span></span> <span data-ttu-id="ca589-366">基本的に、メッセージ全体は、メッセージ <xref:System.ServiceModel.MessageBodyMemberAttribute> <xref:System.ServiceModel.MessageHeaderAttribute> コントラクトクラスのどの部分をメッセージのどの部分にマップする必要があるかを説明するために、やなどの属性を使用する1つの .NET Framework 型によって表されます。</span><span class="sxs-lookup"><span data-stu-id="ca589-366">Essentially, the entire message is represented by a single .NET Framework type that uses attributes like the <xref:System.ServiceModel.MessageBodyMemberAttribute> and <xref:System.ServiceModel.MessageHeaderAttribute> to describe which parts of the message contract class should map to which part of the message.</span></span>  
  
 <span data-ttu-id="ca589-367">メッセージ コントラクトは、結果として生成される `Message` インスタンスに対してさまざまな制御を行うことができます (ただし、 `Message` クラスを直接使用した場合と同様に制御できるわけではありません)。</span><span class="sxs-lookup"><span data-stu-id="ca589-367">Message contracts provide a lot of control over the resulting `Message` instances (although obviously not as much control as using the `Message` class directly).</span></span> <span data-ttu-id="ca589-368">たとえば、多くの場合、メッセージ本文は情報の複数の部分で構成され、各部分は独自の XML 要素によって表されます。</span><span class="sxs-lookup"><span data-stu-id="ca589-368">For example, message bodies are often composed of multiple pieces of information, each represented by its own XML element.</span></span> <span data-ttu-id="ca589-369">これらの要素は、本文に直接出現することも (*ベア* モード)、XML 要素で囲んで *ラップ* することもできます。</span><span class="sxs-lookup"><span data-stu-id="ca589-369">These elements can either occur directly in the body (*bare* mode) or can be *wrapped* in an encompassing XML element.</span></span> <span data-ttu-id="ca589-370">メッセージ コントラクト プログラミング モデルを使用すると、ベアとラップのどちらを使用するかを決定し、ラッパー名と名前空間の名前を制御できます。</span><span class="sxs-lookup"><span data-stu-id="ca589-370">Using the message contract programming model enables you to make the bare-versus-wrapped decision and control the name of the wrapper name and namespace.</span></span>  
  
 <span data-ttu-id="ca589-371">前述の機能を示すメッセージ コントラクトのコード例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="ca589-371">The following code example of a message contract demonstrates these features.</span></span>  
  
 [!code-csharp[C_DataArchitecture#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#9)]
 [!code-vb[C_DataArchitecture#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#9)]  
  
 <span data-ttu-id="ca589-372"><xref:System.ServiceModel.MessageBodyMemberAttribute>、 <xref:System.ServiceModel.MessageHeaderAttribute>、または他の関連する属性を使用して、シリアル化対象としてマークされた項目は、メッセージ コントラクトに関与するためにシリアル化可能であることが必要です。</span><span class="sxs-lookup"><span data-stu-id="ca589-372">Items marked to be serialized (with the <xref:System.ServiceModel.MessageBodyMemberAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, or other related attributes) must be serializable to participate in a message contract.</span></span> <span data-ttu-id="ca589-373">詳細については、このトピックで後述する「シリアル化」のセクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="ca589-373">For more information, see the "Serialization" section later in this topic.</span></span>  
  
### <a name="4-parameters"></a><span data-ttu-id="ca589-374">4.パラメーター</span><span class="sxs-lookup"><span data-stu-id="ca589-374">4. Parameters</span></span>  

 <span data-ttu-id="ca589-375">多くの場合、データの複数の部分に作用する操作を記述する開発者は、メッセージ コントラクトによって実現される制御のレベルを必要としていません。</span><span class="sxs-lookup"><span data-stu-id="ca589-375">Often, a developer who wants to describe an operation that acts on multiple pieces of data does not need the degree of control that message contracts provide.</span></span> <span data-ttu-id="ca589-376">たとえば、新しいサービスの作成時に、ベアとラップのどちらを使用するかを決定し、ラッパー要素名を決めることは通常望まれていません。</span><span class="sxs-lookup"><span data-stu-id="ca589-376">For example, when creating new services, one does not usually want to make the bare-versus-wrapped decision and decide on the wrapper element name.</span></span> <span data-ttu-id="ca589-377">多くの場合、これらを決定するには Web サービスと SOAP の深い知識が必要となります。</span><span class="sxs-lookup"><span data-stu-id="ca589-377">Making these decisions often requires deep knowledge of Web services and SOAP.</span></span>  
  
 <span data-ttu-id="ca589-378">WCF サービスフレームワークでは、ユーザーに対してこれらの選択を強制することなく、関連する複数の情報を送受信するための最適で相互運用性の高い SOAP 表現を自動的に選択できます。</span><span class="sxs-lookup"><span data-stu-id="ca589-378">The WCF service framework can automatically pick the best and most interoperable SOAP representation for sending or receiving multiple related pieces of information, without forcing these choices on the user.</span></span> <span data-ttu-id="ca589-379">これは、情報のこのような部分を操作コントラクトのパラメーターまたは戻り値として記述するだけで実現されます。</span><span class="sxs-lookup"><span data-stu-id="ca589-379">This is accomplished by simply describing these pieces of information as parameters or return values of an operation contract.</span></span> <span data-ttu-id="ca589-380">たとえば、次のような操作コントラクトについて考えてみます。</span><span class="sxs-lookup"><span data-stu-id="ca589-380">For example, consider the following operation contract.</span></span>  
  
 [!code-csharp[C_DataArchitecture#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#11)]
 [!code-vb[C_DataArchitecture#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#11)]  
  
 <span data-ttu-id="ca589-381">サービス フレームワークは、情報の 3 つの部分 (`customerID`、 `item`、および `quantity`) をすべてメッセージ本文に配置し、 `SubmitOrderRequest`というラッパー要素にラップすることを自動的に決定します。</span><span class="sxs-lookup"><span data-stu-id="ca589-381">The service framework automatically decides to put all three pieces of information (`customerID`, `item`, and `quantity`) into the message body and wrap them in a wrapper element named `SubmitOrderRequest`.</span></span>  
  
 <span data-ttu-id="ca589-382">より複雑なメッセージ コントラクトや `Message`ベースのプログラミング モデルに移行する特別な理由がない限り、操作コントラクト パラメーターの簡単なリストとして送信または受信するように情報を記述することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="ca589-382">Describing the information to be sent or received as a simple list of operation contract parameters is the recommended approach, unless special reasons exist to move to the more-complex message contract or `Message`-based programming models.</span></span>  
  
### <a name="5-stream"></a><span data-ttu-id="ca589-383">5.ストリーム</span><span class="sxs-lookup"><span data-stu-id="ca589-383">5. Stream</span></span>  

 <span data-ttu-id="ca589-384">`Stream` またはそのサブクラスのいずれかを、操作コントラクトで使用したり、メッセージ コントラクトでメッセージ本文の単独の部分として使用したりすることは、これまでに説明したものとは別のプログラミング モデルと考えることができます。</span><span class="sxs-lookup"><span data-stu-id="ca589-384">Using `Stream` or one of its subclasses in an operation contract or as a sole message body part in a message contract can be considered a separate programming model from the ones described above.</span></span> <span data-ttu-id="ca589-385">ストリーミングに対応する独自の `Stream` サブクラスを作成する場合を除き、 `Message` をこのように使用することは、コントラクトをストリーミング方式で使用できることを保証する唯一の方法です。</span><span class="sxs-lookup"><span data-stu-id="ca589-385">Using `Stream` in this way is the only way to guarantee that your contract will be usable in a streamed fashion, short of writing your own streaming-compatible `Message` subclass.</span></span> <span data-ttu-id="ca589-386">詳細については、「 [Large Data And Streaming](large-data-and-streaming.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ca589-386">For more information, see [Large Data and Streaming](large-data-and-streaming.md).</span></span>  
  
 <span data-ttu-id="ca589-387">`Stream` またはそのサブクラスのいずれかをこのように使用した場合、シリアライザーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="ca589-387">When `Stream` or one of its subclasses is used in this way, the serializer is not invoked.</span></span> <span data-ttu-id="ca589-388">送信メッセージの場合、 `Message` インターフェイスのセクションで説明したように、特殊なストリーミング <xref:System.Xml.IStreamProvider> サブクラスが作成され、ストリームが書き込まれます。</span><span class="sxs-lookup"><span data-stu-id="ca589-388">For outgoing messages, a special streaming `Message` subclass is created and the stream is written out as described in the section on the <xref:System.Xml.IStreamProvider> interface.</span></span> <span data-ttu-id="ca589-389">受信メッセージの場合は、サービス フレームワークが受信メッセージに `Stream` サブクラスを作成し、操作に提供します。</span><span class="sxs-lookup"><span data-stu-id="ca589-389">For incoming messages, the service framework creates a `Stream` subclass over the incoming message and provides it to the operation.</span></span>  
  
## <a name="programming-model-restrictions"></a><span data-ttu-id="ca589-390">プログラミング モデルの制限</span><span class="sxs-lookup"><span data-stu-id="ca589-390">Programming Model Restrictions</span></span>  

 <span data-ttu-id="ca589-391">前述のプログラミング モデルを任意に組み合わせることはできません。</span><span class="sxs-lookup"><span data-stu-id="ca589-391">The programming models described above cannot be arbitrarily combined.</span></span> <span data-ttu-id="ca589-392">たとえば、ある操作でメッセージ コントラクトを受け入れる場合、そのメッセージ コントラクトは入力パラメーターのみであることが必要です。</span><span class="sxs-lookup"><span data-stu-id="ca589-392">For example, if an operation accepts a message contract type, the message contract must be its only input parameter.</span></span> <span data-ttu-id="ca589-393">さらに、操作では、空のメッセージ (戻り値の型が void) または別のメッセージ コントラクトを返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca589-393">Furthermore, the operation must then either return an empty message (return type of void) or another message contract.</span></span> <span data-ttu-id="ca589-394">プログラミング モデルのこれらの制限については、各プログラミング モデルに関するトピック (「 [Using Message Contracts](using-message-contracts.md)」、「 [Using the Message Class](using-the-message-class.md)」、および「 [Large Data and Streaming](large-data-and-streaming.md)」) に記載されています。</span><span class="sxs-lookup"><span data-stu-id="ca589-394">These programming model restrictions are described in the topics for each specific programming model: [Using Message Contracts](using-message-contracts.md), [Using the Message Class](using-the-message-class.md), and [Large Data and Streaming](large-data-and-streaming.md).</span></span>  
  
## <a name="message-formatters"></a><span data-ttu-id="ca589-395">メッセージ フォーマッタ</span><span class="sxs-lookup"><span data-stu-id="ca589-395">Message Formatters</span></span>  

 <span data-ttu-id="ca589-396">前述の各プログラミング モデルは、 *"メッセージ フォーマッタ"* と呼ばれるコンポーネントをサービス フレームワークにプラグインすることによってサポートされます。</span><span class="sxs-lookup"><span data-stu-id="ca589-396">The programming models described above are supported by plugging in components called *message formatters* into the service framework.</span></span> <span data-ttu-id="ca589-397">メッセージフォーマッタは、インターフェイスまたはインターフェイスを実装する型、または <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> クライアントとサービスの WCF クライアントで使用するための、両方を実装する型です。</span><span class="sxs-lookup"><span data-stu-id="ca589-397">Message formatters are types that implement the <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> or <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> interface, or both, for use in clients and service WCF clients, respectively.</span></span>  
  
 <span data-ttu-id="ca589-398">通常、メッセージ フォーマッタは動作によってプラグインされます。</span><span class="sxs-lookup"><span data-stu-id="ca589-398">Message formatters are normally plugged in by behaviors.</span></span> <span data-ttu-id="ca589-399">たとえば、 <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> は、データ コントラクト メッセージ フォーマッタをプラグインします。</span><span class="sxs-lookup"><span data-stu-id="ca589-399">For example, the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> plugs in the data contract message formatter.</span></span> <span data-ttu-id="ca589-400">これを行うには、サービス側では <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> メソッドで <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> を適切なフォーマッタに設定します。クライアント側では、 <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> メソッドで <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> を適切なフォーマッタに設定します。</span><span class="sxs-lookup"><span data-stu-id="ca589-400">This is done on the service side by setting <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> method, or on the client side by setting <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> method.</span></span>  
  
 <span data-ttu-id="ca589-401">メッセージ フォーマッタが実装できるメソッドを次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="ca589-401">The following tables lists the methods that a message formatter may implement.</span></span>  
  
|<span data-ttu-id="ca589-402">インターフェイス</span><span class="sxs-lookup"><span data-stu-id="ca589-402">Interface</span></span>|<span data-ttu-id="ca589-403">メソッド</span><span class="sxs-lookup"><span data-stu-id="ca589-403">Method</span></span>|<span data-ttu-id="ca589-404">アクション</span><span class="sxs-lookup"><span data-stu-id="ca589-404">Action</span></span>|  
|---------------|------------|------------|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.DeserializeRequest%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|<span data-ttu-id="ca589-405">受信 `Message` を操作パラメーターに変換します。</span><span class="sxs-lookup"><span data-stu-id="ca589-405">Converts an incoming `Message` to operation parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.SerializeReply%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%2CSystem.Object%29>|<span data-ttu-id="ca589-406">操作の戻り値または出力パラメーターから送信 `Message` を作成します。</span><span class="sxs-lookup"><span data-stu-id="ca589-406">Creates an outgoing `Message` from operation return value/out parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.SerializeRequest%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%29>|<span data-ttu-id="ca589-407">操作パラメーターから送信 `Message` を作成します。</span><span class="sxs-lookup"><span data-stu-id="ca589-407">Creates an outgoing `Message` from operation parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.DeserializeReply%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|<span data-ttu-id="ca589-408">受信 `Message` を戻り値または出力パラメーターに変換します。</span><span class="sxs-lookup"><span data-stu-id="ca589-408">Converts an incoming `Message` to a return value/out parameters</span></span>|  
  
## <a name="serialization"></a><span data-ttu-id="ca589-409">シリアル化</span><span class="sxs-lookup"><span data-stu-id="ca589-409">Serialization</span></span>  

 <span data-ttu-id="ca589-410">メッセージコントラクトまたはパラメーターを使用してメッセージの内容を記述するときは常に、シリアル化を使用して .NET Framework の型と XML Infoset 表現の間で変換を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="ca589-410">Whenever you use message contracts or parameters to describe message contents, you must use serialization to convert between .NET Framework types and XML Infoset representation.</span></span> <span data-ttu-id="ca589-411">シリアル化は、WCF 内の他の場所で使用されます。たとえば、に <xref:System.ServiceModel.Channels.Message> は、 <xref:System.ServiceModel.Channels.Message.GetBody%2A> オブジェクトに逆シリアル化されたメッセージの本文全体を読み取るために使用できるジェネリックメソッドがあります。</span><span class="sxs-lookup"><span data-stu-id="ca589-411">Serialization is used in other places in WCF, for example, <xref:System.ServiceModel.Channels.Message> has a Generic <xref:System.ServiceModel.Channels.Message.GetBody%2A> method that you can use to read the entire body of the message deserialized into an object.</span></span>  
  
 <span data-ttu-id="ca589-412">WCF では、パラメーターとメッセージ部分をシリアル化および逆シリアル化するための、"すぐに使用できる" 2 つのシリアル化テクノロジがサポートされています。 <xref:System.Runtime.Serialization.DataContractSerializer> と `XmlSerializer` 。</span><span class="sxs-lookup"><span data-stu-id="ca589-412">WCF supports two serialization technologies "out of the box" for serializing and deserializing parameters and message parts: the <xref:System.Runtime.Serialization.DataContractSerializer> and the `XmlSerializer`.</span></span> <span data-ttu-id="ca589-413">また、カスタム シリアライザーを作成することもできます。</span><span class="sxs-lookup"><span data-stu-id="ca589-413">Additionally, you can write custom serializers.</span></span> <span data-ttu-id="ca589-414">ただし、WCF のその他の部分 (ジェネリック `GetBody` メソッドや SOAP エラーのシリアル化など) は、サブクラスのみを使用するように制限することができます (ただし、は使用でき <xref:System.Runtime.Serialization.XmlObjectSerializer> <xref:System.Runtime.Serialization.DataContractSerializer> <xref:System.Runtime.Serialization.NetDataContractSerializer> ません <xref:System.Xml.Serialization.XmlSerializer> )。また、を使用するようにハードコーディングすることもでき <xref:System.Runtime.Serialization.DataContractSerializer> ます。</span><span class="sxs-lookup"><span data-stu-id="ca589-414">However, other parts of WCF (such as the Generic `GetBody` method or SOAP fault serialization) may be restricted to use only the <xref:System.Runtime.Serialization.XmlObjectSerializer> subclasses (<xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>, but not the <xref:System.Xml.Serialization.XmlSerializer>), or may even be hard-coded to use only the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span>  
  
 <span data-ttu-id="ca589-415">は、 `XmlSerializer` ASP.NET Web サービスで使用されるシリアル化エンジンです。</span><span class="sxs-lookup"><span data-stu-id="ca589-415">The `XmlSerializer` is the serialization engine used in ASP.NET Web services.</span></span> <span data-ttu-id="ca589-416">`DataContractSerializer` は、新しいデータ コントラクト プログラミング モデルを認識する新しいシリアル化エンジンです。</span><span class="sxs-lookup"><span data-stu-id="ca589-416">The `DataContractSerializer` is the new serialization engine that understands the new data contract programming model.</span></span> <span data-ttu-id="ca589-417">`DataContractSerializer` が既定で選択されています。 `XmlSerializer` を使用する場合は、 <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> 属性を使用して操作ごとに選択できます。</span><span class="sxs-lookup"><span data-stu-id="ca589-417">`DataContractSerializer` is the default choice, and the choice to use the `XmlSerializer` can be made on a per-operation basis using the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> attribute.</span></span>  
  
 <span data-ttu-id="ca589-418"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> と <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> は、それぞれ `DataContractSerializer` および `XmlSerializer`のメッセージ フォーマッタをプラグインする役割を担う操作の動作です。</span><span class="sxs-lookup"><span data-stu-id="ca589-418"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> and <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> are the operation behaviors responsible for plugging in the message formatters for the `DataContractSerializer` and the `XmlSerializer`, respectively.</span></span> <span data-ttu-id="ca589-419"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> の動作は、 <xref:System.Runtime.Serialization.XmlObjectSerializer>など、 <xref:System.Runtime.Serialization.NetDataContractSerializer> から派生した任意のシリアライザーで実際に操作できます (詳細については、「スタンドアロンのシリアル化の使用」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="ca589-419">The <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> behavior can actually operate with any serializer that derives from <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.NetDataContractSerializer> (described in detail in Using Stand-Alone Serialization).</span></span> <span data-ttu-id="ca589-420">この動作では、 `CreateSerializer` 仮想メソッド オーバーロードのいずれかを呼び出して、シリアライザーを取得します。</span><span class="sxs-lookup"><span data-stu-id="ca589-420">The behavior calls one of the `CreateSerializer` virtual method overloads to obtain the serializer.</span></span> <span data-ttu-id="ca589-421">別のシリアライザーをプラグインするには、新しい <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> サブクラスを作成し、 `CreateSerializer` の両方のオーバーロードをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="ca589-421">To plug in a different serializer, create a new <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> subclass and override both `CreateSerializer` overloads.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ca589-422">関連項目</span><span class="sxs-lookup"><span data-stu-id="ca589-422">See also</span></span>

- [<span data-ttu-id="ca589-423">サービス コントラクトでのデータ転送の指定</span><span class="sxs-lookup"><span data-stu-id="ca589-423">Specifying Data Transfer in Service Contracts</span></span>](specifying-data-transfer-in-service-contracts.md)
