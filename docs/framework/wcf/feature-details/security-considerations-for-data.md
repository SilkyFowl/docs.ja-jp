---
description: '詳細情報: データのセキュリティに関する考慮事項'
title: セキュリティに関するデータの考慮事項
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: a7eb98da-4a93-4692-8b59-9d670c79ffb2
ms.openlocfilehash: 6e0bf681ad8dd141ad030ef850c3e50c1d6e65c8
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/06/2021
ms.locfileid: "99632621"
---
# <a name="security-considerations-for-data"></a><span data-ttu-id="98d05-103">セキュリティに関するデータの考慮事項</span><span class="sxs-lookup"><span data-stu-id="98d05-103">Security Considerations for Data</span></span>

<span data-ttu-id="98d05-104">Windows Communication Foundation (WCF) でデータを処理する場合は、いくつかの脅威のカテゴリを考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-104">When dealing with data in Windows Communication Foundation (WCF), you must consider a number of threat categories.</span></span> <span data-ttu-id="98d05-105">次の一覧は、データ処理に関連する最も重要な脅威クラスを示しています。</span><span class="sxs-lookup"><span data-stu-id="98d05-105">The following list shows the most important threat classes that relate to data processing.</span></span> <span data-ttu-id="98d05-106">WCF には、これらの脅威を軽減するツールが用意されています。</span><span class="sxs-lookup"><span data-stu-id="98d05-106">WCF provides tools to mitigate these threats.</span></span>

* <span data-ttu-id="98d05-107">サービス拒否</span><span class="sxs-lookup"><span data-stu-id="98d05-107">Denial of service</span></span>

  <span data-ttu-id="98d05-108">信頼できないデータを受信すると、受信側では、そのデータによって非常に長い計算が発生し、メモリ、スレッド、利用可能な接続、プロセッサ サイクルなど複数のリソースに過剰にアクセスすることがあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-108">When receiving untrusted data, the data may cause the receiving side to access a disproportionate amount of various resources, such as memory, threads, available connections, or processor cycles by causing lengthy computations.</span></span> <span data-ttu-id="98d05-109">サーバーに対するサービス拒否攻撃によって、サーバーがクラッシュし、正当なクライアントからのメッセージを処理できなくなる場合があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-109">A denial-of-service attack against a server may cause it to crash and be unable to process messages from other, legitimate clients.</span></span>

* <span data-ttu-id="98d05-110">悪質なコードの実行</span><span class="sxs-lookup"><span data-stu-id="98d05-110">Malicious code execution</span></span>

  <span data-ttu-id="98d05-111">信頼できないデータを受信すると、受信側で本来意図してしないコードが実行されます。</span><span class="sxs-lookup"><span data-stu-id="98d05-111">Incoming untrusted data causes the receiving side to run code it did not intend to.</span></span>

* <span data-ttu-id="98d05-112">情報漏えい</span><span class="sxs-lookup"><span data-stu-id="98d05-112">Information disclosure</span></span>

  <span data-ttu-id="98d05-113">リモートの攻撃者は、受信側に要求への応答を強制し、受信側が意図した以上の情報を公開させます。</span><span class="sxs-lookup"><span data-stu-id="98d05-113">The remote attacker forces the receiving party to respond to its requests in such a way as to disclose more information than it intends to.</span></span>

## <a name="user-provided-code-and-code-access-security"></a><span data-ttu-id="98d05-114">ユーザー指定のコードとコード アクセス セキュリティ</span><span class="sxs-lookup"><span data-stu-id="98d05-114">User-Provided Code and Code Access Security</span></span>

<span data-ttu-id="98d05-115">Windows Communication Foundation (WCF) インフラストラクチャのさまざまな場所で、ユーザーが提供するコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="98d05-115">A number of places in the Windows Communication Foundation (WCF) infrastructure run code that is provided by the user.</span></span> <span data-ttu-id="98d05-116">たとえば、 <xref:System.Runtime.Serialization.DataContractSerializer> シリアル化エンジンでは、ユーザー指定のプロパティの `set` アクセサーと `get` アクセサーが呼び出されることがあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-116">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> serialization engine may call user-provided property `set` accessors and `get` accessors.</span></span> <span data-ttu-id="98d05-117">WCF チャネルインフラストラクチャは、クラスのユーザー指定の派生クラスを呼び出すこともでき <xref:System.ServiceModel.Channels.Message> ます。</span><span class="sxs-lookup"><span data-stu-id="98d05-117">The WCF channel infrastructure may also call into user-provided derived classes of the <xref:System.ServiceModel.Channels.Message> class.</span></span>

<span data-ttu-id="98d05-118">コード作成者は、コードにセキュリティの脆弱性が存在しないことを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-118">It is the responsibility of the code author to ensure that no security vulnerabilities exist.</span></span> <span data-ttu-id="98d05-119">たとえば、整数型のデータ メンバー プロパティを使用してデータ コントラクト型を作成し、 `set` アクセサー実装でこのプロパティ値に基づいて配列を割り当てた場合、悪質なメッセージにこのデータ メンバーの極端に大きな値が含まれていると、サービス拒否攻撃の危険にさらされることになります。</span><span class="sxs-lookup"><span data-stu-id="98d05-119">For example, if you create a data contract type with a data member property of type integer, and in the `set` accessor implementation allocate an array based on the property value, you expose the possibility of a denial-of-service attack if a malicious message contains an extremely large value for this data member.</span></span> <span data-ttu-id="98d05-120">一般的に、受信データに基づく割り当てや、ユーザー指定のコードでの長時間に及ぶ処理は回避します (特に、長時間に及ぶ処理が少量の受信データによって発生する可能性がある場合)。</span><span class="sxs-lookup"><span data-stu-id="98d05-120">In general, avoid any allocations based on incoming data or lengthy processing in user-provided code (especially if lengthy processing can be caused by a small amount of incoming data).</span></span> <span data-ttu-id="98d05-121">ユーザー指定のコードのセキュリティ分析を実行するときは、必ず失敗した場合 (つまり、例外をスローするすべてのコード分岐) も考慮してください。</span><span class="sxs-lookup"><span data-stu-id="98d05-121">When performing security analysis of user-provided code, make sure to also consider all failure cases (that is, all code branches where exceptions are thrown).</span></span>

<span data-ttu-id="98d05-122">ユーザー指定コードの特に重要な例は、各操作に対するサービス実装内部のコードです。</span><span class="sxs-lookup"><span data-stu-id="98d05-122">The ultimate example of user-provided code is the code inside your service implementation for each operation.</span></span> <span data-ttu-id="98d05-123">サービス実装のセキュリティを確保することはユーザーの責任です。</span><span class="sxs-lookup"><span data-stu-id="98d05-123">The security of your service implementation is your responsibility.</span></span> <span data-ttu-id="98d05-124">サービス拒否の脆弱性を生じるような、セキュリティで保護されていない操作実装は、不注意によって容易に作成されてしまいます。</span><span class="sxs-lookup"><span data-stu-id="98d05-124">It is easy to inadvertently create insecure operation implementations that may result in denial-of-service vulnerabilities.</span></span> <span data-ttu-id="98d05-125">たとえば、文字列を受け取り、名前がその文字列で始まる顧客のリストをデータベースから返す操作があるとします。</span><span class="sxs-lookup"><span data-stu-id="98d05-125">For example, an operation that takes a string and returns the list of customers from a database whose name starts with that string.</span></span> <span data-ttu-id="98d05-126">使用しているデータベースの規模が大きく、渡された文字列が 1 文字の場合、ユーザーのコードは、使用可能なメモリより大きなメッセージを作成しようとする可能性があります。これによって、サービス全体が失敗します</span><span class="sxs-lookup"><span data-stu-id="98d05-126">If you are working with a large database and the string being passed is just a single letter, your code may attempt to create a message larger than all available memory, causing the entire service to fail.</span></span> <span data-ttu-id="98d05-127">( <xref:System.OutOfMemoryException> .NET Framework では回復できず、常にアプリケーションが終了します。)</span><span class="sxs-lookup"><span data-stu-id="98d05-127">(An <xref:System.OutOfMemoryException> is not recoverable in the .NET Framework and always results in the termination of your application.)</span></span>

<span data-ttu-id="98d05-128">悪質なコードがさまざまな機能拡張ポイントに接続されないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-128">You should ensure that no malicious code is plugged in to the various extensibility points.</span></span> <span data-ttu-id="98d05-129">これが特に関係するのは、部分信頼で実行する場合、部分信頼アセンブリの型を処理する場合、または部分信頼コードで使用できるコンポーネントを作成する場合です。</span><span class="sxs-lookup"><span data-stu-id="98d05-129">This is especially relevant when running under partial trust, dealing with types from partially-trusted assemblies, or creating components usable by partially-trusted code.</span></span> <span data-ttu-id="98d05-130">詳細については、後のセクションの「部分信頼に関する脅威」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="98d05-130">For more information, see "Partial Trust Threats" in a later section.</span></span>

<span data-ttu-id="98d05-131">部分信頼で実行する場合、データ コントラクトのシリアル化インフラストラクチャがサポートするのは、データ コントラクト プログラミング モデルの一部のサブセットのみです。たとえば、 <xref:System.SerializableAttribute> 属性を使用するプライベート データ メンバーや型はサポートされません。</span><span class="sxs-lookup"><span data-stu-id="98d05-131">Note that when running in partial trust, the data contract serialization infrastructure supports only a limited subset of the data contract programming model - for example, private data members or types using the <xref:System.SerializableAttribute> attribute are not supported.</span></span> <span data-ttu-id="98d05-132">詳細については、「 [部分信頼](partial-trust.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="98d05-132">For more information, see [Partial Trust](partial-trust.md).</span></span>

## <a name="avoiding-unintentional-information-disclosure"></a><span data-ttu-id="98d05-133">意図しない情報公開の回避</span><span class="sxs-lookup"><span data-stu-id="98d05-133">Avoiding Unintentional Information Disclosure</span></span>

<span data-ttu-id="98d05-134">セキュリティを念頭に置いてシリアル化可能な型を設計するとき、情報の漏えい公開は考慮事項の 1 つです。</span><span class="sxs-lookup"><span data-stu-id="98d05-134">When designing serializable types with security in mind, information disclosure is a possible concern.</span></span>

<span data-ttu-id="98d05-135">次の点を考慮します。</span><span class="sxs-lookup"><span data-stu-id="98d05-135">Consider the following points:</span></span>

- <span data-ttu-id="98d05-136"><xref:System.Runtime.Serialization.DataContractSerializer> プログラミング モデルでは、シリアル化中に型またはアセンブリの外側で、プライベートな内部データの公開が許可されます。</span><span class="sxs-lookup"><span data-stu-id="98d05-136">The <xref:System.Runtime.Serialization.DataContractSerializer> programming model allows the exposure of private and internal data outside of the type or assembly during serialization.</span></span> <span data-ttu-id="98d05-137">さらに、スキーマのエクスポート時に型の形状が公開されることがあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-137">Additionally, the shape of a type can be exposed during schema export.</span></span> <span data-ttu-id="98d05-138">必ず、型のシリアル化射影について理解してください。</span><span class="sxs-lookup"><span data-stu-id="98d05-138">Be sure to understand your type's serialization projection.</span></span> <span data-ttu-id="98d05-139">型を公開しない場合は、シリアル化を無効にします (たとえば、データ コントラクトの場合、 <xref:System.Runtime.Serialization.DataMemberAttribute> 属性を適用しないことによって無効にします)。</span><span class="sxs-lookup"><span data-stu-id="98d05-139">If you do not want anything exposed, disable serializing it (for example, by not applying the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute in the case of a data contract).</span></span>

- <span data-ttu-id="98d05-140">使用するシリアライザーによっては、同じ型に対して複数のシリアル化射影が存在することがあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-140">Be aware that the same type may have multiple serialization projections, depending on the serializer in use.</span></span> <span data-ttu-id="98d05-141">また、同じ型であっても、 <xref:System.Runtime.Serialization.DataContractSerializer> を使用したときに公開されるデータ セットと、 <xref:System.Xml.Serialization.XmlSerializer>を使用したとき公開されるデータ セットが異なる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-141">The same type may expose one set of data when used with the <xref:System.Runtime.Serialization.DataContractSerializer> and another set of data when used with the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="98d05-142">使用するシリアライザーを誤ると、情報の漏えいを招く場合があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-142">Accidentally using the wrong serializer may lead to information disclosure.</span></span>

- <span data-ttu-id="98d05-143">従来のリモート プロシージャ コール (RPC)/エンコード モードで <xref:System.Xml.Serialization.XmlSerializer> を使用すると、送信側のオブジェクト グラフの形状が誤って受信側に公開されることがあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-143">Using the <xref:System.Xml.Serialization.XmlSerializer> in legacy remote procedure call (RPC)/encoded mode may unintentionally expose the shape of the object graph on the sending side to the receiving side.</span></span>

## <a name="preventing-denial-of-service-attacks"></a><span data-ttu-id="98d05-144">サービス拒否攻撃の防止</span><span class="sxs-lookup"><span data-stu-id="98d05-144">Preventing Denial-of-Service Attacks</span></span>

### <a name="quotas"></a><span data-ttu-id="98d05-145">Quotas (クォータ)</span><span class="sxs-lookup"><span data-stu-id="98d05-145">Quotas</span></span>

<span data-ttu-id="98d05-146">受信側で大量のメモリ割り当てが発生した場合、サービス拒否攻撃の可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-146">Causing the receiving side to allocate a significant amount of memory is a potential denial-of-service attack.</span></span> <span data-ttu-id="98d05-147">ここでは、主に大きいメッセージが原因で起こるメモリ消費の問題について説明しますが、攻撃には他の種類もあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-147">While this section concentrates on memory consumption issues arising from large messages, other attacks may occur.</span></span> <span data-ttu-id="98d05-148">たとえば、メッセージに過度の処理時間が使用される場合があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-148">For example, messages may use a disproportionate amount of processing time.</span></span>

<span data-ttu-id="98d05-149">サービス拒否攻撃の緩和には通常、クォータを使用します。</span><span class="sxs-lookup"><span data-stu-id="98d05-149">Denial-of-service attacks are usually mitigated using quotas.</span></span> <span data-ttu-id="98d05-150">クォータを超えると、通常は <xref:System.ServiceModel.QuotaExceededException> 例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="98d05-150">When a quota is exceeded, a <xref:System.ServiceModel.QuotaExceededException> exception is normally thrown.</span></span> <span data-ttu-id="98d05-151">クォータが設定されていないと、悪質なメッセージが使用可能なすべてのメモリにアクセスし、 <xref:System.OutOfMemoryException> 例外が発生したり、使用可能なすべてのスタックにアクセスし、 <xref:System.StackOverflowException>例外が発生したりする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-151">Without the quota, a malicious message may cause all available memory to be accessed, resulting in an <xref:System.OutOfMemoryException> exception, or all available stacks to be accessed, resulting in a <xref:System.StackOverflowException>.</span></span>

<span data-ttu-id="98d05-152">クォータが超過した状況は、回復可能です。実行中のサービスでこの状況が発生した場合、現在処理されているメッセージは破棄されますが、サービスの実行は続行され、次のメッセージが処理されます。</span><span class="sxs-lookup"><span data-stu-id="98d05-152">The quota exceeded scenario is recoverable; if encountered in a running service, the message currently being processed is discarded and the service keeps running and processes further messages.</span></span> <span data-ttu-id="98d05-153">ただし、メモリ不足とスタックオーバーフローのシナリオは、.NET Framework のどこでも回復できません。このような例外が発生した場合、サービスは終了します。</span><span class="sxs-lookup"><span data-stu-id="98d05-153">The out-of-memory and stack overflow scenarios, however, are not recoverable anywhere in the .NET Framework; the service terminates if it encounters such exceptions.</span></span>

<span data-ttu-id="98d05-154">WCF のクォータには、事前割り当ては含まれません。</span><span class="sxs-lookup"><span data-stu-id="98d05-154">Quotas in WCF do not involve any pre-allocation.</span></span> <span data-ttu-id="98d05-155">たとえば、さまざまなクラスにある <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> クォータを 128 KB に設定した場合、各メッセージに 128 KB が自動的に割り当てられるわけではありません。</span><span class="sxs-lookup"><span data-stu-id="98d05-155">For example, if the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota (found on various classes) is set to 128 KB, it does not mean that 128 KB is automatically allocated for each message.</span></span> <span data-ttu-id="98d05-156">実際の割当量は、実際の受信メッセージのサイズによって異なります。</span><span class="sxs-lookup"><span data-stu-id="98d05-156">The actual amount allocated depends on the actual incoming message size.</span></span>

<span data-ttu-id="98d05-157">トランスポート層には、利用できるクォータが多数あります。</span><span class="sxs-lookup"><span data-stu-id="98d05-157">Many quotas are available at the transport layer.</span></span> <span data-ttu-id="98d05-158">使用しているトランスポート チャネル (HTTP、TCP など) によって指定されるクォータもあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-158">These are quotas enforced by the specific transport channel in use (HTTP, TCP, and so on).</span></span> <span data-ttu-id="98d05-159">ここでは、これらのクォータの一部について説明しますが、詳細については、「 [Transport Quotas](transport-quotas.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="98d05-159">While this topic discusses some of these quotas, these quotas are described in detail in [Transport Quotas](transport-quotas.md).</span></span>

### <a name="hashtable-vulnerability"></a><span data-ttu-id="98d05-160">ハッシュ テーブルの脆弱性</span><span class="sxs-lookup"><span data-stu-id="98d05-160">Hashtable Vulnerability</span></span>

<span data-ttu-id="98d05-161">データ コントラクトにハッシュ テーブルまたはコレクションが含まれている場合は脆弱性が存在します。</span><span class="sxs-lookup"><span data-stu-id="98d05-161">A vulnerability exists when data contracts contain hashtables or collections.</span></span> <span data-ttu-id="98d05-162">多数の値がハッシュ テーブルに挿入されると問題が発生します。ハッシュ テーブルでは、このような多数の値によって同じハッシュ値が生成されます。</span><span class="sxs-lookup"><span data-stu-id="98d05-162">The problem occurs if a large number of values are inserted into a hashtable where a large number of those values generate the same hash value.</span></span> <span data-ttu-id="98d05-163">これは、DOS 攻撃に使用される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-163">This can be used as a DOS attack.</span></span>  <span data-ttu-id="98d05-164">この脆弱性は、MaxReceivedMessageSize binding クォータを設定することによって軽減できます。</span><span class="sxs-lookup"><span data-stu-id="98d05-164">This vulnerability can be mitigated by setting the MaxReceivedMessageSize binding quota.</span></span> <span data-ttu-id="98d05-165">このような攻撃を防ぐためにこのクォータを設定している場合は注意が必要です。</span><span class="sxs-lookup"><span data-stu-id="98d05-165">Care must be taken while setting this quota in order to prevent such attacks.</span></span> <span data-ttu-id="98d05-166">このクォータにより、WCF メッセージのサイズに上限が設定されます。</span><span class="sxs-lookup"><span data-stu-id="98d05-166">This quota puts an upper limit on the size of WCF message.</span></span> <span data-ttu-id="98d05-167">また、データ コントラクトではハッシュ テーブルやコレクションを使用しないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="98d05-167">Additionally, avoid using hashtables or collections in your data contracts.</span></span>

## <a name="limiting-memory-consumption-without-streaming"></a><span data-ttu-id="98d05-168">メモリ消費の制限 (ストリーミングなしの場合)</span><span class="sxs-lookup"><span data-stu-id="98d05-168">Limiting Memory Consumption Without Streaming</span></span>

<span data-ttu-id="98d05-169">大きいメッセージに関するセキュリティ モデルは、ストリーミングが使用されているかどうかによって異なります。</span><span class="sxs-lookup"><span data-stu-id="98d05-169">The security model around large messages depends on whether streaming is in use.</span></span> <span data-ttu-id="98d05-170">ストリーミングを使用しない基本的なケースでは、メッセージはメモリにバッファーされます。</span><span class="sxs-lookup"><span data-stu-id="98d05-170">In the basic, non-streamed case, messages are buffered into memory.</span></span> <span data-ttu-id="98d05-171">この場合、 <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> またはシステム指定のバインディングで <xref:System.ServiceModel.Channels.TransportBindingElement> クォータを使用して、アクセスするメッセージの最大サイズを制限することによって、サイズの大きいメッセージからシステムを保護します。</span><span class="sxs-lookup"><span data-stu-id="98d05-171">In this case, use the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota on the <xref:System.ServiceModel.Channels.TransportBindingElement> or on the system-provided bindings to protect against large messages by limiting the maximum message size to access.</span></span> <span data-ttu-id="98d05-172">サービスが複数のメッセージを同時に処理していることがありますが、この場合、メッセージはすべてメモリ内にあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-172">Note that a service may be processing multiple messages at the same time, in which case they are all in memory.</span></span> <span data-ttu-id="98d05-173">この脅威を軽減するには、調整機能を使用します。</span><span class="sxs-lookup"><span data-stu-id="98d05-173">Use the throttling feature to mitigate this threat.</span></span>

<span data-ttu-id="98d05-174">また、 `MaxReceivedMessageSize` ではメッセージごとのメモリ消費に対して上限値が設定されませんが、メッセージごとのメモリ消費が定数係数以内に制限されます。</span><span class="sxs-lookup"><span data-stu-id="98d05-174">Also note that `MaxReceivedMessageSize` does not place an upper bound on per-message memory consumption, but limits it to within a constant factor.</span></span> <span data-ttu-id="98d05-175">たとえば、 `MaxReceivedMessageSize` が 1 MB のときに 1 MB のメッセージを受信し、逆シリアル化した場合、逆シリアル化されたオブジェクト グラフを格納するために追加のメモリが必要となるため、メモリの総消費量が 1 MB を超えることになります。</span><span class="sxs-lookup"><span data-stu-id="98d05-175">For example, if the `MaxReceivedMessageSize` is 1 MB and a 1-MB message is received and then deserialized, additional memory is required to contain the deserialized object graph, resulting in total memory consumption well over 1 MB.</span></span> <span data-ttu-id="98d05-176">このため、受信するデータは大きくなくてもメモリ消費量が極端に大きくなるような、シリアル化可能な型は作成しないようにします。</span><span class="sxs-lookup"><span data-stu-id="98d05-176">For this reason, avoid creating serializable types that could result in significant memory consumption without much incoming data.</span></span> <span data-ttu-id="98d05-177">たとえば、50のオプションのデータメンバーフィールドと100プライベートフィールドを含むデータコントラクト "MyContract" は、XML 構築 "" を使用してインスタンス化でき \<MyContract/> ます。</span><span class="sxs-lookup"><span data-stu-id="98d05-177">For example, a data contract "MyContract" with 50 optional data member fields and an additional 100 private fields could be instantiated with the XML construction "\<MyContract/>".</span></span> <span data-ttu-id="98d05-178">この XML は、150 個のフィールドに対応するメモリにアクセスすることになります。</span><span class="sxs-lookup"><span data-stu-id="98d05-178">This XML results in memory being accessed for 150 fields.</span></span> <span data-ttu-id="98d05-179">既定では、このデータ メンバーは省略可能です。</span><span class="sxs-lookup"><span data-stu-id="98d05-179">Note that data members are optional by default.</span></span> <span data-ttu-id="98d05-180">このような型が配列に含まれていると、問題はさらに悪化します。</span><span class="sxs-lookup"><span data-stu-id="98d05-180">The problem is compounded when such a type is part of an array.</span></span>

<span data-ttu-id="98d05-181">`MaxReceivedMessageSize` だけでは、すべてのサービス拒否攻撃を防止できません。</span><span class="sxs-lookup"><span data-stu-id="98d05-181">`MaxReceivedMessageSize` alone is not enough to prevent all denial-of-service attacks.</span></span> <span data-ttu-id="98d05-182">たとえば、受信メッセージによって、デシリアライザーが深く入れ子になったオブジェクト グラフ (オブジェクトに別のオブジェクトが格納され、その別のオブジェクトにさらに別のオブジェクトが格納されているということが繰り返されているオブジェクト) を逆シリアル化することを強制される場合があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-182">For example, the deserializer may be forced to deserialize a deeply-nested object graph (an object that contains another object that contains yet another one, and so on) by an incoming message.</span></span> <span data-ttu-id="98d05-183"><xref:System.Runtime.Serialization.DataContractSerializer> と <xref:System.Xml.Serialization.XmlSerializer> は、このオブジェクト グラフを逆シリアル化するために入れ子形態でメソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="98d05-183">Both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer> call methods in a nested way to deserialize such graphs.</span></span> <span data-ttu-id="98d05-184">メソッド呼び出しがレベルの深い入れ子構造になっていると、回復不可能な <xref:System.StackOverflowException>が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-184">Deep nesting of method calls may result in an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="98d05-185">この脅威は、このトピックの後半の「XML の安全な使用」で説明するように、 <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> クォータを設定して、XML の入れ子レベルを制限することによって軽減できます。</span><span class="sxs-lookup"><span data-stu-id="98d05-185">This threat is mitigated by setting the <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> quota to limit the level of XML nesting, as discussed in the "Using XML Safely" section later in the topic.</span></span>

<span data-ttu-id="98d05-186">バイナリ XML エンコーディングを使用する場合は、追加のクォータを `MaxReceivedMessageSize` に設定することが特に重要です。</span><span class="sxs-lookup"><span data-stu-id="98d05-186">Setting additional quotas to `MaxReceivedMessageSize` is especially important when using binary XML encoding.</span></span> <span data-ttu-id="98d05-187">バイナリ エンコーディングの使用は、圧縮に似ているところがあります。受信メッセージ内の少量のバイトで、大量のデータが表されていることがあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-187">Using binary encoding is somewhat equivalent to compression: a small group of bytes in the incoming message may represent a lot of data.</span></span> <span data-ttu-id="98d05-188">したがって、 `MaxReceivedMessageSize` の制限に収まるメッセージでも、完全に展開された形式では、さらに多くのメモリを消費する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-188">Thus, even a message fitting into the `MaxReceivedMessageSize` limit may take up much more memory in fully expanded form.</span></span> <span data-ttu-id="98d05-189">このような XML 固有の脅威を軽減するには、すべての XML リーダーのクォータを、このトピックの後半の「XML の安全な使用」で説明するとおりに設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-189">To mitigate such XML-specific threats, all of the XML reader quotas must be set correctly, as discussed in the "Using XML Safely" section later in this topic.</span></span>

## <a name="limiting-memory-consumption-with-streaming"></a><span data-ttu-id="98d05-190">メモリ消費の制限 (ストリーミングありの場合)</span><span class="sxs-lookup"><span data-stu-id="98d05-190">Limiting Memory Consumption with Streaming</span></span>

<span data-ttu-id="98d05-191">ストリーミング中、 `MaxReceivedMessageSize` の設定値を小さくすることで、サービス拒否攻撃を防止できます。</span><span class="sxs-lookup"><span data-stu-id="98d05-191">When streaming, you may use a small `MaxReceivedMessageSize` setting to protect against denial-of-service attacks.</span></span> <span data-ttu-id="98d05-192">ただし、ストリーミングを伴う場合、状況が複雑になります。</span><span class="sxs-lookup"><span data-stu-id="98d05-192">However, more complicated scenarios are possible with streaming.</span></span> <span data-ttu-id="98d05-193">たとえば、ファイル アップロード サービスでは使用可能なメモリより大きいファイルが許容されます。</span><span class="sxs-lookup"><span data-stu-id="98d05-193">For example, a file upload service accepts files larger than all available memory.</span></span> <span data-ttu-id="98d05-194">この場合、メモリにバッファーされるデータはほとんどなく、メッセージが直接ディスクにストリーミングされると予測して、 `MaxReceivedMessageSize` を非常に大きな値に設定します。</span><span class="sxs-lookup"><span data-stu-id="98d05-194">In this case, set the `MaxReceivedMessageSize` to an extremely large value, expecting that almost no data is buffered in memory and the message streams directly to disk.</span></span> <span data-ttu-id="98d05-195">悪意のあるメッセージが何らかの方法で、ストリーミングではなくデータをバッファーに格納する場合、は、 `MaxReceivedMessageSize` 使用可能なすべてのメモリにアクセスするメッセージから保護することができなくなります。</span><span class="sxs-lookup"><span data-stu-id="98d05-195">If a malicious message can somehow force WCF to buffer data instead of streaming it in this case, `MaxReceivedMessageSize` no longer protects against the message accessing all available memory.</span></span>

<span data-ttu-id="98d05-196">この脅威を軽減するために、バッファリングを制限するさまざまな WCF データ処理コンポーネントに特定のクォータ設定が存在します。</span><span class="sxs-lookup"><span data-stu-id="98d05-196">To mitigate this threat, specific quota settings exist on various WCF data-processing components that limit buffering.</span></span> <span data-ttu-id="98d05-197">この中で最も重要なのは、複数のトランスポート バインド要素と標準バインディングに存在する `MaxBufferSize` プロパティです。</span><span class="sxs-lookup"><span data-stu-id="98d05-197">The most important of these is the `MaxBufferSize` property on various transport binding elements and standard bindings.</span></span> <span data-ttu-id="98d05-198">ストリーミングを使用する場合は、メッセージごとに割り当て可能なメモリの最大量を考慮して、このクォータを設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-198">When streaming, this quota should be set taking into account the maximum amount of memory you are willing to allocate per message.</span></span> <span data-ttu-id="98d05-199">`MaxReceivedMessageSize`と同様、この設定ではメモリ消費の絶対的な最大値が設定されるのではなく、メモリ消費が定数係数以内に制限されるだけです。</span><span class="sxs-lookup"><span data-stu-id="98d05-199">As with `MaxReceivedMessageSize`, the setting does not put an absolute maximum on memory consumption but only limits it to within a constant factor.</span></span> <span data-ttu-id="98d05-200">また、 `MaxReceivedMessageSize`の場合と同じく、複数のメッセージが同時に処理されている可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-200">Also, as with `MaxReceivedMessageSize`, be aware of the possibility of multiple messages being processed simultaneously.</span></span>

### <a name="maxbuffersize-details"></a><span data-ttu-id="98d05-201">MaxBufferSize の詳細</span><span class="sxs-lookup"><span data-stu-id="98d05-201">MaxBufferSize Details</span></span>

<span data-ttu-id="98d05-202">プロパティは、 `MaxBufferSize` WCF が行うすべての一括バッファリングを制限します。</span><span class="sxs-lookup"><span data-stu-id="98d05-202">The `MaxBufferSize` property limits any bulk buffering WCF does.</span></span> <span data-ttu-id="98d05-203">たとえば、WCF では、常に SOAP ヘッダーと SOAP エラー、およびメッセージ伝送最適化メカニズム (MTOM) メッセージの自然な読み取り順序ではないと検出された MIME パートがバッファーに格納されます。</span><span class="sxs-lookup"><span data-stu-id="98d05-203">For example, WCF always buffers SOAP headers and SOAP faults, as well as any MIME parts found to be not in the natural reading order in an Message Transmission Optimization Mechanism (MTOM) message.</span></span> <span data-ttu-id="98d05-204">この設定では、このようなすべての状況でバッファー量が制限されます。</span><span class="sxs-lookup"><span data-stu-id="98d05-204">This setting limits the amount of buffering in all these cases.</span></span>

<span data-ttu-id="98d05-205">WCF では、バッファーに格納さ `MaxBufferSize` れる可能性のあるさまざまなコンポーネントに値を渡すことによってこれを実現します。</span><span class="sxs-lookup"><span data-stu-id="98d05-205">WCF accomplishes this by passing the `MaxBufferSize` value to the various components that may buffer.</span></span> <span data-ttu-id="98d05-206">たとえば、 <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> クラスの一部の <xref:System.ServiceModel.Channels.Message> オーバーロードは、 `maxSizeOfHeaders` パラメーターを受け取ります。</span><span class="sxs-lookup"><span data-stu-id="98d05-206">For example, some <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> overloads of the <xref:System.ServiceModel.Channels.Message> class take a `maxSizeOfHeaders` parameter.</span></span> <span data-ttu-id="98d05-207">WCF は、 `MaxBufferSize` このパラメーターに値を渡して、SOAP ヘッダーのバッファー量を制限します。</span><span class="sxs-lookup"><span data-stu-id="98d05-207">WCF passes the `MaxBufferSize` value to this parameter to limit the amount of SOAP header buffering.</span></span> <span data-ttu-id="98d05-208"><xref:System.ServiceModel.Channels.Message> クラスを直接使用する場合、このパラメーターを設定することが重要です。</span><span class="sxs-lookup"><span data-stu-id="98d05-208">It is important to set this parameter when using the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="98d05-209">一般に、クォータパラメーターを受け取る WCF のコンポーネントを使用する場合は、これらのパラメーターのセキュリティへの影響を理解し、それらを正しく設定することが重要です。</span><span class="sxs-lookup"><span data-stu-id="98d05-209">In general, when using a component in WCF that takes quota parameters, it is important to understand the security implications of these parameters and set them correctly.</span></span>

<span data-ttu-id="98d05-210">MTOM メッセージ エンコーダーには、 `MaxBufferSize` 設定もあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-210">The MTOM message encoder also has a `MaxBufferSize` setting.</span></span> <span data-ttu-id="98d05-211">標準バインディングを使用する場合、この値は自動的にトランスポート レベルの `MaxBufferSize` に設定されます。</span><span class="sxs-lookup"><span data-stu-id="98d05-211">When using standard bindings, this is set automatically to the transport-level `MaxBufferSize` value.</span></span> <span data-ttu-id="98d05-212">ただし、MTOM メッセージ エンコーダーのバインド要素を使用してカスタム バインディングを作成する場合、ストリーミングの使用時には `MaxBufferSize` プロパティを安全な値に設定することが重要です。</span><span class="sxs-lookup"><span data-stu-id="98d05-212">However, when using the MTOM message encoder binding element to construct a custom binding, it is important to set the `MaxBufferSize` property to a safe value when streaming is used.</span></span>

## <a name="xml-based-streaming-attacks"></a><span data-ttu-id="98d05-213">XML ベースのストリーミング攻撃</span><span class="sxs-lookup"><span data-stu-id="98d05-213">XML-Based Streaming Attacks</span></span>

<span data-ttu-id="98d05-214">`MaxBufferSize` だけでは、ストリーミングが予想される場合に WCF を強制的にバッファリングできないようにするだけでは不十分です。</span><span class="sxs-lookup"><span data-stu-id="98d05-214">`MaxBufferSize` alone is not enough to ensure that WCF cannot be forced into buffering when streaming is expected.</span></span> <span data-ttu-id="98d05-215">たとえば、WCF XML リーダーは、新しい要素の読み取りを開始するときに、XML 要素の開始タグ全体を常にバッファーに格納します。</span><span class="sxs-lookup"><span data-stu-id="98d05-215">For example, the WCF XML readers always buffer the entire XML element start tag when starting to read a new element.</span></span> <span data-ttu-id="98d05-216">この処理は、名前空間と属性を適切に処理するために行われます。</span><span class="sxs-lookup"><span data-stu-id="98d05-216">This is done so that namespaces and attributes are properly processed.</span></span> <span data-ttu-id="98d05-217">(たとえば、大きいファイルを直接ディスクにストリーミングするシナリオを可能にする目的で) `MaxReceivedMessageSize` が大きい値に設定されている場合、メッセージの本文全体が大きい XML 要素の開始タグであるような、悪質なメッセージが作成される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-217">If `MaxReceivedMessageSize` is configured to be large (for example, to enable a direct-to-disk large file streaming scenario), a malicious message may be constructed where the entire message body is a large XML element start tag.</span></span> <span data-ttu-id="98d05-218">このメッセージを読み取ろうとすると、 <xref:System.OutOfMemoryException>が発生します。</span><span class="sxs-lookup"><span data-stu-id="98d05-218">An attempt to read it results in an <xref:System.OutOfMemoryException>.</span></span> <span data-ttu-id="98d05-219">これは、xml ベースのサービス拒否攻撃の1つであり、このトピックの後半の「XML の安全な使用」で説明されている xml リーダーのクォータを使用してすべて軽減できます。</span><span class="sxs-lookup"><span data-stu-id="98d05-219">This is one of many possible XML-based denial-of-service attacks that can all be mitigated using XML reader quotas, discussed in the "Using XML Safely" section later in this topic.</span></span> <span data-ttu-id="98d05-220">ストリーミングを使用する場合、これらのクォータをすべて設定することが特に重要です。</span><span class="sxs-lookup"><span data-stu-id="98d05-220">When streaming, it is especially important to set all of these quotas.</span></span>

### <a name="mixing-streaming-and-buffering-programming-models"></a><span data-ttu-id="98d05-221">ストリーミングとバッファー プログラミング モデルの混在</span><span class="sxs-lookup"><span data-stu-id="98d05-221">Mixing Streaming and Buffering Programming Models</span></span>

<span data-ttu-id="98d05-222">攻撃の多くは、同じサービス内にストリーミングとストリーミング以外のプログラミング モデルを混在させることによって発生することが考えられます。</span><span class="sxs-lookup"><span data-stu-id="98d05-222">Many possible attacks arise from mixing streaming and non-streaming programming models in the same service.</span></span> <span data-ttu-id="98d05-223">2 つの操作が設定されたサービス コントラクトがあるとします。一方は <xref:System.IO.Stream> を使用し、他方はカスタム型の配列を使用します。</span><span class="sxs-lookup"><span data-stu-id="98d05-223">Suppose there is a service contract with two operations: one takes a <xref:System.IO.Stream> and another takes an array of some custom type.</span></span> <span data-ttu-id="98d05-224">また、1 つ目の操作で、大きいストリームを処理できるように、 `MaxReceivedMessageSize` が大きい値に設定されているとします。</span><span class="sxs-lookup"><span data-stu-id="98d05-224">Suppose also that `MaxReceivedMessageSize` is set to a large value to enable the first operation to process large streams.</span></span> <span data-ttu-id="98d05-225">この場合、大きいメッセージを 2 つ目の操作でも受け取れることになってしまいます。デシリアライザーは、操作が呼び出される前にデータを配列としてメモリにバッファー化します。</span><span class="sxs-lookup"><span data-stu-id="98d05-225">Unfortunately, this means that large messages can now be sent to the second operation as well, and the deserializer buffers data in memory as an array before the operation is called.</span></span> <span data-ttu-id="98d05-226">この状況では、サービス拒否攻撃が発生する可能性があります。 `MaxBufferSize` クォータでは、メッセージ本文のサイズ、つまり、デシリアライザーが処理するデータのサイズは制限できません。</span><span class="sxs-lookup"><span data-stu-id="98d05-226">This is a potential denial-of-service attack: the `MaxBufferSize` quota does not limit the size of the message body, which is what the deserializer works with.</span></span>

<span data-ttu-id="98d05-227">このため、同じコントラクトにストリーム ベースの操作とストリーム以外の操作を混合しないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="98d05-227">For this reason, avoid mixing stream-based and non-streamed operations in the same contract.</span></span> <span data-ttu-id="98d05-228">この 2 つのプログラミング モデルを混合する必要がある場合は、次の予防策を使用します。</span><span class="sxs-lookup"><span data-stu-id="98d05-228">If you absolutely must mix the two programming models, use the following precautions:</span></span>

- <span data-ttu-id="98d05-229"><xref:System.Runtime.Serialization.IExtensibleDataObject> の <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> プロパティを <xref:System.ServiceModel.ServiceBehaviorAttribute> に設定して、 `true`機能を無効にします。</span><span class="sxs-lookup"><span data-stu-id="98d05-229">Turn off the <xref:System.Runtime.Serialization.IExtensibleDataObject> feature by setting the <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> property of the <xref:System.ServiceModel.ServiceBehaviorAttribute> to `true`.</span></span> <span data-ttu-id="98d05-230">これによって、コントラクトの一部であるメンバーだけが逆シリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="98d05-230">This ensures that only members that are a part of the contract are deserialized.</span></span>

- <span data-ttu-id="98d05-231"><xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> の <xref:System.Runtime.Serialization.DataContractSerializer> プロパティを安全な値に設定します。</span><span class="sxs-lookup"><span data-stu-id="98d05-231">Set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property of the <xref:System.Runtime.Serialization.DataContractSerializer> to a safe value.</span></span> <span data-ttu-id="98d05-232">このクォータは、 <xref:System.ServiceModel.ServiceBehaviorAttribute> 属性または構成からも操作できます。</span><span class="sxs-lookup"><span data-stu-id="98d05-232">This quota is also available on the <xref:System.ServiceModel.ServiceBehaviorAttribute> attribute or through configuration.</span></span> <span data-ttu-id="98d05-233">このクォータは、1 回の逆シリアル化で逆シリアル化されるオブジェクトの数を制限します。</span><span class="sxs-lookup"><span data-stu-id="98d05-233">This quota limits the number of objects that are deserialized in one deserialization episode.</span></span> <span data-ttu-id="98d05-234">通常、1 回の逆シリアル化で、メッセージ コントラクト内の 1 つの操作パラメーターまたはメッセージ本文が逆シリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="98d05-234">Normally, each operation parameter or message body part in a message contract is deserialized in one episode.</span></span> <span data-ttu-id="98d05-235">配列を逆シリアル化する場合、各配列エントリは個別のオブジェクトとしてカウントされます。</span><span class="sxs-lookup"><span data-stu-id="98d05-235">When deserializing arrays, each array entry is counted as a separate object.</span></span>

- <span data-ttu-id="98d05-236">すべての XML リーダーのクォータを安全な値に設定します。</span><span class="sxs-lookup"><span data-stu-id="98d05-236">Set all of the XML reader quotas to safe values.</span></span> <span data-ttu-id="98d05-237"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>、 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>、および <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> に注意して、ストリーミング以外の操作で文字列の使用を避けます。</span><span class="sxs-lookup"><span data-stu-id="98d05-237">Pay attention to <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>, <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, and <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> and avoid strings in non-streaming operations.</span></span>

- <span data-ttu-id="98d05-238">既知の型のリストを確認し、ここにある型はいつでもインスタンス化が可能であることを覚えておいてください (このトピックの後半の「意図しない型の読み込み防止」を参照)。</span><span class="sxs-lookup"><span data-stu-id="98d05-238">Review the list of known types, keeping in mind that any one of them can be instantiated at any time (see the "Preventing Unintended Types from Being Loaded" section later in this topic).</span></span>

- <span data-ttu-id="98d05-239"><xref:System.Xml.Serialization.IXmlSerializable> インターフェイスを実装して大量のデータをバッファー化する型は使用しないようにします。</span><span class="sxs-lookup"><span data-stu-id="98d05-239">Do not use any types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface that buffer a lot of data.</span></span> <span data-ttu-id="98d05-240">このような型は既知の型のリストに追加しないでください。</span><span class="sxs-lookup"><span data-stu-id="98d05-240">Do not add such types to the list of known types.</span></span>

- <span data-ttu-id="98d05-241"><xref:System.Xml.XmlElement>、 <xref:System.Xml.XmlNode> 、 <xref:System.Byte> の各配列や、 <xref:System.Runtime.Serialization.ISerializable> を実装する型をコントラクトで使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="98d05-241">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in a contract.</span></span>

- <span data-ttu-id="98d05-242"><xref:System.Xml.XmlElement>、 <xref:System.Xml.XmlNode> 、 <xref:System.Byte> の各配列や、 <xref:System.Runtime.Serialization.ISerializable> を実装する型は、既知の型のリストで使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="98d05-242">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in the list of known types.</span></span>

<span data-ttu-id="98d05-243">前述の予防策は、ストリーミング以外の操作で <xref:System.Runtime.Serialization.DataContractSerializer>を使用する場合に適用できます。</span><span class="sxs-lookup"><span data-stu-id="98d05-243">The preceding precautions apply when the non-streamed operation uses the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="98d05-244"><xref:System.Xml.Serialization.XmlSerializer>を使用している場合、これには <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> クォータによる保護がないので、同じサービスにストリーミングとストリーミング以外のプログラミング モデルを絶対に混在させないでください。</span><span class="sxs-lookup"><span data-stu-id="98d05-244">Never mix streaming and non-streaming programming models on the same service if you are using the <xref:System.Xml.Serialization.XmlSerializer>, because it does not have the protection of the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> quota.</span></span>

### <a name="slow-stream-attacks"></a><span data-ttu-id="98d05-245">遅いストリームによる攻撃</span><span class="sxs-lookup"><span data-stu-id="98d05-245">Slow Stream Attacks</span></span>

<span data-ttu-id="98d05-246">ストリーミング サービス拒否攻撃では、メモリ消費は発生しません。</span><span class="sxs-lookup"><span data-stu-id="98d05-246">A class of streaming denial-of-service attacks does not involve memory consumption.</span></span> <span data-ttu-id="98d05-247">代わりに、この攻撃では送信側または受信側でデータの転送が遅くなります。</span><span class="sxs-lookup"><span data-stu-id="98d05-247">Instead, the attack involves a slow sender or receiver of data.</span></span> <span data-ttu-id="98d05-248">データが送信または受信されるのを待っている間、スレッドや利用可能な接続などのリソースが消耗します。</span><span class="sxs-lookup"><span data-stu-id="98d05-248">While waiting for the data to be sent or received, resources such as threads and available connections are exhausted.</span></span> <span data-ttu-id="98d05-249">この状況は、悪質な攻撃を受けた結果として、または正当な送信側または受信側が遅いネットワーク接続を使用していることが原因で起こる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-249">This situation could arise either as a result of a malicious attack or from a legitimate sender/receiver on a slow network connection.</span></span>

<span data-ttu-id="98d05-250">この攻撃を軽減するには、トランスポートのタイムアウトを適切に設定します。</span><span class="sxs-lookup"><span data-stu-id="98d05-250">To mitigate these attacks, set the transport time-outs correctly.</span></span> <span data-ttu-id="98d05-251">詳細については、「 [トランスポートクォータ](transport-quotas.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="98d05-251">For more information, see [Transport Quotas](transport-quotas.md).</span></span> <span data-ttu-id="98d05-252">第2に、 `Read` `Write` WCF でストリームを操作するときは、同期または操作を使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="98d05-252">Secondly, never use synchronous `Read` or `Write` operations when working with streams in WCF.</span></span>

## <a name="using-xml-safely"></a><span data-ttu-id="98d05-253">XML の安全な使用</span><span class="sxs-lookup"><span data-stu-id="98d05-253">Using XML Safely</span></span>

> [!NOTE]
> <span data-ttu-id="98d05-254">このセクションは XML に関するものですが、ここに記載された情報は、JSON (JavaScript Object Notation) ドキュメントにも該当します。</span><span class="sxs-lookup"><span data-stu-id="98d05-254">Although this section is about XML, the information also applies to JavaScript Object Notation (JSON) documents.</span></span> <span data-ttu-id="98d05-255">[Mapping Between JSON and XML](mapping-between-json-and-xml.md)を使用することで、クォータは同様に機能します。</span><span class="sxs-lookup"><span data-stu-id="98d05-255">The quotas work similarly, using [Mapping Between JSON and XML](mapping-between-json-and-xml.md).</span></span>

### <a name="secure-xml-readers"></a><span data-ttu-id="98d05-256">セキュリティで保護された XML リーダー</span><span class="sxs-lookup"><span data-stu-id="98d05-256">Secure XML Readers</span></span>

<span data-ttu-id="98d05-257">XML Infoset は、WCF でのすべてのメッセージ処理の基礎を形成します。</span><span class="sxs-lookup"><span data-stu-id="98d05-257">The XML Infoset forms the basis of all message processing in WCF.</span></span> <span data-ttu-id="98d05-258">信頼できない送信元からの XML データを受け入れる場合、多数のサービス拒否攻撃が存在する可能性があり、これを軽減する必要があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-258">When accepting XML data from an untrusted source, a number of denial-of-service attack possibilities exist that must be mitigated.</span></span> <span data-ttu-id="98d05-259">WCF は、特別なセキュリティで保護された XML リーダーを提供します。</span><span class="sxs-lookup"><span data-stu-id="98d05-259">WCF provides special, secure XML readers.</span></span> <span data-ttu-id="98d05-260">これらのリーダーは、WCF の標準エンコーディング (テキスト、バイナリ、MTOM) のいずれかを使用するときに自動的に作成されます。</span><span class="sxs-lookup"><span data-stu-id="98d05-260">These readers are created automatically when using one of the standard encodings in WCF (text, binary, or MTOM).</span></span>

<span data-ttu-id="98d05-261">このリーダーでは、一部のセキュリティ機能が常にアクティブです。</span><span class="sxs-lookup"><span data-stu-id="98d05-261">Some of the security features on these readers are always active.</span></span> <span data-ttu-id="98d05-262">たとえば、このリーダーは文書型定義 (DTD) を処理しません。文書型定義は、サービス拒否攻撃のソースの 1 つになり得るものであり、正当な SOAP メッセージに使用すべきではありません。</span><span class="sxs-lookup"><span data-stu-id="98d05-262">For example, the readers never process document type definitions (DTDs), which are a potential source of denial-of-service attacks and should never appear in legitimate SOAP messages.</span></span> <span data-ttu-id="98d05-263">他のセキュリティ機能としてリーダーのクォータがあり、これらを設定する必要があります。この機能については、次のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="98d05-263">Other security features include reader quotas that must be configured, which are described in the following section.</span></span>

<span data-ttu-id="98d05-264">XML リーダーを直接操作する場合 (独自のカスタムエンコーダーを作成する場合や、クラスを直接操作する場合など <xref:System.ServiceModel.Channels.Message> ) は、信頼されていないデータを処理する可能性がある場合は常に、WCF のセキュリティで保護されたリーダーを使用します。</span><span class="sxs-lookup"><span data-stu-id="98d05-264">When working directly with XML readers (such as when writing your own custom encoder or when working directly with the <xref:System.ServiceModel.Channels.Message> class), always use the WCF secure readers when there is a chance of working with untrusted data.</span></span> <span data-ttu-id="98d05-265">セキュリティで保護されたリーダーは、 <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>クラス上で <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>、 <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> 、または <xref:System.Xml.XmlDictionaryReader> の静的ファクトリ メソッドのオーバーロードのいずれかを呼び出すことによって作成します。</span><span class="sxs-lookup"><span data-stu-id="98d05-265">Create the secure readers by calling one of the static factory method overloads of <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> on the <xref:System.Xml.XmlDictionaryReader> class.</span></span> <span data-ttu-id="98d05-266">リーダーを作成したら、安全なクォータ値を渡します。</span><span class="sxs-lookup"><span data-stu-id="98d05-266">When creating a reader, pass in secure quota values.</span></span> <span data-ttu-id="98d05-267">`Create` メソッドのオーバーロードを呼び出さないでください。</span><span class="sxs-lookup"><span data-stu-id="98d05-267">Do not call the `Create` method overloads.</span></span> <span data-ttu-id="98d05-268">これらの方法では、WCF リーダーは作成されません。</span><span class="sxs-lookup"><span data-stu-id="98d05-268">These do not create a WCF reader.</span></span> <span data-ttu-id="98d05-269">作成されるのは、このセクションで説明したセキュリティ機能で保護されていないリーダーです。</span><span class="sxs-lookup"><span data-stu-id="98d05-269">Instead, a reader is created that is not protected by the security features described in this section.</span></span>

### <a name="reader-quotas"></a><span data-ttu-id="98d05-270">リーダーのクォータ</span><span class="sxs-lookup"><span data-stu-id="98d05-270">Reader Quotas</span></span>

<span data-ttu-id="98d05-271">セキュリティで保護された XML リーダーには、5 つの設定可能なクォータがあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-271">The secure XML readers have five configurable quotas.</span></span> <span data-ttu-id="98d05-272">これらのクォータは通常、標準バインディングまたはエンコーディング バインド要素で `ReaderQuotas` プロパティを使用するか、リーダーの作成時に渡される <xref:System.Xml.XmlDictionaryReaderQuotas> オブジェクトを使用して設定します。</span><span class="sxs-lookup"><span data-stu-id="98d05-272">These are normally configured using the `ReaderQuotas` property on the encoding binding elements or standard bindings, or by using an <xref:System.Xml.XmlDictionaryReaderQuotas> object passed when creating a reader.</span></span>

#### <a name="maxbytesperread"></a><span data-ttu-id="98d05-273">MaxBytesPerRead</span><span class="sxs-lookup"><span data-stu-id="98d05-273">MaxBytesPerRead</span></span>

<span data-ttu-id="98d05-274">このクォータは、要素の開始タグとその属性を読み取るときに、1 回の `Read` 操作で読み取るバイト数を制限します</span><span class="sxs-lookup"><span data-stu-id="98d05-274">This quota limits the number of bytes that are read in a single `Read` operation when reading the element start tag and its attributes.</span></span> <span data-ttu-id="98d05-275">(ストリーミングを使用しない場合、要素名自体がクォータに照らし合わせてカウントされることはありません)。 <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> が重要な理由は、次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="98d05-275">(In non-streamed cases, the element name itself is not counted against the quota.) <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> is important for the following reasons:</span></span>

- <span data-ttu-id="98d05-276">要素名とその属性は、読み取り時に必ずメモリ内でバッファー化されます。</span><span class="sxs-lookup"><span data-stu-id="98d05-276">The element name and its attributes are always buffered in memory when they are being read.</span></span> <span data-ttu-id="98d05-277">このため、ストリーミングが予想されるときにこのクォータをストリーミング モードで適切に設定して、過度のバッファーを防止することが重要です。</span><span class="sxs-lookup"><span data-stu-id="98d05-277">Therefore, it is important to set this quota correctly in streaming mode to prevent excessive buffering when streaming is expected.</span></span> <span data-ttu-id="98d05-278">実行されるバッファリングの実際の量については、 `MaxDepth` クォータのセクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="98d05-278">See the `MaxDepth` quota section for information about the actual amount of buffering that takes place.</span></span>

- <span data-ttu-id="98d05-279">XML 属性が多すぎると、属性名は一意かどうかを確認する必要があるため、処理時間が大幅に増加する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-279">Having too many XML attributes may use up disproportionate processing time because attribute names have to be checked for uniqueness.</span></span> <span data-ttu-id="98d05-280">`MaxBytesPerRead` によってこの脅威を軽減できます。</span><span class="sxs-lookup"><span data-stu-id="98d05-280">`MaxBytesPerRead` mitigates this threat.</span></span>

#### <a name="maxdepth"></a><span data-ttu-id="98d05-281">MaxDepth</span><span class="sxs-lookup"><span data-stu-id="98d05-281">MaxDepth</span></span>

<span data-ttu-id="98d05-282">このクォータは、XML 要素の入れ子の深さの最大値を制限します。</span><span class="sxs-lookup"><span data-stu-id="98d05-282">This quota limits the maximum nesting depth of XML elements.</span></span> <span data-ttu-id="98d05-283">たとえば、ドキュメント "" の \<A> \<B> \<C/> \</B> \</A> 入れ子の深さは3です。</span><span class="sxs-lookup"><span data-stu-id="98d05-283">For example, the document "\<A>\<B>\<C/>\</B>\</A>" has a nesting depth of three.</span></span> <span data-ttu-id="98d05-284"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> が重要な理由は、次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="98d05-284"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> is important for the following reasons:</span></span>

- <span data-ttu-id="98d05-285">`MaxDepth` は `MaxBytesPerRead`と相互に関係しています。リーダーは常に、現在の要素とそのすべての先祖に関するデータをメモリ内に維持します。このため、リーダーのメモリ消費の最大値は、この 2 つの設定値の積に比例します。</span><span class="sxs-lookup"><span data-stu-id="98d05-285">`MaxDepth` interacts with `MaxBytesPerRead`: the reader always keeps data in memory for the current element and all of its ancestors, so the maximum memory consumption of the reader is proportional to the product of these two settings.</span></span>

- <span data-ttu-id="98d05-286">深く入れ子になったオブジェクト グラフを逆シリアル化する場合、デシリアライザーはスタック全体にアクセスし、回復不可能な <xref:System.StackOverflowException>をスローするしかありません。</span><span class="sxs-lookup"><span data-stu-id="98d05-286">When deserializing a deeply-nested object graph, the deserializer is forced to access the entire stack and throw an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="98d05-287"><xref:System.Runtime.Serialization.DataContractSerializer> の場合も <xref:System.Xml.Serialization.XmlSerializer>の場合も、XML の入れ子構造とオブジェクトの入れ子構造との間に直接的な相関関係が存在します。</span><span class="sxs-lookup"><span data-stu-id="98d05-287">A direct correlation exists between XML nesting and object nesting for both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="98d05-288">この脅威を軽減するには、 `MaxDepth` を使用します。</span><span class="sxs-lookup"><span data-stu-id="98d05-288">Use `MaxDepth` to mitigate this threat.</span></span>

#### <a name="maxnametablecharcount"></a><span data-ttu-id="98d05-289">MaxNameTableCharCount</span><span class="sxs-lookup"><span data-stu-id="98d05-289">MaxNameTableCharCount</span></span>

<span data-ttu-id="98d05-290">このクォータは、リーダーの *nametable* のサイズを制限します。</span><span class="sxs-lookup"><span data-stu-id="98d05-290">This quota limits the size of the reader’s *nametable*.</span></span> <span data-ttu-id="98d05-291">nametable には、XML ドキュメントを処理するときに出現する特定の文字列 (名前空間やプレフィックスなど) が入っています。</span><span class="sxs-lookup"><span data-stu-id="98d05-291">The nametable contains certain strings (such as namespaces and prefixes) that are encountered when processing an XML document.</span></span> <span data-ttu-id="98d05-292">この文字列はメモリ内でバッファー化されるので、ストリーミングが予想されるときは、このクォータを設定して過度のバッファーを防止します。</span><span class="sxs-lookup"><span data-stu-id="98d05-292">As these strings are buffered in memory, set this quota to prevent excessive buffering when streaming is expected.</span></span>

#### <a name="maxstringcontentlength"></a><span data-ttu-id="98d05-293">MaxStringContentLength</span><span class="sxs-lookup"><span data-stu-id="98d05-293">MaxStringContentLength</span></span>

<span data-ttu-id="98d05-294">このクォータは、XML リーダーが返す文字列の最大サイズを制限します。</span><span class="sxs-lookup"><span data-stu-id="98d05-294">This quota limits the maximum string size that the XML reader returns.</span></span> <span data-ttu-id="98d05-295">このクォータは、XML リーダー自体のメモリ消費は制限しませんが、このリーダーを使用するコンポーネントのメモリ消費を制限します。</span><span class="sxs-lookup"><span data-stu-id="98d05-295">This quota does not limit memory consumption in the XML reader itself, but in the component that is using the reader.</span></span> <span data-ttu-id="98d05-296">たとえば、 <xref:System.Runtime.Serialization.DataContractSerializer> が <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>でセキュリティ保護されたリーダーを使用するときは、このクォータを超える文字列を逆シリアル化することはありません。</span><span class="sxs-lookup"><span data-stu-id="98d05-296">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, it does not deserialize strings larger than this quota.</span></span> <span data-ttu-id="98d05-297"><xref:System.Xml.XmlDictionaryReader> クラスを直接使用すると、すべてのメソッドではなく、文字列を読み取ることを目的としたメソッド ( <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> メソッドなど) だけがこのクォータに従います。</span><span class="sxs-lookup"><span data-stu-id="98d05-297">When using the <xref:System.Xml.XmlDictionaryReader> class directly, not all methods respect this quota, but only the methods that are specifically designed to read strings, such as the <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> method.</span></span> <span data-ttu-id="98d05-298">リーダー上の <xref:System.Xml.XmlReader.Value%2A> プロパティはこのクォータの影響を受けないので、このクォータによる保護が必要な場合はこのプロパティを使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="98d05-298">The <xref:System.Xml.XmlReader.Value%2A> property on the reader is not affected by this quota, and thus should not be used when the protection this quota provides is necessary.</span></span>

#### <a name="maxarraylength"></a><span data-ttu-id="98d05-299">MaxArrayLength</span><span class="sxs-lookup"><span data-stu-id="98d05-299">MaxArrayLength</span></span>

<span data-ttu-id="98d05-300">このクォータは、XML リーダーが返すプリミティブ配列 (バイト配列など) の最大サイズを制限します。</span><span class="sxs-lookup"><span data-stu-id="98d05-300">This quota limits the maximum size of an array of primitives that the XML reader returns, including byte arrays.</span></span> <span data-ttu-id="98d05-301">このクォータは、XML リーダー自体のメモリ消費は制限しませんが、このリーダーを使用するコンポーネントのメモリ消費を制限します。</span><span class="sxs-lookup"><span data-stu-id="98d05-301">This quota does not limit memory consumption in the XML reader itself, but in whatever component that is using the reader.</span></span> <span data-ttu-id="98d05-302">たとえば、 <xref:System.Runtime.Serialization.DataContractSerializer> が <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>でセキュリティ保護されたリーダーを使用するときは、このクォータを超えるバイト配列を逆シリアル化することはありません。</span><span class="sxs-lookup"><span data-stu-id="98d05-302">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>, it does not deserialize byte arrays larger than this quota.</span></span> <span data-ttu-id="98d05-303">1 つのコントラクトでストリーミングとバッファー プログラミング モデルを混合する場合は、このクォータを設定することが重要です。</span><span class="sxs-lookup"><span data-stu-id="98d05-303">It is important to set this quota when attempting to mix streaming and buffered programming models in a single contract.</span></span> <span data-ttu-id="98d05-304"><xref:System.Xml.XmlDictionaryReader> クラスを直接使用すると、特定のプリミティブ型の任意のサイズの配列を読み取ることを目的としたメソッド ( <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>メソッドなど) だけがこのクォータに従います。</span><span class="sxs-lookup"><span data-stu-id="98d05-304">Keep in mind that when using the <xref:System.Xml.XmlDictionaryReader> class directly, only the methods that are specifically designed to read arrays of arbitrary size of certain primitive types, such as <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>, respect this quota.</span></span>

## <a name="threats-specific-to-the-binary-encoding"></a><span data-ttu-id="98d05-305">バイナリ エンコーディングに固有の脅威</span><span class="sxs-lookup"><span data-stu-id="98d05-305">Threats Specific to the Binary Encoding</span></span>

<span data-ttu-id="98d05-306">WCF でサポートされるバイナリ XML エンコーディングには、 *ディクショナリ文字列* 機能が含まれています。</span><span class="sxs-lookup"><span data-stu-id="98d05-306">The binary XML encoding WCF supports includes a *dictionary strings* feature.</span></span> <span data-ttu-id="98d05-307">長い文字列をわずかなバイト数でエンコードすることができます。</span><span class="sxs-lookup"><span data-stu-id="98d05-307">A large string may be encoded using only a few bytes.</span></span> <span data-ttu-id="98d05-308">これによって、パフォーマンスは大幅に向上しますが、新たなサービス拒否攻撃の脅威を招き、その対策が必要になります。</span><span class="sxs-lookup"><span data-stu-id="98d05-308">This enables significant performance gains, but introduces new denial-of-service threats that must be mitigated.</span></span>

<span data-ttu-id="98d05-309">ディクショナリには、 *静的ディクショナリ* と *動的ディクショナリ* の 2 種類があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-309">There are two kinds of dictionaries: *static* and *dynamic*.</span></span> <span data-ttu-id="98d05-310">静的ディクショナリは、バイナリ エンコーディングで短いコードを使用して表現できる長い文字列の組み込みリストです。</span><span class="sxs-lookup"><span data-stu-id="98d05-310">The static dictionary is a built-in list of long strings that may be represented using a short code in the binary encoding.</span></span> <span data-ttu-id="98d05-311">この文字列のリストは、リーダーの作成時に固定され、変更できません。</span><span class="sxs-lookup"><span data-stu-id="98d05-311">This list of strings is fixed when the reader is created and cannot be modified.</span></span> <span data-ttu-id="98d05-312">WCF が既定で使用する静的ディクショナリ内の文字列は、重大なサービス拒否攻撃の脅威をもたらすために十分な大きさではありませんが、ディクショナリ拡張攻撃でも使用される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-312">None of the strings in the static dictionary that WCF uses by default are sufficiently large to pose a serious denial-of-service threat, although they may still be used in a dictionary expansion attack.</span></span> <span data-ttu-id="98d05-313">独自の静的ディクショナリを使用する高度なシナリオでは、長いディクショナリ文字列を追加するときに注意が必要です。</span><span class="sxs-lookup"><span data-stu-id="98d05-313">In advanced scenarios where you supply your own static dictionary, be careful when introducing large dictionary strings.</span></span>

<span data-ttu-id="98d05-314">動的ディクショナリ機能では、メッセージで独自の文字列を定義し、その文字列を短いコードに関連付けることができます。</span><span class="sxs-lookup"><span data-stu-id="98d05-314">The dynamic dictionaries feature allows messages to define their own strings and associate them with short codes.</span></span> <span data-ttu-id="98d05-315">この文字列とコードのマッピングは、通信セッション中にメモリに格納されるので、後続のメッセージは文字列を再送信する必要がなく、既に定義されているコードを利用できます。</span><span class="sxs-lookup"><span data-stu-id="98d05-315">These string-to-code mappings are kept in memory during the entire communication session, such that subsequent messages do not have to resend the strings and can utilize codes that are already defined.</span></span> <span data-ttu-id="98d05-316">この文字列は、任意の長さになるので、静的ディクショナリの場合よりも重大な脅威を招く可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-316">These strings may be of arbitrary length and thus pose a more serious threat than those in the static dictionary.</span></span>

<span data-ttu-id="98d05-317">軽減する必要がある第 1 の脅威は、動的ディクショナリ (文字列とコードのマッピング テーブル) が大きくなりすぎる可能性です。</span><span class="sxs-lookup"><span data-stu-id="98d05-317">The first threat that must be mitigated is the possibility of the dynamic dictionary (the string-to-code mapping table) becoming too large.</span></span> <span data-ttu-id="98d05-318">このディクショナリは、複数のメッセージを処理するうちに拡大する可能性があります。`MaxReceivedMessageSize` クォータは各メッセージに個別に適用されるだけなので、このクォータで保護することはできません。</span><span class="sxs-lookup"><span data-stu-id="98d05-318">This dictionary may be expanded over the course of several messages, and so the `MaxReceivedMessageSize` quota offers no protection because it applies only to each message separately.</span></span> <span data-ttu-id="98d05-319">このため、 <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> にはディクショナリのサイズを制限する個別の <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> プロパティがあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-319">Therefore, a separate <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> property exists on the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> that limits the size of the dictionary.</span></span>

<span data-ttu-id="98d05-320">他のほとんどのクォータと異なり、このクォータはメッセージの書き込み時にも適用されます。</span><span class="sxs-lookup"><span data-stu-id="98d05-320">Unlike most other quotas, this quota also applies when writing messages.</span></span> <span data-ttu-id="98d05-321">メッセージの読み取り時にこのクォータを超えた場合は、 `QuotaExceededException` が通常どおりスローされます。</span><span class="sxs-lookup"><span data-stu-id="98d05-321">If it is exceeded when reading a message, the `QuotaExceededException` is thrown as usual.</span></span> <span data-ttu-id="98d05-322">メッセージの書き込み時にこのクォータを超えた場合は、クォータの超過を引き起こす文字列はそのまま書き込まれますが、動的ディクショナリ機能は使用されません。</span><span class="sxs-lookup"><span data-stu-id="98d05-322">If it is exceeded when writing a message, any strings that cause the quota to be exceeded are written as-is, without using the dynamic dictionaries feature.</span></span>

### <a name="dictionary-expansion-threats"></a><span data-ttu-id="98d05-323">ディクショナリ拡大攻撃</span><span class="sxs-lookup"><span data-stu-id="98d05-323">Dictionary Expansion Threats</span></span>

<span data-ttu-id="98d05-324">重大なバイナリ固有の攻撃は、ディクショナリの拡大が原因で発生します。</span><span class="sxs-lookup"><span data-stu-id="98d05-324">A significant class of binary-specific attacks arises from dictionary expansion.</span></span> <span data-ttu-id="98d05-325">文字列ディクショナリ機能を利用した場合、バイナリ形式の小さいメッセージが、完全に展開されたテキスト形式では非常に大きいメッセージになることがあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-325">A small message in binary form may turn into a very large message in fully expanded textual form if it makes extensive use of the string dictionaries feature.</span></span> <span data-ttu-id="98d05-326">動的ディクショナリの文字列がディクショナリ全体の最大サイズを超えることはないため、動的ディクショナリの文字列の拡大要因は、 <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> クォータで制限できます。</span><span class="sxs-lookup"><span data-stu-id="98d05-326">The expansion factor for dynamic dictionary strings is limited by the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> quota, because no dynamic dictionary string exceeds the maximum size of the entire dictionary.</span></span>

<span data-ttu-id="98d05-327"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>、 `MaxStringContentLength`、および `MaxArrayLength` の各プロパティで制限されるのは、メモリ消費だけです。</span><span class="sxs-lookup"><span data-stu-id="98d05-327">The <xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>, `MaxStringContentLength`, and `MaxArrayLength` properties only limit memory consumption.</span></span> <span data-ttu-id="98d05-328">メモリ使用量は `MaxReceivedMessageSize`によって既に制限されているため、通常、ストリーミングを使用しない状況で脅威を軽減するためにこれらのプロパティを使用する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="98d05-328">They are normally not required to mitigate any threats in the non-streamed usage because memory usage is already limited by `MaxReceivedMessageSize`.</span></span> <span data-ttu-id="98d05-329">ただし、 `MaxReceivedMessageSize` では、展開前のバイト数がカウントされます。</span><span class="sxs-lookup"><span data-stu-id="98d05-329">However, `MaxReceivedMessageSize` counts pre-expansion bytes.</span></span> <span data-ttu-id="98d05-330">バイナリ エンコーディングを使用しているとき、メモリ消費は、 `MaxReceivedMessageSize`という因数によってのみ制限される、 <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>を超える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-330">When binary encoding is in use, memory consumption could potentially go beyond `MaxReceivedMessageSize`, limited only by a factor of <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>.</span></span> <span data-ttu-id="98d05-331">このため、バイナリ エンコーディングを使用するときはすべてのリーダーのクォータ (特に <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>) を必ず設定することが重要です。</span><span class="sxs-lookup"><span data-stu-id="98d05-331">For this reason, it is important to always set all of the reader quotas (especially <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>) when using the binary encoding.</span></span>

<span data-ttu-id="98d05-332"><xref:System.Runtime.Serialization.DataContractSerializer>と共にバイナリ エンコーディングを使用する場合、 `IExtensibleDataObject` インターフェイスを誤用して、ディクショナリ拡大攻撃を引き起こす可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-332">When using binary encoding together with the <xref:System.Runtime.Serialization.DataContractSerializer>, the `IExtensibleDataObject` interface can be misused to mount a dictionary expansion attack.</span></span> <span data-ttu-id="98d05-333">このインターフェイスは、コントラクトの一部でない任意のデータに対して無制限のストレージを提供します。</span><span class="sxs-lookup"><span data-stu-id="98d05-333">This interface essentially provides unlimited storage for arbitrary data that is not a part of the contract.</span></span> <span data-ttu-id="98d05-334">`MaxSessionSize` に `MaxReceivedMessageSize` を掛けた値によって問題が起こらない程度に低くクォータを設定できない場合は、バイナリ エンコーディングを使用するときに `IExtensibleDataObject` 機能を無効にします。</span><span class="sxs-lookup"><span data-stu-id="98d05-334">If quotas cannot be set low enough such that `MaxSessionSize` multiplied by `MaxReceivedMessageSize` does not pose a problem, disable the `IExtensibleDataObject` feature when using the binary encoding.</span></span> <span data-ttu-id="98d05-335">`IgnoreExtensionDataObject` 属性では `true` プロパティを `ServiceBehaviorAttribute` に設定します。</span><span class="sxs-lookup"><span data-stu-id="98d05-335">Set the `IgnoreExtensionDataObject` property to `true` on the `ServiceBehaviorAttribute` attribute.</span></span> <span data-ttu-id="98d05-336">または `IExtensibleDataObject` インターフェイスを実装しないという方法もあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-336">Alternatively, do not implement the `IExtensibleDataObject` interface.</span></span> <span data-ttu-id="98d05-337">詳細については、「[上位互換性のあるデータ コントラクト](forward-compatible-data-contracts.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="98d05-337">For more information, see [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md).</span></span>

### <a name="quotas-summary"></a><span data-ttu-id="98d05-338">クォータの概要</span><span class="sxs-lookup"><span data-stu-id="98d05-338">Quotas Summary</span></span>

<span data-ttu-id="98d05-339">次の表では、クォータを使用するときのヒントを示します。</span><span class="sxs-lookup"><span data-stu-id="98d05-339">The following table summarizes the guidance about quotas.</span></span>

|<span data-ttu-id="98d05-340">条件</span><span class="sxs-lookup"><span data-stu-id="98d05-340">Condition</span></span>|<span data-ttu-id="98d05-341">設定が重要なクォータ</span><span class="sxs-lookup"><span data-stu-id="98d05-341">Important quotas to set</span></span>|
|---------------|-----------------------------|
|<span data-ttu-id="98d05-342">ストリーミングのない、またはストリーミングのある小さいメッセージ、テキスト、MTOM エンコーディング</span><span class="sxs-lookup"><span data-stu-id="98d05-342">No streaming or streaming small messages, text, or MTOM encoding</span></span>|<span data-ttu-id="98d05-343">`MaxReceivedMessageSize`、`MaxBytesPerRead`、`MaxDepth`</span><span class="sxs-lookup"><span data-stu-id="98d05-343">`MaxReceivedMessageSize`, `MaxBytesPerRead`, and `MaxDepth`</span></span>|
|<span data-ttu-id="98d05-344">ストリーミングのない、またはストリーミングのある小さいメッセージ、バイナリ エンコーディング</span><span class="sxs-lookup"><span data-stu-id="98d05-344">No streaming or streaming small messages, binary encoding</span></span>|<span data-ttu-id="98d05-345">`MaxReceivedMessageSize`、 `MaxSessionSize`、およびすべての `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="98d05-345">`MaxReceivedMessageSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|
|<span data-ttu-id="98d05-346">大きいストリーミング メッセージ、テキスト、MTOM エンコーディング</span><span class="sxs-lookup"><span data-stu-id="98d05-346">Streaming large messages, text, or MTOM encoding</span></span>|<span data-ttu-id="98d05-347">`MaxBufferSize` およびすべての `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="98d05-347">`MaxBufferSize` and all `ReaderQuotas`</span></span>|
|<span data-ttu-id="98d05-348">大きいストリーミング メッセージ、バイナリ エンコーディング</span><span class="sxs-lookup"><span data-stu-id="98d05-348">Streaming large messages, binary encoding</span></span>|<span data-ttu-id="98d05-349">`MaxBufferSize`、 `MaxSessionSize`、およびすべての `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="98d05-349">`MaxBufferSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|

- <span data-ttu-id="98d05-350">トランスポート レベルのタイムアウトを常に設定する必要があります。ストリーミングを使用するときは、ストリーミングするメッセージが大きいか小さいかに関係なく、同期読み取りと書き込みを使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="98d05-350">Transport-level time-outs must always be set and never use synchronous reads/writes when streaming is in use, regardless of whether you are streaming large or small messages.</span></span>

- <span data-ttu-id="98d05-351">クォータについて確信がない場合は、そのクォータを未決定のままにするのではなく、安全な値を設定します。</span><span class="sxs-lookup"><span data-stu-id="98d05-351">When in doubt about a quota, set it to a safe value rather than leaving it open.</span></span>

## <a name="preventing-malicious-code-execution"></a><span data-ttu-id="98d05-352">悪質なコードの実行の防止</span><span class="sxs-lookup"><span data-stu-id="98d05-352">Preventing Malicious Code Execution</span></span>

<span data-ttu-id="98d05-353">主に、次の種類の脅威が、コードを実行し、意図しない結果をもたらす可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-353">The following general classes of threats can execute code and have unintended effects:</span></span>

- <span data-ttu-id="98d05-354">デシリアライザーが、悪質、安全でない、またはセキュリティに注意する必要がある型を読み込んでしまう。</span><span class="sxs-lookup"><span data-stu-id="98d05-354">The deserializer loads a malicious, unsafe, or security-sensitive type.</span></span>

- <span data-ttu-id="98d05-355">受信メッセージが原因で、デシリアライザーが通常は安全な型のインスタンスを作成する際に、意図しない結果を引き起こすようなインスタンスが生成されてしまう。</span><span class="sxs-lookup"><span data-stu-id="98d05-355">An incoming message causes the deserializer to construct an instance of a normally safe type in such a way that it has unintended consequences.</span></span>

<span data-ttu-id="98d05-356">次の各セクションで、これらの種類の脅威について詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="98d05-356">The following sections discuss these classes of threats further.</span></span>

## <a name="datacontractserializer"></a><span data-ttu-id="98d05-357">DataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="98d05-357">DataContractSerializer</span></span>

<span data-ttu-id="98d05-358">(のセキュリティ情報につい <xref:System.Xml.Serialization.XmlSerializer> ては、関連するドキュメントを参照してください。)のセキュリティモデルは、 <xref:System.Xml.Serialization.XmlSerializer> のセキュリティモデルと似ていますが、ほとんどの場合、 <xref:System.Runtime.Serialization.DataContractSerializer> 詳細は異なります。</span><span class="sxs-lookup"><span data-stu-id="98d05-358">(For security information on the <xref:System.Xml.Serialization.XmlSerializer>, see the relevant documentation.) The security model for the <xref:System.Xml.Serialization.XmlSerializer> is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>, and differs mostly in details.</span></span> <span data-ttu-id="98d05-359">たとえば、型を含めるために、 <xref:System.Xml.Serialization.XmlIncludeAttribute> 属性ではなく <xref:System.Runtime.Serialization.KnownTypeAttribute> 属性が使用されます。</span><span class="sxs-lookup"><span data-stu-id="98d05-359">For example, the <xref:System.Xml.Serialization.XmlIncludeAttribute> attribute is used for type inclusion instead of the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute.</span></span> <span data-ttu-id="98d05-360"><xref:System.Xml.Serialization.XmlSerializer> に固有のいくつかの脅威については、このトピックの後半で説明します。</span><span class="sxs-lookup"><span data-stu-id="98d05-360">However, some threats unique to the <xref:System.Xml.Serialization.XmlSerializer> are discussed later in this topic.</span></span>

### <a name="preventing-unintended-types-from-being-loaded"></a><span data-ttu-id="98d05-361">意図しない型の読み込み防止</span><span class="sxs-lookup"><span data-stu-id="98d05-361">Preventing Unintended Types from Being Loaded</span></span>

<span data-ttu-id="98d05-362">意図しない型を読み込むと、その型が悪質である場合も、単にセキュリティに影響するような副作用がある型の場合も、重大な結果を引き起こす可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-362">Loading unintended types may have significant consequences, whether the type is malicious or just has security-sensitive side effects.</span></span> <span data-ttu-id="98d05-363">型は、悪用されやすいセキュリティの脆弱性を含んでいたり、その型のコンストラクターまたはクラス コンストラクターでセキュリティに影響するアクションを実行したりする可能性があります。また、サービス拒否攻撃の実行を容易にしてしまうほどメモリ フットプリントが大きい場合や、回復不可能な例外をスローする場合もあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-363">A type may contain exploitable security vulnerability, perform security-sensitive actions in its constructor or class constructor, have a large memory footprint that facilitates denial-of-service attacks, or may throw non-recoverable exceptions.</span></span> <span data-ttu-id="98d05-364">型には、インスタンスが作成されるよりも前に、その型が読み込まれると直ちに実行されるクラス コンストラクターが用意されている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-364">Types may have class constructors that run as soon as the type is loaded and before any instances are created.</span></span> <span data-ttu-id="98d05-365">これらの理由から、デシリアライザーがどのような型を読み込むかを制御することが重要です。</span><span class="sxs-lookup"><span data-stu-id="98d05-365">For these reasons, it is important to control the set of types that the deserializer may load.</span></span>

<span data-ttu-id="98d05-366"><xref:System.Runtime.Serialization.DataContractSerializer> での逆シリアル化は、疎結合的な方法で行われます。</span><span class="sxs-lookup"><span data-stu-id="98d05-366">The <xref:System.Runtime.Serialization.DataContractSerializer> deserializes in a loosely coupled way.</span></span> <span data-ttu-id="98d05-367">共通言語ランタイム (CLR) 型とアセンブリ名は、受信データから読み取られません。</span><span class="sxs-lookup"><span data-stu-id="98d05-367">It never reads common language runtime (CLR) type and assembly names from the incoming data.</span></span> <span data-ttu-id="98d05-368">これは、 <xref:System.Xml.Serialization.XmlSerializer>の動作と似ていますが、 <xref:System.Runtime.Serialization.NetDataContractSerializer>、 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>、および <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>の動作とは異なります。</span><span class="sxs-lookup"><span data-stu-id="98d05-368">This is similar to the behavior of the <xref:System.Xml.Serialization.XmlSerializer>, but differs from the behavior of the <xref:System.Runtime.Serialization.NetDataContractSerializer>, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>, and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="98d05-369">疎結合的な方法をとることによって、ある程度の安全を確保できます。リモートの攻撃者は、メッセージ内で型の名前を示すだけでは、意図した型が読み込まれるように指定することができません。</span><span class="sxs-lookup"><span data-stu-id="98d05-369">Loose coupling introduces a degree of safety, because the remote attacker cannot indicate an arbitrary type to load just by naming that type in the message.</span></span>

<span data-ttu-id="98d05-370"><xref:System.Runtime.Serialization.DataContractSerializer> は常に、コントラクトに基づいて現在予期される型を読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="98d05-370">The <xref:System.Runtime.Serialization.DataContractSerializer> is always allowed to load a type that is currently expected according to the contract.</span></span> <span data-ttu-id="98d05-371">たとえば、データ コントラクトに `Customer`型のデータ メンバーが含まれている場合、 <xref:System.Runtime.Serialization.DataContractSerializer> は、このデータ メンバーを逆シリアル化するときに `Customer` 型を読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="98d05-371">For example, if a data contract has a data member of type `Customer`, the <xref:System.Runtime.Serialization.DataContractSerializer> is allowed to load the `Customer` type when it deserializes this data member.</span></span>

<span data-ttu-id="98d05-372">また、 <xref:System.Runtime.Serialization.DataContractSerializer> はポリモーフィズムをサポートします。</span><span class="sxs-lookup"><span data-stu-id="98d05-372">Additionally, the <xref:System.Runtime.Serialization.DataContractSerializer> supports polymorphism.</span></span> <span data-ttu-id="98d05-373">データ メンバーを <xref:System.Object>として宣言しておき、受信データに `Customer` インスタンスを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="98d05-373">A data member may be declared as <xref:System.Object>, but the incoming data may contain a `Customer` instance.</span></span> <span data-ttu-id="98d05-374">これが可能なのは、次のいずれかのメカニズムにより、 `Customer` 型がデシリアライザーに対して既知の型になっている場合だけです。</span><span class="sxs-lookup"><span data-stu-id="98d05-374">This is possible only if the `Customer` type has been made "known" to the deserializer through one of these mechanisms:</span></span>

- <span data-ttu-id="98d05-375">型に<xref:System.Runtime.Serialization.KnownTypeAttribute> 属性を適用する。</span><span class="sxs-lookup"><span data-stu-id="98d05-375"><xref:System.Runtime.Serialization.KnownTypeAttribute> attribute applied to a type.</span></span>

- <span data-ttu-id="98d05-376">`KnownTypeAttribute` 属性で、型のリストを返すメソッドを指定する。</span><span class="sxs-lookup"><span data-stu-id="98d05-376">`KnownTypeAttribute` attribute specifying a method that returns a list of types.</span></span>

- <span data-ttu-id="98d05-377">`ServiceKnownTypeAttribute` 属性を使用する。</span><span class="sxs-lookup"><span data-stu-id="98d05-377">`ServiceKnownTypeAttribute` attribute.</span></span>

- <span data-ttu-id="98d05-378">`KnownTypes` 構成セクションを使用する。</span><span class="sxs-lookup"><span data-stu-id="98d05-378">The `KnownTypes` configuration section.</span></span>

- <span data-ttu-id="98d05-379">構築時に <xref:System.Runtime.Serialization.DataContractSerializer> に既知の型のリストを明示的に渡す (シリアライザーを直接使用している場合)。</span><span class="sxs-lookup"><span data-stu-id="98d05-379">A list of known types explicitly passed to the <xref:System.Runtime.Serialization.DataContractSerializer> during construction, if using the serializer directly.</span></span>

<span data-ttu-id="98d05-380">これらのメカニズムを使用すると、デシリアライザーが読み込むことのできる型が追加されるので、攻撃を受け得る表面積は拡大します。</span><span class="sxs-lookup"><span data-stu-id="98d05-380">Each of these mechanisms increases the surface area by introducing more types that the deserializer can load.</span></span> <span data-ttu-id="98d05-381">既知の型リストに、悪質な型または意図しない型が追加されることのないように、これらのメカニズムを制御する必要があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-381">Control each of these mechanisms to ensure no malicious or unintended types are added to the known types list.</span></span>

<span data-ttu-id="98d05-382">型が既知の型リストに追加されると、コントラクトでその型の使用が禁止されている場合でも、その型をいつでも読み込むことができ、その型のインスタンスを作成できるようになります。</span><span class="sxs-lookup"><span data-stu-id="98d05-382">Once a known type is in scope, it can be loaded at any time, and instances of the type can be created, even if the contract forbids actually using it.</span></span> <span data-ttu-id="98d05-383">たとえば、前述のメカニズムのいずれかを使用して "MyDangerousType" という型が既知の型のリストに追加されるとします。</span><span class="sxs-lookup"><span data-stu-id="98d05-383">For example, suppose the type "MyDangerousType" is added to the known types list using one of the mechanisms above.</span></span> <span data-ttu-id="98d05-384">これは、次のことを意味します。</span><span class="sxs-lookup"><span data-stu-id="98d05-384">This means that:</span></span>

- <span data-ttu-id="98d05-385">`MyDangerousType` が読み込まれ、そのクラス コンストラクターが実行されます。</span><span class="sxs-lookup"><span data-stu-id="98d05-385">`MyDangerousType` is loaded and its class constructor runs.</span></span>

- <span data-ttu-id="98d05-386">文字列データ メンバーが指定されたデータ コントラクトを逆シリアル化している場合でも、悪質なメッセージによって `MyDangerousType` のインスタンスが作成される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-386">Even when deserializing a data contract with a string data member, a malicious message may still cause an instance of `MyDangerousType` to create.</span></span> <span data-ttu-id="98d05-387">プロパティの setter など、 `MyDangerousType`のコードが実行される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-387">Code in `MyDangerousType`, such as property setters, may run.</span></span> <span data-ttu-id="98d05-388">その後で、デシリアライザーが文字列データ メンバーにこのインスタンスを割り当てる動作を試行し、例外が発生して失敗します。</span><span class="sxs-lookup"><span data-stu-id="98d05-388">After this is done, the deserializer tries to assign this instance to the string data member and fail with an exception.</span></span>

<span data-ttu-id="98d05-389">既知の型のリストを返すメソッドを作成する場合、またはリストを直接 <xref:System.Runtime.Serialization.DataContractSerializer> コンストラクターに渡す場合は、リストを準備するためのコードをセキュリティで保護し、信頼されたデータだけを操作対象にします。</span><span class="sxs-lookup"><span data-stu-id="98d05-389">When writing a method that returns a list of known types, or when passing a list directly to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor, ensure that the code that prepares the list is secure and operates only on trusted data.</span></span>

<span data-ttu-id="98d05-390">構成で既知の型を指定する場合は、構成ファイルをセキュリティで保護します。</span><span class="sxs-lookup"><span data-stu-id="98d05-390">If specifying known types in configuration, ensure that the configuration file is secure.</span></span> <span data-ttu-id="98d05-391">構成では必ず厳密な名前を使用します (型が含まれている署名付きアセンブリの公開キーを指定します)。ただし、読み込む型のバージョンは指定しないでください。</span><span class="sxs-lookup"><span data-stu-id="98d05-391">Always use strong names in configuration (by specifying the public key of the signed assembly where the type resides), but do not specify the version of the type to load.</span></span> <span data-ttu-id="98d05-392">型ローダーにより、可能であれば最新のバージョンが自動的に選択されます。</span><span class="sxs-lookup"><span data-stu-id="98d05-392">The type loader automatically picks the latest version, if possible.</span></span> <span data-ttu-id="98d05-393">セキュリティの脆弱性を持つ型の場合、その脆弱性が今後のバージョンで修正される可能性があります。しかし、構成でバージョンを明示的に指定していると、脆弱なバージョンが引き続き読み込まれます。構成で特定のバージョンを指定した場合には、このリスクを負うことになります。</span><span class="sxs-lookup"><span data-stu-id="98d05-393">If you specify a particular version in configuration, you run the following risk: A type may have a security vulnerability that may be fixed in a future version, but the vulnerable version still loads because it is explicitly specified in configuration.</span></span>

<span data-ttu-id="98d05-394">既知の型が多すぎると、もう 1 つ問題が生じます。 <xref:System.Runtime.Serialization.DataContractSerializer> は、アプリケーション ドメインでシリアル化コードまたは逆シリアル化コードのキャッシュを作成し、シリアル化または逆シリアル化する必要がある型ごとにエントリを作成します。</span><span class="sxs-lookup"><span data-stu-id="98d05-394">Having too many known types has another consequence: The <xref:System.Runtime.Serialization.DataContractSerializer> creates a cache of serialization/deserialization code in the application domain, with an entry for each type it must serialize and deserialize.</span></span> <span data-ttu-id="98d05-395">このキャッシュは、アプリケーション ドメインの実行中はクリアされません。</span><span class="sxs-lookup"><span data-stu-id="98d05-395">This cache is never cleared as long as the application domain is running.</span></span> <span data-ttu-id="98d05-396">このため、アプリケーションに多くの既知の型が使用されていることを知る攻撃者は、これらの既知の型がすべて逆シリアル化され、キャッシュで大量のメモリが消費されるように仕向けることが可能です。</span><span class="sxs-lookup"><span data-stu-id="98d05-396">Therefore, an attacker who is aware that an application uses many known types can cause the deserialization of all these types, causing the cache to consume a disproportionately large amount of memory.</span></span>

### <a name="preventing-types-from-being-in-an-unintended-state"></a><span data-ttu-id="98d05-397">型の意図しない状態の防止</span><span class="sxs-lookup"><span data-stu-id="98d05-397">Preventing Types from Being in an Unintended State</span></span>

<span data-ttu-id="98d05-398">型には、従う必要がある内部の一貫性に対する制約が存在することがあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-398">A type may have internal consistency constraints that must be enforced.</span></span> <span data-ttu-id="98d05-399">逆シリアル化中にこの制約に違反しないように注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-399">Care must be taken to avoid breaking these constraints during deserialization.</span></span>

<span data-ttu-id="98d05-400">次の型は、宇宙船でのエアロックの状態を表します。この型では、内側のドアと外側のドアを両方同時に開くことはできないという制約が適用されます。</span><span class="sxs-lookup"><span data-stu-id="98d05-400">The following example of a type represents the state of an airlock on a spacecraft, and enforces the constraint that both the inner and the outer doors cannot be open at the same time.</span></span>

[!code-csharp[DataContractAttribute#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#3)]
[!code-vb[DataContractAttribute#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#3)]

<span data-ttu-id="98d05-401">攻撃者は、次のような悪質なメッセージを送信することによってこの制約を迂回し、オブジェクトを無効な状態にする可能性があります。これにより、意図しない予測不可能な結果を招くおそれがあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-401">An attacker may send a malicious message like this, getting around the constraints and getting the object into an invalid state, which may have unintended and unpredictable consequences.</span></span>

```xml
<SpaceStationAirlock>
    <innerDoorOpen>true</innerDoorOpen>
    <outerDoorOpen>true</outerDoorOpen>
</SpaceStationAirlock>
```

<span data-ttu-id="98d05-402">このような状況は、次の点を知っていると防止できます。</span><span class="sxs-lookup"><span data-stu-id="98d05-402">This situation can be avoided by being aware of the following points:</span></span>

- <span data-ttu-id="98d05-403"><xref:System.Runtime.Serialization.DataContractSerializer> で逆シリアル化が行われる際に、ほとんどのクラスで、コンストラクターが実行されません。</span><span class="sxs-lookup"><span data-stu-id="98d05-403">When the <xref:System.Runtime.Serialization.DataContractSerializer> deserializes most classes, constructors do not run.</span></span> <span data-ttu-id="98d05-404">このため、コンストラクターで実行される状態管理には依存できません。</span><span class="sxs-lookup"><span data-stu-id="98d05-404">Therefore, do not rely on any state management done in the constructor.</span></span>

- <span data-ttu-id="98d05-405">コールバックを使用して、オブジェクトを確実に有効な状態にします。</span><span class="sxs-lookup"><span data-stu-id="98d05-405">Use callbacks to ensure that the object is in a valid state.</span></span> <span data-ttu-id="98d05-406"><xref:System.Runtime.Serialization.OnDeserializedAttribute> 属性でマークされたコールバックは、逆シリアル化の完了後に実行され、全体の状態を調査して訂正できるので便利です。</span><span class="sxs-lookup"><span data-stu-id="98d05-406">The callback marked with the <xref:System.Runtime.Serialization.OnDeserializedAttribute> attribute is especially useful because it runs after deserialization is complete and has a chance to examine and correct the overall state.</span></span> <span data-ttu-id="98d05-407">詳細については、「 [バージョントレラントなシリアル化コールバック](version-tolerant-serialization-callbacks.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="98d05-407">For more information, see [Version-Tolerant Serialization Callbacks](version-tolerant-serialization-callbacks.md).</span></span>

- <span data-ttu-id="98d05-408">データ コントラクト型は、プロパティの setter が特定の順序で呼び出されなくてもよいように設計します。</span><span class="sxs-lookup"><span data-stu-id="98d05-408">Do not design data contract types to rely on any particular order in which property setters must be called.</span></span>

- <span data-ttu-id="98d05-409"><xref:System.SerializableAttribute> 属性でマークされた従来の型を使用する場合は十分に注意します。</span><span class="sxs-lookup"><span data-stu-id="98d05-409">Take care using legacy types marked with the <xref:System.SerializableAttribute> attribute.</span></span> <span data-ttu-id="98d05-410">その多くは、信頼できるデータでのみ使用するために .NET Framework リモート処理と連携するように設計されています。</span><span class="sxs-lookup"><span data-stu-id="98d05-410">Many of them were designed to work with .NET Framework remoting for use with trusted data only.</span></span> <span data-ttu-id="98d05-411">この属性でマークされた既存の型は、状態の安全性を考えて設計されていない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-411">Existing types marked with this attribute may not have been designed with state safety in mind.</span></span>

- <span data-ttu-id="98d05-412">状態の安全性に関しては、データの存在を保証するために、 <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> 属性の <xref:System.Runtime.Serialization.DataMemberAttribute> プロパティに依存することはできません。</span><span class="sxs-lookup"><span data-stu-id="98d05-412">Do not rely on the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to guarantee presence of data as far as state safety is concerned.</span></span> <span data-ttu-id="98d05-413">データは常に `null`、 `zero`、または `invalid`になります。</span><span class="sxs-lookup"><span data-stu-id="98d05-413">Data could always be `null`, `zero`, or `invalid`.</span></span>

- <span data-ttu-id="98d05-414">信頼できないデータ ソースから逆シリアル化されたオブジェクト グラフは、検証せずに信頼してはいけません。</span><span class="sxs-lookup"><span data-stu-id="98d05-414">Never trust an object graph deserialized from an untrusted data source without validating it first.</span></span> <span data-ttu-id="98d05-415">各オブジェクトが整合状態にあっても、オブジェクト グラフ全体としては整合状態にない場合があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-415">Each individual object may be in a consistent state, but the object graph as a whole may not be.</span></span> <span data-ttu-id="98d05-416">さらに、オブジェクト グラフの保存モードが無効になっている場合でも、逆シリアル化されたグラフに、同じオブジェクトへの複数の参照または循環参照が存在することがあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-416">Furthermore, even if the object graph preservation mode is disabled, the deserialized graph may have multiple references to the same object or have circular references.</span></span> <span data-ttu-id="98d05-417">詳細については、「 [シリアル化と逆シリアル化](serialization-and-deserialization.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="98d05-417">For more information, see [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

### <a name="using-the-netdatacontractserializer-securely"></a><span data-ttu-id="98d05-418">NetDataContractSerializer の安全な使用</span><span class="sxs-lookup"><span data-stu-id="98d05-418">Using the NetDataContractSerializer Securely</span></span>

<span data-ttu-id="98d05-419"><xref:System.Runtime.Serialization.NetDataContractSerializer> は、型に対して密結合を使用するシリアル化エンジンです。</span><span class="sxs-lookup"><span data-stu-id="98d05-419">The <xref:System.Runtime.Serialization.NetDataContractSerializer> is a serialization engine that uses tight coupling to types.</span></span> <span data-ttu-id="98d05-420">これは、 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> および <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>に類似しています。</span><span class="sxs-lookup"><span data-stu-id="98d05-420">This is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="98d05-421">つまり、受信データから .NET Framework アセンブリと型名を読み取って、インスタンス化する型を決定します。</span><span class="sxs-lookup"><span data-stu-id="98d05-421">That is, it determines which type to instantiate by reading the .NET Framework assembly and type name from the incoming data.</span></span> <span data-ttu-id="98d05-422">これは WCF の一部ですが、このシリアル化エンジンにプラグインする方法は用意されていません。カスタムコードを記述する必要があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-422">Although it is a part of WCF, there is no supplied way of plugging in this serialization engine; custom code must be written.</span></span> <span data-ttu-id="98d05-423">は、 `NetDataContractSerializer` 主に .NET Framework リモート処理から WCF への移行を容易にするために用意されています。</span><span class="sxs-lookup"><span data-stu-id="98d05-423">The `NetDataContractSerializer` is provided primarily to ease migration from .NET Framework remoting to WCF.</span></span> <span data-ttu-id="98d05-424">詳細については、「 [シリアル化と逆シリアル化](serialization-and-deserialization.md)」の関連セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="98d05-424">For more information, see the relevant section in [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

<span data-ttu-id="98d05-425">読み込むことができる型はメッセージ自身が示すことができるため、 <xref:System.Runtime.Serialization.NetDataContractSerializer> のメカニズムは本質的にセキュリティで保護されていません。このエンジンでは、信頼されたデータだけを使用してください。</span><span class="sxs-lookup"><span data-stu-id="98d05-425">Because the message itself may indicate any type can be loaded, the <xref:System.Runtime.Serialization.NetDataContractSerializer> mechanism is inherently insecure and should be used only with trusted data.</span></span> <span data-ttu-id="98d05-426">詳細については、「 [Binaryformatter セキュリティガイド](../../../standard/serialization/binaryformatter-security-guide.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="98d05-426">For more information, see the [BinaryFormatter security guide](../../../standard/serialization/binaryformatter-security-guide.md).</span></span>

<span data-ttu-id="98d05-427">信頼されたデータを使用している場合でも、特に <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> プロパティが <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>に設定されている場合は、読み込む型が受信データで適切に指定されないことがあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-427">Even when used with trusted data, the incoming data may insufficiently specify the type to load, especially if the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property is set to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>.</span></span> <span data-ttu-id="98d05-428">アプリケーションのディレクトリまたはグローバル アセンブリ キャッシュにアクセスできればだれにでも、読み込むべき型の代わりに、悪質な型を配置することができます。</span><span class="sxs-lookup"><span data-stu-id="98d05-428">Anyone with access to the application’s directory or to the global assembly cache can substitute a malicious type in place of the one that is supposed to load.</span></span> <span data-ttu-id="98d05-429">アクセス許可を適切に設定することによって、アプリケーション ディレクトリとグローバル アセンブリ キャッシュのセキュリティを必ず確保してください。</span><span class="sxs-lookup"><span data-stu-id="98d05-429">Always ensure the security of your application’s directory and of the global assembly cache by correctly setting permissions.</span></span>

<span data-ttu-id="98d05-430">通常、部分信頼コードで `NetDataContractSerializer` インスタンスにアクセスしたり、サロゲート セレクター (<xref:System.Runtime.Serialization.ISurrogateSelector>) やシリアル化バインダー (<xref:System.Runtime.Serialization.SerializationBinder>) を制御したりできるようにすると、コードによってシリアル化と逆シリアル化のプロセスが細かく制御される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-430">In general, if you allow partially trusted code access to your `NetDataContractSerializer` instance or otherwise control the surrogate selector (<xref:System.Runtime.Serialization.ISurrogateSelector>) or the serialization binder (<xref:System.Runtime.Serialization.SerializationBinder>), the code may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="98d05-431">たとえば、コードによって任意の型が挿入されたり、情報漏えいにつながったりする場合があります。また、生成されたオブジェクト グラフやシリアル化されたデータが改ざんされたり、生成されたシリアル化ストリームをオーバーフローさせたりする場合もあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-431">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span>

<span data-ttu-id="98d05-432">`NetDataContractSerializer` に関するもう 1 つのセキュリティの問題は、悪質なコードの実行ではなく、サービス拒否攻撃です。</span><span class="sxs-lookup"><span data-stu-id="98d05-432">Another security concern with the `NetDataContractSerializer` is a denial of service, not a malicious code execution threat.</span></span> <span data-ttu-id="98d05-433">`NetDataContractSerializer`を使用する場合は、必ず <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> クォータを安全な値に設定してください。</span><span class="sxs-lookup"><span data-stu-id="98d05-433">When using the `NetDataContractSerializer`, always set the <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> quota to a safe value.</span></span> <span data-ttu-id="98d05-434">サイズがこのクォータでしか制限されないようなオブジェクトであれば、そのオブジェクトの配列を割り当てるための悪質な小さいメッセージを作成することは容易です。</span><span class="sxs-lookup"><span data-stu-id="98d05-434">It is easy to construct a small malicious message that allocates an array of objects whose size is limited only by this quota.</span></span>

### <a name="xmlserializer-specific-threats"></a><span data-ttu-id="98d05-435">XmlSerializer 固有の脅威</span><span class="sxs-lookup"><span data-stu-id="98d05-435">XmlSerializer-Specific Threats</span></span>

<span data-ttu-id="98d05-436"><xref:System.Xml.Serialization.XmlSerializer> のセキュリティ モデルは、 <xref:System.Runtime.Serialization.DataContractSerializer>のセキュリティ モデルに似ています。</span><span class="sxs-lookup"><span data-stu-id="98d05-436">The <xref:System.Xml.Serialization.XmlSerializer> security model is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="98d05-437">ただし、 <xref:System.Xml.Serialization.XmlSerializer>に固有の脅威がいくつか存在します。</span><span class="sxs-lookup"><span data-stu-id="98d05-437">A few threats, however, are unique to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>

<span data-ttu-id="98d05-438"><xref:System.Xml.Serialization.XmlSerializer> は、実際にシリアル化と逆シリアル化を実行するコードが含まれた *シリアル化アセンブリ* を実行時に生成します。これらのアセンブリは、ファイルの一時ディレクトリに作成されます。</span><span class="sxs-lookup"><span data-stu-id="98d05-438">The <xref:System.Xml.Serialization.XmlSerializer> generates *serialization assemblies* at runtime that contain code that actually serializes and deserializes; these assemblies are created in a temporary files directory.</span></span> <span data-ttu-id="98d05-439">他のプロセスまたはユーザーがこのディレクトリにアクセスできる場合は、シリアル化または逆シリアル化のコードが任意のコードで上書きされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-439">If some other process or user has access rights to that directory, they may overwrite the serialization/deserialization code with arbitrary code.</span></span> <span data-ttu-id="98d05-440">その結果、シリアル化または逆シリアル化のコードではなく、上書き後のコードのセキュリティ コンテキストを使用して、 <xref:System.Xml.Serialization.XmlSerializer> がこのコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="98d05-440">The <xref:System.Xml.Serialization.XmlSerializer> then runs this code using its security context, instead of the serialization/deserialization code.</span></span> <span data-ttu-id="98d05-441">一時ファイルのディレクトリへのアクセス許可が適切に設定されていることを確認し、この状況が起こらないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="98d05-441">Make sure the permissions are set correctly on the temporary files directory to prevent this from happening.</span></span>

<span data-ttu-id="98d05-442"><xref:System.Xml.Serialization.XmlSerializer> には、シリアル化アセンブリを実行時に生成するのではなく、事前生成済みのシリアル化アセンブリを使用するモードもあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-442">The <xref:System.Xml.Serialization.XmlSerializer> also has a mode in which it uses pre-generated serialization assemblies instead of generating them at runtime.</span></span> <span data-ttu-id="98d05-443">このモードは、 <xref:System.Xml.Serialization.XmlSerializer> が適切なシリアル化アセンブリを検出できるとトリガーされます。</span><span class="sxs-lookup"><span data-stu-id="98d05-443">This mode is triggered whenever the <xref:System.Xml.Serialization.XmlSerializer> can find a suitable serialization assembly.</span></span> <span data-ttu-id="98d05-444"><xref:System.Xml.Serialization.XmlSerializer> は、シリアル化アセンブリの署名に使用されているキーが、シリアル化する型を含むアセンブリの署名に使用されたものと同じであるかどうかをチェックします。</span><span class="sxs-lookup"><span data-stu-id="98d05-444">The <xref:System.Xml.Serialization.XmlSerializer> checks whether or not the serialization assembly was signed by the same key that was used to sign the assembly that contains the types being serialized.</span></span> <span data-ttu-id="98d05-445">このチェックによって、シリアル化アセンブリに偽装した悪質なアセンブリからの保護が可能になります。</span><span class="sxs-lookup"><span data-stu-id="98d05-445">This offers protection from malicious assemblies being disguised as serialization assemblies.</span></span> <span data-ttu-id="98d05-446">ただし、シリアル化可能な型を含むアセンブリが署名されていない場合、 <xref:System.Xml.Serialization.XmlSerializer> はこのチェックを実行できず、正しい名前を持つ任意のアセンブリを使用することになります。</span><span class="sxs-lookup"><span data-stu-id="98d05-446">However, if the assembly that contains your serializable types is not signed, the <xref:System.Xml.Serialization.XmlSerializer> cannot perform this check and uses any assembly with the correct name.</span></span> <span data-ttu-id="98d05-447">これによって、悪質なコードの実行が生じる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-447">This makes running malicious code possible.</span></span> <span data-ttu-id="98d05-448">シリアル化可能な型が属するアセンブリに必ず署名するか、アプリケーション ディレクトリとグローバル アセンブリ キャッシュへのアクセスを厳密に制御することによって、悪質なアセンブリの侵入を防止します。</span><span class="sxs-lookup"><span data-stu-id="98d05-448">Always sign the assemblies that contain your serializable types, or tightly control access to your application’s directory and the global assembly cache to prevent the introduction of malicious assemblies.</span></span>

<span data-ttu-id="98d05-449"><xref:System.Xml.Serialization.XmlSerializer> は、サービス拒否攻撃にもさらされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-449">The <xref:System.Xml.Serialization.XmlSerializer> can be subject to a denial of service attack.</span></span> <span data-ttu-id="98d05-450"><xref:System.Xml.Serialization.XmlSerializer> には、( `MaxItemsInObjectGraph` で利用できるような) <xref:System.Runtime.Serialization.DataContractSerializer>クォータがありません。</span><span class="sxs-lookup"><span data-stu-id="98d05-450">The <xref:System.Xml.Serialization.XmlSerializer> does not have a `MaxItemsInObjectGraph` quota (as is available on the <xref:System.Runtime.Serialization.DataContractSerializer>).</span></span> <span data-ttu-id="98d05-451">したがって、逆シリアル化されるオブジェクトの量は、メッセージ サイズによってのみ制限されるため、不定になります。</span><span class="sxs-lookup"><span data-stu-id="98d05-451">Thus, it deserializes an arbitrary amount of objects, limited only by the message size.</span></span>

### <a name="partial-trust-threats"></a><span data-ttu-id="98d05-452">部分信頼に関する脅威</span><span class="sxs-lookup"><span data-stu-id="98d05-452">Partial Trust Threats</span></span>

<span data-ttu-id="98d05-453">部分信頼で実行されているコードに関連する脅威について、以下の懸念事項に注意してください。</span><span class="sxs-lookup"><span data-stu-id="98d05-453">Note the following concerns regarding threats related to code running with partial trust.</span></span> <span data-ttu-id="98d05-454">これらの脅威には、悪質な部分信頼コードと、他の攻撃シナリオと結びついた悪質な部分信頼コード (特定の文字列を作成し、それを逆シリアル化する部分信頼コードなど) があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-454">These threats include malicious partially-trusted code as well as malicious partially-trusted code in combination with other attack scenarios (for example, partially-trusted code that constructs a specific string and then deserializing it).</span></span>

- <span data-ttu-id="98d05-455">シリアル化コンポーネントを使用するときは、使用前にどのアクセス許可もアサートしないでください。これは、シリアル化シナリオ全体がアサートのスコープ内であり、信頼できないデータまたはオブジェクトは処理しない場合も同様です。</span><span class="sxs-lookup"><span data-stu-id="98d05-455">When using any serialization components, never assert any permissions before such usage, even if the entire serialization scenario is within the scope of your assert, and you are not dealing with any untrusted data or objects.</span></span> <span data-ttu-id="98d05-456">アクセス許可をアサートすると、セキュリティ上の脆弱性の原因となる場合があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-456">Such usage may lead to security vulnerabilities.</span></span>

- <span data-ttu-id="98d05-457">部分信頼コードで拡張ポイント (サロゲート)、シリアル化する型、または他の方法によってシリアル化プロセスを制御している場合、部分信頼コードが原因でシリアライザーが大量のデータをシリアル化ストリームに出力し、このストリームの受信側に対してサービス拒否 (DoS: Denial of Service) を引き起こす可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-457">In cases where partially-trusted code has control over the serialization process, either through extensibility points (surrogates), types being serialized, or through other means, the partially-trusted code may cause the serializer to output a large amount of data into the serialized stream, which may cause Denial of Service (DoS) to the receiver of this stream.</span></span> <span data-ttu-id="98d05-458">DoS の脅威の影響を受けやすいターゲットを対象とするデータをシリアル化する場合、部分信頼の型をシリアル化したり、部分信頼コードでシリアル化を制御したりしないでください。</span><span class="sxs-lookup"><span data-stu-id="98d05-458">If you are serializing data intended for a target that is sensitive to DoS threats, do not serialize partially-trusted types or otherwise let partially-trusted code control serialization.</span></span>

- <span data-ttu-id="98d05-459">部分信頼コードがインスタンスにアクセスできるようにする場合 <xref:System.Runtime.Serialization.DataContractSerializer> 、または [データコントラクトサロゲート](../extending/data-contract-surrogates.md)を制御する場合は、シリアル化と逆シリアル化のプロセスを細かく制御することが必要になることがあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-459">If you allow partially-trusted code access to your <xref:System.Runtime.Serialization.DataContractSerializer> instance or otherwise control the [Data Contract Surrogates](../extending/data-contract-surrogates.md), it may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="98d05-460">たとえば、コードによって任意の型が挿入されたり、情報漏えいにつながったりする場合があります。また、生成されたオブジェクト グラフやシリアル化されたデータが改ざんされたり、生成されたシリアル化ストリームをオーバーフローさせたりする場合もあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-460">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span> <span data-ttu-id="98d05-461"><xref:System.Runtime.Serialization.NetDataContractSerializer> に関する同等の脅威については、「NetDataContractSerializer の安全な使用」で説明しています。</span><span class="sxs-lookup"><span data-stu-id="98d05-461">An equivalent <xref:System.Runtime.Serialization.NetDataContractSerializer> threat is described in the "Using the NetDataContractSerializer Securely" section.</span></span>

- <span data-ttu-id="98d05-462"><xref:System.Runtime.Serialization.DataContractAttribute> 属性が型 (または <xref:System.SerializableAttribute> ではなく <xref:System.Runtime.Serialization.ISerializable>とマークされた型) に適用されている場合、すべてのコンストラクターが非パブリックであるか、または要求で保護されている場合でも、デシリアライザーはこのような型のインスタンスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="98d05-462">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a type (or the type marked as <xref:System.SerializableAttribute> but is not <xref:System.Runtime.Serialization.ISerializable>), the deserializer can create an instance of such a type even if all constructors are non-public or protected by demands.</span></span>

- <span data-ttu-id="98d05-463">逆シリアル化されるデータが信頼できるものであり、すべての既知の型が信頼した型であることが確実である場合を除き、逆シリアル化の結果を信頼しないでください。</span><span class="sxs-lookup"><span data-stu-id="98d05-463">Never trust the result of deserialization unless the data to be deserialized is trusted and you are certain that all known types are types that you trust.</span></span> <span data-ttu-id="98d05-464">部分信頼で実行されている場合、既知の型はアプリケーション構成ファイルから読み込まれません (ただし、コンピューター構成ファイルからは読み込まれます)。</span><span class="sxs-lookup"><span data-stu-id="98d05-464">Note that known types are not loaded from the application configuration file, (but are loaded from the computer configuration file) when running in partial trust.</span></span>

- <span data-ttu-id="98d05-465">部分信頼コードに追加されたサロゲートと共に <xref:System.Runtime.Serialization.DataContractSerializer> インスタンスを渡すと、コードによってそのサロゲートの変更可能な設定が変更される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-465">If you pass a <xref:System.Runtime.Serialization.DataContractSerializer> instance with a surrogate added to partially-trusted code, the code can change any modifiable settings on that surrogate.</span></span>

- <span data-ttu-id="98d05-466">逆シリアル化されたオブジェクトでは、XML リーダー (またはそれに含まれるデータ) が部分信頼コードからのものである場合、結果の逆シリアル化されたオブジェクトを信頼できないデータとして扱ってください。</span><span class="sxs-lookup"><span data-stu-id="98d05-466">For a deserialized object, if the XML reader (or the data therein) comes from partially-trusted code, treat the resulting deserialized object as untrusted data.</span></span>

- <span data-ttu-id="98d05-467"><xref:System.Runtime.Serialization.ExtensionDataObject> 型がパブリック メンバーを含んでいなくても、それに含まれるデータが安全であるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="98d05-467">The fact that the <xref:System.Runtime.Serialization.ExtensionDataObject> type has no public members does not mean that data within it is secure.</span></span> <span data-ttu-id="98d05-468">たとえば、特権が付与されたデータ ソースから、いくつかのデータを含むオブジェクトに逆シリアル化し、そのオブジェクトを部分信頼コードに渡した場合、部分信頼コードは、オブジェクトをシリアル化して `ExtensionDataObject` のデータを読み取ることができます。</span><span class="sxs-lookup"><span data-stu-id="98d05-468">For example, if you deserialize from a privileged data source into an object in which some data resides, then hand that object to partially-trusted code, the partially-trusted code can read the data in the `ExtensionDataObject` by serializing the object.</span></span> <span data-ttu-id="98d05-469">特権が付与されたデータ ソースから、後で部分信頼コードに渡されるオブジェクトに逆シリアル化する場合は、 <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> を `true` に設定するよう考慮してください。</span><span class="sxs-lookup"><span data-stu-id="98d05-469">Consider setting <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> to `true` when deserializing from a privileged data source into an object that is later passed to partially-trusted code.</span></span>

- <span data-ttu-id="98d05-470">完全信頼では、<xref:System.Runtime.Serialization.DataContractSerializer> および <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> support the serialization of private, protected, internal, および public members in full trust.</span><span class="sxs-lookup"><span data-stu-id="98d05-470"><xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> support the serialization of private, protected, internal, and public members in full trust.</span></span> <span data-ttu-id="98d05-471">一方、部分信頼ではパブリック メンバーのシリアル化のみが可能です。</span><span class="sxs-lookup"><span data-stu-id="98d05-471">However, in partial trust, only public members can be serialized.</span></span> <span data-ttu-id="98d05-472">アプリケーションがパブリック メンバー以外のメンバーのシリアル化を試みると、 <xref:System.Security.SecurityException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="98d05-472">A <xref:System.Security.SecurityException> is thrown if an application attempts to serialize a non-public member.</span></span>

    <span data-ttu-id="98d05-473">部分信頼で内部メンバーまたはプロテクト内部メンバーをシリアル化するには、 <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> アセンブリ属性を使用します。</span><span class="sxs-lookup"><span data-stu-id="98d05-473">To allow internal or protected internal members to be serialized in partial trust, use the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> assembly attribute.</span></span> <span data-ttu-id="98d05-474">この属性を使用すると、アセンブリは内部メンバーが他のアセンブリから参照できることを宣言できます。</span><span class="sxs-lookup"><span data-stu-id="98d05-474">This attribute allows an assembly to declare that its internal members are visible to some other assembly.</span></span> <span data-ttu-id="98d05-475">この場合、内部メンバーのシリアル化が必要なアセンブリは、その内部メンバーが System.Runtime.Serialization.dll から参照できることを宣言します。</span><span class="sxs-lookup"><span data-stu-id="98d05-475">In this case, an assembly that wants to have its internal members serialized declares that its internal members are visible to System.Runtime.Serialization.dll.</span></span>

    <span data-ttu-id="98d05-476">この方法の利点は、昇格されたコード生成パスが不要なことです。</span><span class="sxs-lookup"><span data-stu-id="98d05-476">The advantage of this approach is that it does not require an elevated code generation path.</span></span>

    <span data-ttu-id="98d05-477">ただし、2 つの大きな欠点もあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-477">At the same time, there are two major disadvantages.</span></span>

    <span data-ttu-id="98d05-478">1 つ目の欠点は、 <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> 属性のオプトイン プロパティがアセンブリ全体に適用されることです。</span><span class="sxs-lookup"><span data-stu-id="98d05-478">The first disadvantage is that the opt-in property of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute is assembly-wide.</span></span> <span data-ttu-id="98d05-479">つまり、特定のクラスに対してのみ内部メンバーのシリアル化を可能にするような指定はできません。</span><span class="sxs-lookup"><span data-stu-id="98d05-479">That is, you cannot specify that only a certain class can have its internal members serialized.</span></span> <span data-ttu-id="98d05-480">もちろん、 <xref:System.Runtime.Serialization.DataMemberAttribute> 属性をメンバーに追加しないことで、特定の内部メンバーをシリアル化しないことは可能です。</span><span class="sxs-lookup"><span data-stu-id="98d05-480">Of course, you can still choose not to serialize a specific internal member, by simply not adding a <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to that member.</span></span> <span data-ttu-id="98d05-481">同様に、メンバーをプライベート メンバーまたはプロテクト メンバーではなく内部メンバーにすることもできますが、参照可能範囲の問題が残ります。</span><span class="sxs-lookup"><span data-stu-id="98d05-481">Similarly, a developer can also choose to make a member internal rather than private or protected, with slight visibility concerns.</span></span>

    <span data-ttu-id="98d05-482">2 つ目の欠点は、プライベート メンバーやプロテクト メンバーがサポートされないことです。</span><span class="sxs-lookup"><span data-stu-id="98d05-482">The second disadvantage is that it still does not support private or protected members.</span></span>

    <span data-ttu-id="98d05-483">部分信頼での <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> 属性の使用を理解するために、次のプログラムについて考えてみましょう。</span><span class="sxs-lookup"><span data-stu-id="98d05-483">To illustrate the use of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute in partial trust, consider the following program:</span></span>

    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#1)]

    <span data-ttu-id="98d05-484">上の例で、 `PermissionsHelper.InternetZone` は部分信頼の <xref:System.Security.PermissionSet> に対応します。</span><span class="sxs-lookup"><span data-stu-id="98d05-484">In the example above, `PermissionsHelper.InternetZone` corresponds to the <xref:System.Security.PermissionSet> for partial trust.</span></span> <span data-ttu-id="98d05-485">属性を指定しないと、 <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> アプリケーションは失敗し、 <xref:System.Security.SecurityException> 非パブリックメンバーが部分信頼でシリアル化できないことを示すがスローされます。</span><span class="sxs-lookup"><span data-stu-id="98d05-485">Now, without the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute, the application will fail, throwing a <xref:System.Security.SecurityException> indicating that non-public members cannot be serialized in partial trust.</span></span>

    <span data-ttu-id="98d05-486">ただし、ソース ファイルに次の行を追加すると、プログラムは正常に実行されます。</span><span class="sxs-lookup"><span data-stu-id="98d05-486">However, if we add the following line to the source file, the program runs successfully.</span></span>

    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#2)]

## <a name="other-state-management-concerns"></a><span data-ttu-id="98d05-487">状態管理に関するその他の注意事項</span><span class="sxs-lookup"><span data-stu-id="98d05-487">Other State Management Concerns</span></span>

<span data-ttu-id="98d05-488">オブジェクトの状態管理に関してその他の注意すべき点を以下に示します。</span><span class="sxs-lookup"><span data-stu-id="98d05-488">A few other concerns regarding object state management are worth mentioning:</span></span>

- <span data-ttu-id="98d05-489">ストリーミング トランスポートでストリーム ベースのプログラミング モデルを使用した場合、メッセージが到着するとメッセージの処理が開始されます。</span><span class="sxs-lookup"><span data-stu-id="98d05-489">When using the stream-based programming model with a streaming transport, processing of the message occurs as the message arrives.</span></span> <span data-ttu-id="98d05-490">メッセージの送信側によってストリームの途中で送信操作が中止されることはあり得ますが、このとき続きのコンテンツを待機していた場合、コードの状態を予想できなくなります。</span><span class="sxs-lookup"><span data-stu-id="98d05-490">The sender of the message may abort the send operation in the middle of the stream, leaving your code in an unpredictable state if more content was expected.</span></span> <span data-ttu-id="98d05-491">一般に、ストリームは完全であると考えないでください。また、ストリーミングが中止されたときにロールバックできないようなストリーム ベースの操作では、処理を行わないでください。</span><span class="sxs-lookup"><span data-stu-id="98d05-491">In general, do not rely on the stream being complete, and do not perform any work in a stream-based operation that cannot be rolled back in case the stream is aborted.</span></span> <span data-ttu-id="98d05-492">このことは、ストリーミングの本文の後に続くメッセージの形式が正しくない可能性があるような状況にも当てはまります (たとえば、SOAP エンベロープの終了タグが不足している、または 2 つ目のメッセージ本文があるなど)。</span><span class="sxs-lookup"><span data-stu-id="98d05-492">This also applies to the situation where a message may be malformed after the streaming body (for example, it may be missing an end tag for the SOAP envelope or may have a second message body).</span></span>

- <span data-ttu-id="98d05-493">`IExtensibleDataObject` 機能を使用すると、機密データが出力される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-493">Using the `IExtensibleDataObject` feature may cause sensitive data to be emitted.</span></span> <span data-ttu-id="98d05-494">`IExtensibleObjectData` を含むデータ コントラクトに、信頼できない送信元のデータを受け入れ、その後、メッセージが署名される、セキュリティで保護されたチャネルにそのデータを再送した場合、一切確認していないデータを保証していることになります。</span><span class="sxs-lookup"><span data-stu-id="98d05-494">If you are accepting data from an untrusted source into data contracts with `IExtensibleObjectData` and later re-emitting it on a secure channel where messages are signed, you are potentially vouching for data you know nothing about.</span></span> <span data-ttu-id="98d05-495">さらに、既知のデータと不明なデータの両方を考慮すると、送信している全体の状態が無効になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-495">Moreover, the overall state you are sending may be invalid if you take both the known and unknown pieces of data into account.</span></span> <span data-ttu-id="98d05-496">このような状況を回避するには、拡張データ プロパティを `null` に設定するか、 `IExtensibleObjectData` 機能を無効にします。</span><span class="sxs-lookup"><span data-stu-id="98d05-496">Avoid this situation by either selectively setting the extension data property to `null` or by selectively disabling the `IExtensibleObjectData` feature.</span></span>

## <a name="schema-import"></a><span data-ttu-id="98d05-497">スキーマのインポート</span><span class="sxs-lookup"><span data-stu-id="98d05-497">Schema Import</span></span>

<span data-ttu-id="98d05-498">通常、型を生成するためにスキーマをインポートするプロセスは、設計時にのみ発生します。たとえば、クライアント クラスを生成するために Web サービス上で [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md) を使用しているときなどです。</span><span class="sxs-lookup"><span data-stu-id="98d05-498">Normally, the process of importing schema to generate types happens only at design time, for example, when using the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md) on a Web service to generate a client class.</span></span> <span data-ttu-id="98d05-499">ただし、さらに高度なシナリオでは、スキーマを実行時に処理することがあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-499">However, in more advanced scenarios, you may process schema at runtime.</span></span> <span data-ttu-id="98d05-500">この場合、サービス拒否攻撃の危険にさらされる可能性があることを覚えておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-500">Be aware that doing so can expose you to denial-of-service risks.</span></span> <span data-ttu-id="98d05-501">スキーマによっては、インポートに時間がかかる場合があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-501">Some schema may take a long time to be imported.</span></span> <span data-ttu-id="98d05-502">スキーマが信頼できないソースからのものである可能性がある場合は、このようなシナリオで <xref:System.Xml.Serialization.XmlSerializer> のスキーマ インポート コンポーネントを使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="98d05-502">Never use the <xref:System.Xml.Serialization.XmlSerializer> schema import component in such scenarios if schemas are possibly coming from an untrusted source.</span></span>

## <a name="threats-specific-to-aspnet-ajax-integration"></a><span data-ttu-id="98d05-503">ASP.NET AJAX 統合に固有の脅威</span><span class="sxs-lookup"><span data-stu-id="98d05-503">Threats Specific to ASP.NET AJAX Integration</span></span>

<span data-ttu-id="98d05-504">ユーザーが <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> またはを実装すると <xref:System.ServiceModel.Description.WebHttpBehavior> 、WCF は XML メッセージと JSON メッセージの両方を受け入れることができるエンドポイントを公開します。</span><span class="sxs-lookup"><span data-stu-id="98d05-504">When the user implements <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> or <xref:System.ServiceModel.Description.WebHttpBehavior>, WCF exposes an endpoint that can accept both XML and JSON messages.</span></span> <span data-ttu-id="98d05-505">ただし、XML リーダーと JSON リーダーの両方が使用するリーダー クォータのセットは 1 つしかありません。</span><span class="sxs-lookup"><span data-stu-id="98d05-505">However, there is only one set of reader quotas, used both by the XML reader and the JSON reader.</span></span> <span data-ttu-id="98d05-506">一部のクォータ設定が一方のリーダーには適切であっても、もう一方のリーダーには大きすぎる場合があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-506">Some quota settings may be appropriate for one reader but too large for the other.</span></span>

<span data-ttu-id="98d05-507">`WebScriptEnablingBehavior`を実装すると、ユーザーはエンドポイントで JavaScript プロキシを公開するオプションを使用できます。</span><span class="sxs-lookup"><span data-stu-id="98d05-507">When implementing `WebScriptEnablingBehavior`, the user has the option to expose a JavaScript proxy at the endpoint.</span></span> <span data-ttu-id="98d05-508">セキュリティに関する次の問題を考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-508">The following security issues must be considered:</span></span>

- <span data-ttu-id="98d05-509">JavaScript プロキシを調べることで、サービスに関する情報 (操作名、パラメーター名など) を取得できます。</span><span class="sxs-lookup"><span data-stu-id="98d05-509">Information about the service (operation names, parameter names, and so on) can be obtained by examining the JavaScript proxy.</span></span>

- <span data-ttu-id="98d05-510">JavaScript エンドポイントを使用すると、機密性の高い情報やプライベートな情報がクライアントの Web ブラウザーのキャッシュに保持される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="98d05-510">When using the JavaScript endpoint, sensitive and private information might be retained in the client Web browser cache.</span></span>

## <a name="a-note-on-components"></a><span data-ttu-id="98d05-511">コンポーネントに関する注意事項</span><span class="sxs-lookup"><span data-stu-id="98d05-511">A Note on Components</span></span>

<span data-ttu-id="98d05-512">WCF は、柔軟でカスタマイズ可能なシステムです。</span><span class="sxs-lookup"><span data-stu-id="98d05-512">WCF is a flexible and customizable system.</span></span> <span data-ttu-id="98d05-513">このトピックのほとんどの内容は、最も一般的な WCF 使用シナリオに焦点を当てています。</span><span class="sxs-lookup"><span data-stu-id="98d05-513">Most of the contents of this topic focus on the most common WCF usage scenarios.</span></span> <span data-ttu-id="98d05-514">ただし、WCF に用意されているコンポーネントは、さまざまな方法で構成できます。</span><span class="sxs-lookup"><span data-stu-id="98d05-514">However, it is possible to compose components WCF provides in many different ways.</span></span> <span data-ttu-id="98d05-515">各コンポーネントを使用した場合のセキュリティへの影響について理解することが重要です。</span><span class="sxs-lookup"><span data-stu-id="98d05-515">It is important to understand the security implications of using each component.</span></span> <span data-ttu-id="98d05-516">特に次の点に違いがあります。</span><span class="sxs-lookup"><span data-stu-id="98d05-516">In particular:</span></span>

- <span data-ttu-id="98d05-517">XML リーダーを使用する必要があるときは、 <xref:System.Xml.XmlDictionaryReader> クラスに用意されたリーダーを使用し、それ以外のリーダーは使用しないようにします。</span><span class="sxs-lookup"><span data-stu-id="98d05-517">When you must use XML readers, use the readers the <xref:System.Xml.XmlDictionaryReader> class provides as opposed to any other readers.</span></span> <span data-ttu-id="98d05-518">安全なリーダーは、 <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>、 <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>、 <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> のいずれかのメソッドを使用して作成できます。</span><span class="sxs-lookup"><span data-stu-id="98d05-518">Safe readers are created using <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> methods.</span></span> <span data-ttu-id="98d05-519"><xref:System.Xml.XmlReader.Create%2A> メソッドは使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="98d05-519">Do not use the <xref:System.Xml.XmlReader.Create%2A> method.</span></span> <span data-ttu-id="98d05-520">リーダーは、必ず安全なクォータを使用して設定します。</span><span class="sxs-lookup"><span data-stu-id="98d05-520">Always configure the readers with safe quotas.</span></span> <span data-ttu-id="98d05-521">Wcf のシリアル化エンジンは、WCF のセキュリティで保護された XML リーダーと共に使用する場合にのみ、セキュリティで保護されます。</span><span class="sxs-lookup"><span data-stu-id="98d05-521">The serialization engines in WCF are secure only when used with secure XML readers from WCF.</span></span>

- <span data-ttu-id="98d05-522"><xref:System.Runtime.Serialization.DataContractSerializer> を使用して、信頼できない可能性のあるデータを逆シリアル化する場合は、必ず <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> プロパティを設定します。</span><span class="sxs-lookup"><span data-stu-id="98d05-522">When using the <xref:System.Runtime.Serialization.DataContractSerializer> to deserialize potentially untrusted data, always set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property.</span></span>

- <span data-ttu-id="98d05-523">メッセージを作成する場合、 `maxSizeOfHeaders` による保護が十分でないときは `MaxReceivedMessageSize` パラメーターを設定します。</span><span class="sxs-lookup"><span data-stu-id="98d05-523">When creating a message, set the `maxSizeOfHeaders` parameter if `MaxReceivedMessageSize` does not offer enough protection.</span></span>

- <span data-ttu-id="98d05-524">エンコーダーを作成する場合、 `MaxSessionSize` や `MaxBufferSize`などの関連クォータを必ず設定します。</span><span class="sxs-lookup"><span data-stu-id="98d05-524">When creating an encoder, always configure the relevant quotas, such as `MaxSessionSize` and `MaxBufferSize`.</span></span>

- <span data-ttu-id="98d05-525">XPath メッセージ フィルターを使用する場合は、 <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> を設定してそのフィルターがアクセスする XML ノードの量を制限します。</span><span class="sxs-lookup"><span data-stu-id="98d05-525">When using an XPath message filter, set the <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> to limit the amount of XML nodes the filter visits.</span></span> <span data-ttu-id="98d05-526">多数のノードにアクセスせず、計算に長い時間がかかる可能性がある XPath 式は使用しないようにします。</span><span class="sxs-lookup"><span data-stu-id="98d05-526">Do not use XPath expressions that could take a long time to compute without visiting many nodes.</span></span>

- <span data-ttu-id="98d05-527">通常、クォータを受け入れるコンポーネントを使用する場合は、そのセキュリティへの影響を理解し、クォータを安全な値に設定します。</span><span class="sxs-lookup"><span data-stu-id="98d05-527">In general, when using any component that accepts a quota, understand its security implications and set it to a safe value.</span></span>

## <a name="see-also"></a><span data-ttu-id="98d05-528">関連項目</span><span class="sxs-lookup"><span data-stu-id="98d05-528">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.XmlDictionaryReader>
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="98d05-529">既知のデータ コントラクト型</span><span class="sxs-lookup"><span data-stu-id="98d05-529">Data Contract Known Types</span></span>](data-contract-known-types.md)
